///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := BINARY_TREES;
  
  - bibliography := "http://IsaacOS.com";
  - author       := "Xavier Oswald (x.oswald@free.fr)";
  - comment      := "Language shootout - binary-trees"; 
  
Section Inherit
  
  - parent_any:OBJECT := OBJECT;

Section Private

  - min_depth :INTEGER := 4;

Section Public
 
  - main <-
  ( + n, check        :INTEGER;
    + max_depth       :INTEGER;
    + stretch_depth   :INTEGER;
    + depth           :INTEGER;
    + iterations      :INTEGER;
    + long_lived_tree :TREENODE;

    (COMMAND_LINE.upper = 1).if {
      n := COMMAND_LINE.item 1.to_integer;
    };
    
    (min_depth + 2 > n).if {
      max_depth := min_depth+2;
    } else {
      max_depth := n;
    };
    stretch_depth := max_depth+1;
    check := TREENODE.bottom_up_tree (0,stretch_depth).item_check;

    "stretch tree of depth ".print;
    stretch_depth.print;
    "\t check: ".print;
    check.print;
    '\n'.print;
    
    long_lived_tree := TREENODE.bottom_up_tree (0, max_depth);
    depth := min_depth;
    {depth <= max_depth}.while_do {
      iterations := 1 << (max_depth - depth  + min_depth);
      check := 0;
      1.to iterations do { i:INTEGER;
        check := check + TREENODE.bottom_up_tree (i,depth) .item_check;
        check := check + TREENODE.bottom_up_tree (-i,depth).item_check;
      };
      (iterations * 2).print;
      "\t trees of depth ".print;
      depth.print;
      "\t check: ".print;
      check.print;
      '\n'.print;
      depth := depth + 2;
    };
    
    "long lived tree of depth ".print;
    max_depth.print;
    "\t check: ".print;
    long_lived_tree.item_check.print;
    '\n'.print;
  );
