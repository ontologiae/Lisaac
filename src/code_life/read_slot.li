Section Header

  + name    := READ_SLOT;

  - comment := "Read for slot";

Section Inherit

  + parent_read:Expanded READ;

Section Public

  - is_slot:BOOLEAN <- TRUE;

  - is_invariant:BOOLEAN <- slot.is_invariant receiver;

  + slot:SLOT_DATA;

  + receiver:EXPR;

  - variable:VARIABLE <- slot;

  - get_last_value:EXPR <- variable.get_last_value receiver;

  //
  // Comparison.
  //

  - Self:SELF '~=' Right 60 other:EXPR :BOOLEAN <-
  ( + rd:READ_SLOT;

    rd ?= other;
    ((rd != NULL) && {slot = rd.slot} && {receiver ~= rd.receiver})
  );

Section SLOT

  //
  // Creation.
  //

  - create p:POSITION with (r:EXPR,s:SLOT_DATA) :SELF <-
  ( + result:SELF;

    result := clone;
    result.make p with (r,s);
    result
  );

  - make p:POSITION with (r:EXPR,s:SLOT_DATA) <-
  (
    position := p;
    receiver := r;
    slot     := s;
  );

Section Public

  - my_copy:SELF <-
  ( + result:SELF;

    result ?= slot.read position with (receiver.my_copy);
    result
  );

  //
  // Executing pass.
  //

  - remove <-
  (
    receiver.remove;
    parent_read.remove;
  );

  - execute_access_unlink:INSTR <-
  (
    slot.execute;
    receiver.execute_unlink
  );

  - execute_access_link <-
  (
    slot.execute;
    receiver := receiver.execute_link;
  );

  //
  // Genere
  //

  - genere buffer:STRING_BUFFER <-
  ( + tf,tf2:TYPE_FULL;
    + t:TYPE;
    + add_end:BOOLEAN;
    + ptr,ptr2:BOOLEAN;

    (slot.intern_name = "self").if {
      buffer.append "((";
      tf := slot.type;
      tf.genere_declaration buffer;
      buffer.add_last ' ';
      tf.genere_star_declaration buffer;
      buffer.add_last ')';
      receiver.genere buffer;
      buffer.append ".self)";
    } else {
      tf := receiver.static_type;
      t  := slot.receiver_type;
      (t.alias_slot != NULL).if {
        tf2 := slot.type;
        ptr  := (! tf .is_expanded) || {tf .is_expanded_ref} || {tf .is_strict};
        ptr2 := (! tf2.is_expanded) || {tf2.is_expanded_ref} || {tf2.is_strict};
        (ptr != ptr2).if {
          add_end := TRUE;
          (ptr).if {
            buffer.append "(*(";
          } else {
            buffer.append "(&(";
          };
        };
      };
      (
        (tf.is_strict) || {tf.is_expanded_ref} || {tf.is_expanded}
      ).if {        
        receiver.genere buffer;
      } else {
        buffer.append "((";
        t.put_reference_declaration buffer;
        buffer.add_last ' ';
        t.put_reference_star_declaration buffer;
        buffer.add_last ')';
        receiver.genere buffer;
        buffer.add_last ')';
      };
      (t.alias_slot = NULL).if {
        ((tf.is_expanded) && {! tf.is_expanded_ref} && {! tf.is_strict}).if {
          buffer.add_last '.';
        } else {
          buffer.append "->";
        };
        buffer.append (variable.intern_name);
      }.elseif {add_end} then {
        buffer.append "))";
      };
    };
  );
  
  //
  // Display.
  //

  - display buffer:STRING_BUFFER <-
  (
    receiver.display buffer;
    buffer.append "->";
    parent_read.display buffer;
  );










