///////////////////////////////////////////////////////////////////////////////
//                             Lisaac Example                                //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name      := FORMAT_BCT;

  - copyright := "2003-2008 Sonntag Benoit";

  - author    := "Sonntag Benoit (sonntag@icps.u-strasbg.fr)";

Section Inherit

  - parent_any:ANY := ANY;

Section Public
  
  - load file:FILE :BOOLEAN <-
  ( + buf:FAST_ARRAY(UINTEGER_8);
    + pos,length:INTEGER;
    + result:BOOLEAN;
    + picture_size:INTEGER;
    + lst:LINKED_LIST(GRAPH);
    + mark:MARK;
          
    // Read file.
    length := file.size;        
    buf := FAST_ARRAY(UINTEGER_8).create_with_capacity length;
    file.read buf size length;
        
    // Version verification.
    (buf.item 0 <= 010h).if {
      result := TRUE;      
      pos := pos + 1;
      // Read Page parameter.
      pos := page.make_with buf at pos;
      
      // Read magnetic mark.
      pos := pos + 1;
      
      // Read small picture.      
      picture_size := read_uinteger_16 buf at pos;
      //pos := pos + 2;
            
      //DeCompressRLE((unsigned char *)&Buf[33],Win);
      pos := pos + picture_size;
      
      // Read graphs.            
      (lst,pos) := load_draw_with buf at pos parent NULL;
      page.set_list_graph lst;
      
      // Read mark.
      page.list_mark.clear;
      {pos < length}.while_do {
        (mark,pos) := MARK.create_with buf at pos;
        page.list_mark.add_last mark;      
      };
      // Compute select object.
      (page.list_graph.lower).to (page.list_graph.upper) do { j:INTEGER;
        page.list_graph.item j.compute_select;
      };
    };
    result
  );
  
Section SELF,GROUP
  
  
  //
  // Compress RLE
  //
  
  /*
  - compress_rle bmp:ABSTRACT_BITMAP :FAST_ARRAY(UINTEGER_8) <-
  [
    ? {bmp.width = 128};
    ? {bmp.height = 128};
  ]
  ( + src,dst:FAST_ARRAY(UINTEGER_8);
    + color_8,type,cpt:UINTEGER_8;
    + pos_src,pos_dst,pos_stat,x,y:INTEGER;
    + color_24:UINTEGER_32;
      
    src := FAST_ARRAY(UINTEGER_8).create_with_capacity 16384;
    dst := FAST_ARRAY(UINTEGER_8).create_with_capacity 16600;
    // Raw image.
    (bmp.y_min).to (bmp.y_max) do { y:INTEGER;
      (bmp.x_min).to (bmp.x_max) do { x:INTEGER;
        bmp.get_pixel_to (x,y);
        color_24 := bmp.rgbcolor;
        color_8  := (((color_24>>16)&0E0h)|((color_24>>11)&01Ch)|((color_24>>6)&003h)).to_uinteger_8;
        src.add_last color_8;
      };
    };    
    // Compress src.
    pos_stat := 2; 
    pos_dst  := 3; 
    pos_src  := 0; 
    type     := 080h; 
    cpt      := 0; // Mode Different.
    {
      (type != 0).if { 
        // Mode Different.
        (
          (pos_src < 16382) && 
          {src.item pos_src = src.item (pos_src+1)} && 
          {src.item pos_src = src.item (pos_src+2)}
        ).if {
          (cpt != 0).if { 
            dst.put ((cpt-1)|0x80) to pos_stat; 
            pos_dst := pos_dst + 1;
            pos_stat := pos_dst; 
            cpt := 0; 
          };
          type := 0; 
          color_8 := src.item pos_src;
        } else {
          bufD[PosD++]=bufS[PosS++]; cpt++;
          if ((PosS==16384L) || (cpt&0x80)) { bufD[PosEtat]=(cpt-1)|0x80; PosEtat=PosD++; cpt=0; };
        };
      } else { // Mode identique.
        (src.item pos_src != color_8).if {
          bufD[PosEtat]=cpt-1; 
          bufD[PosD++]=Coul; 
          PosEtat=PosD++; 
          cpt=0; 
          type=0x80;
        } else {
          PosS++; 
          cpt++;
          ((pos_src = 16384) || {cpt&080h != 0}).if { 
            bufD[PosEtat]=cpt-1; 
            bufD[PosD++]=Coul; 
            PosEtat=PosD++; 
            cpt=0; 
            type=0x80; 
          };
        };
      };
    }.do_while {pos_src != 16384};
    dst
  );
  */
  
  //
  // Decompress RLE
  //
  
  - decompress_rle buf:FAST_ARRAY(UINTEGER_8) in bmp:ABSTRACT_BITMAP <-
  ( + pos,x,y:INTEGER;
    + cpt:UINTEGER_8;
    + color_8,color_24:UINTEGER_32;
    
    {
      cpt := buf.item pos;
      (cpt & 080h != 0).if { 
        // Variable mode.
        pos := pos + 1;
        0.to (cpt & 7Fh) do { j:INTEGER;
          color_8  := buf.item pos; 
          color_24 := ((color_8 & 0E0h)<<16)|(((color_8<<3) & 0E0h)<<8)|((color_8<<6) & 0C0h);
          pixel_to (x,y) color color_24;
          x := x + 1;
          (x = 128).if { 
            x := 0; 
            y := y + 1;
          };
          pos := pos + 1;
        };
      } else { 
        // Copy mode.
        color_8 := buf.item (pos+1); 
        color_24 := ((color_8 & 0E0h)<<16)|(((color_8<<3)&0E0h)<<8)|((color_8<<6)&0C0h);
        color color_24;        
        0.to cpt do { j:INTEGER;
          pixel_to (x,y); 
          x := x + 1;
          (x = 128).if { 
            x := 0; 
            y := y + 1; 
          };
        };
        pos := pos + 2;
      };
    }.do_while {pos < buf.upper};    
  );
      
  // 
  // Load Graph.
  //

  - load_draw_with buf:FAST_ARRAY(UINTEGER_8) at ps:INTEGER 
  parent father:GRAPH :(LINKED_LIST(GRAPH),INTEGER) <-
  ( + result:LINKED_LIST(GRAPH);
    + type:UINTEGER_8;
    + pos:INTEGER;
    + graph:GRAPH;
    + select:SELECT;
    
    `/* LOAD */`;
    
    pos := ps;
    result := LINKED_LIST(GRAPH).create;
    {buf.item pos != 255}.while_do {      
      // Construction de l'objet.      
      type := buf.item pos;            
      pos := pos + 1;      
      (select,pos) := SELECT.create_with buf at pos;
      `/* BEGIN */`;
      (type)
      .when 0 then { // Group
        (graph,pos) := GROUP.create_with buf at pos;        
      }
      .when 1 then { // Curve
        (graph,pos) := FORM.create_with buf at pos;          
      }
      .when 2 then { // Rectangle 
        (graph,pos) := RECTANGLE.create_with buf at pos;
      }
      .when 3 then { // Ellipse 
        (graph,pos) := ELLIPSE.create_with buf at pos;
      }
      .when 4 then { // Text
        (graph,pos) := TEXT.create_with buf at pos;          
      };
      `/* END */`;
      graph.set_select select parent father;
      result.add_last graph;
    };
    pos := pos + 1;
    result,pos
  );


/*
void LoadImgBCT(int File,struct WINDOW *Win)
{ unsigned char *Buf;
  unsigned short Size;
  // Est-ce un ancien fichier BCT :
  unsigned char Tmp;
  struct WINDOW *OldWin=WinAct;

  read(File,&Tmp,1);
  if ((Tmp=='o') || (Tmp=='v')) { // Oui, c'est un ancien fichier ...
    WinAct=Win;
    setcolor(255,255,255);
    rectangle(0,0,127,127);
    setcolor(200,0,0);
    text(2,2,60,"Ancien fichier BCT !");
    WinAct=OldWin;
    return;
  };
  lseek(File,33,SEEK_SET);
  read(File,&Size,2);
  Buf=(unsigned char *)malloc(Size);
  lseek(File,33,SEEK_SET);
  read(File,Buf,Size);
  DeCompressRLE(Buf,Win);
  free(Buf);
};
*/

