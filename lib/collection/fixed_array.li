/****************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/
section HEADER
  
  + name     := FIXED_ARRAY[E];
  
  - category := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
  - comment     :="Resizable, fixed lower bound array.\
                  \Unlike ARRAY, the `lower' bound of a FIXED_ARRAY is frozen \
                  \to 0. Thus, some memory is saved and looping toward `lower' \
                  \bound (which is 0) run a little bit faster.";
  
section INHERIT
  
  * parent_arrayed_collection:ARRAYED_COLLECTION[E];
  
section PUBLIC

  - lower:INTEGER := 0;
  
  
  // Creation and modification:
  
  - create new_count:NUMERIC :SELF <-
  (
    + result:SELF;
    result := clone;
    result.make new_count;
    result
  );
  
  - create_with_capacity new_count:NUMERIC :SELF <-
  (
    + result:SELF;
    result := clone;
    result.with_capacity new_count;
    result
  );
  
  - make_with_map_object obj:OBJECT <-
  ( ? {obj.object_size!=0};
    ? {element_sizeof = 1};
    
    storage := NATIVE_ARRAY[E].force_conversion obj;
    capacity := obj.object_size;
    upper := -1;
    
    ? {storage!=NULL};
  );
    
  
  - make new_count:NUMERIC <-
  // Make array with range [0 .. `new_count' - 1].
  // When `new_count' = 0 the array is empty.
  (   
    + old_capacity:INTEGER;
    
    ? { new_count >= 0};
    
    old_capacity := capacity;
    ( new_count > capacity).if {
      // The new one is bigger:
      storage := NATIVE_ARRAY[E].calloc new_count;
      capacity := new_count;
    }.elseif { (capacity > 0) && { upper >= 0}} then { 
      // The new one is smaller and just need to be cleared:
      storage.clear 0 to upper;
    }; // end if
    upper := new_count - 1;
    
    ? { count = new_count };
    ? { capacity >= old_capacity };
    ? { all_default}; 
  ); // end make
    
  - with_capacity needed_capacity:NUMERIC <-
  // Create an empty array with at least `needed_capacity'.
  (
    ? { needed_capacity >= 0 };
    
    ( capacity < needed_capacity).if {
      storage := NATIVE_ARRAY[E].calloc needed_capacity;
      capacity := needed_capacity;
    }.elseif { capacity > needed_capacity } then {
      storage.clear 0 to upper;
    }; // end if
    upper := -1;
    
    ? { capacity >= needed_capacity };
    ? { is_empty };
    
  ); // end with_capacity
  
  
  
  // Modification:
  
  - resize new_count:NUMERIC <-
  // Resize the array. When `new_count' is greater than
  // `count', new positions are initialized with appropriate
  // default values.
  (
    + old_capacity:INTEGER;
    + new_capacity:INTEGER;
    
    ? {new_count >= 0};
    
    old_capacity := capacity;
    ( new_count > count).if {
      ( capacity = 0).if {
	storage := NATIVE_ARRAY[E].calloc new_count;
	capacity := new_count;
      }.elseif { capacity < new_count } then {
	new_capacity := capacity * 2;
	{ new_capacity >= new_count }.until_do {
	  new_capacity := new_capacity * 2;
	}; // end until_do
      }; // end if
      
      storage := storage.realloc capacity with new_capacity;
      capacity := new_capacity;
    }.elseif { new_count != count } then {
      storage.clear new_count to (count - 1);
    }; // end if
    
    upper := new_count - 1;
    
    ? { count = new_count };
    ? { capacity >= old_capacity };
    
  ); // end resize
  
  
  // Implementation of deferred:
  
  - is_empty :BOOLEAN <-
  ( + result:BOOLEAN;
    result := upper < 0;
    ? { result = (count = 0)};
    result
  ); // end is_empty
  
  
  
  - item i:NUMERIC :E <- // Infix "@"
  (
    ? { valid_index i};
    storage.item i
  ); // end item
  
  
  
  - put element:E to i:NUMERIC <-
  ( + old_count:INTEGER;
    old_count := count;
    ? { valid_index i};
    storage.put element to i;
    ? { item i = element};
    ? { count = old_count};
  ); // end put
  
  
  
  - add_first element:E <-
  ( + old_count,old_lower,old_upper:INTEGER;
    old_count := count;
    old_lower := lower;
    old_upper := upper;
    add_last element;
    ( upper = 0 ).if {
    }.elseif { upper = 1 } then {
      swap 0 with 1;
    } else {
      move 0 to (upper - 1) by 1;
      storage.put element to 0;
    }; // end if
    ? { first = element };
    ? { count = 1 + old_count };
    ? { lower = old_lower };
    ? { upper = 1 + old_upper };
  ); // end add_first
  
  
  
  - add_last element:E <-
  ( + old_count,old_lower,old_upper:INTEGER;
    + new_capacity:INTEGER;
    old_count := count;
    old_lower := lower;
    old_upper := upper;
    
    ( upper + 1 <= capacity - 1 ).if {
      upper := upper + 1;
    }.elseif { capacity = 0 } then {
      storage := NATIVE_ARRAY[E].calloc 2;
      capacity := 2;
      upper := 0
    } else {
      new_capacity := 2 * capacity;
      storage := storage.realloc capacity with new_capacity;
      capacity := new_capacity;
      upper := upper + 1;
    }; // end if
    
    storage.put element to upper;
     ? { last = element };
    ? { count = 1 + old_count };
    ? { lower = old_lower };
    ? { upper = 1 + old_upper };   
  ); // end add_last
  
  
  
  - count :INTEGER <-
  ( + result:INTEGER;
    result := upper + 1;
    ? {result = upper - lower + 1};
    result
  ); // end count
  
  
  
  - clear <-
  ( + old_capacity:INTEGER;
    old_capacity := capacity;
    upper := -1;
    ? { capacity = old_capacity };
    ? { is_empty };
  ); // end clear
  
  
  
  - copy other:SELF <-
  // Copy `other' onto Current.
  (
    + other_upper, new_capacity:INTEGER;
    
    other_upper := other.upper;
    
    ( other_upper >= 0 ).if {
      new_capacity := other_upper + 1;
      
      ( capacity < new_capacity ).if {
	storage := NATIVE_ARRAY[E].calloc new_capacity;
	capacity := new_capacity;
      }.elseif { capacity > 0 } then {
	storage.clear_all (capacity - 1);
      }; // end if
      storage.copy_from (other.storage) until other_upper;
    }.elseif { capacity > 0 } then {
      storage.clear_all (capacity - 1);
    }; // end if
    upper := other_upper;
  ); // end copy
  
  
  
  - set_all_with v:E <-
  ( + old_count:INTEGER;
    old_count := count;
    storage.set_all_with v until upper;
    ? { count = old_count };
  ) ; // end set_all_with
  
  
  
  - from_collection model:COLLECTION[E] <-
  ( + i1:INTEGER;
    ? { model != NULL };
    with_capacity model.count;
    upper := model.count - 1;
    i1 := 0;
    
    (model.lower).to (modele.upper) do { i2:INTEGER;
      storage.put (model.item i2) to i1;
      i1 := i1 + 1;
    }; // end do
    ? { count = model.count };
  ); // end from_collection
  
  
  
  - is_equal other:SELF :BOOLEAN <-
  ( + result:BOOLEAN;
    
    ( self = other).if {
      result := TRUE;
    }.elseif { upper = other.upper } then {
      result := storage.fast_memcmp (other.storage) until (upper + 1) ;
    }; // end if
    ? { result -> (lower = other.lower & upper = other.upper)};
    result
  ); // end is_equal
  
  
  
  - is_equal_map other:SELF :BOOLEAN <- 
  ( + result:BOOLEAN;
    
    ( self = other).if {
      result := TRUE;
    }.elseif { upper = other.upper } then {
      result := storage.memcmp (other.storage) until (upper + 1);
    }; // end if
    ? { result -> (lower = other.lower & upper = other.upper)};
    result
  ); // end is_equal_map
  
  
  
  - all_default :BOOLEAN <- 
  (
    storage.all_default upper
  ); // end all_default
  
  
  
  - occurrences element:E :INTEGER <- 
  ( + result:INTEGER;
    result := storage.occurrences element until upper;
    ? { result >= 0};
    result
  ); // end occurrences
  
  
  
  - fast_occurrences element:E :INTEGER <- 
  ( + result:INTEGER;
    result := storage.fast_occurrences element until upper;
    ? { result >= 0};
    result
  ); // end fast_occurrences
  
  
  
  - index_of element:E :INTEGER <- 
  ( + result:INTEGER;
    result := storage.index_of element until upper;
    ? { lower <= result };
    ? { result <= upper + 1 };
    ? { (result <= upper) -> ( element.is_equal (item result))};
    result 
  ); // end index_of
  
  
  
  - first_index_of element:E :INTEGER <- 
  (
    storage.index_of element until upper
  ); // end first_index_of 
  
  
  
  - fast_index_of element:E :INTEGER <- 
  ( + result:INTEGER;    
    result := storage.fast_index_of element until upper;
    ? { lower <= result };
    ? { result <= upper + 1 };
    ? { (result <= upper) -> ( element = item result)};
    result
  ); // end fast_index_of
  
  
  
  - subarray min:NUMERIC to max:NUMERIC :SELF <-  // slice
  (
    + result:SELF;
    
    result := SELF.create (max - min + 1);
    result.storage.copy_slice storage to 0 from min to max;
    
    result
  ); // end subarray
  
  
  
  - force element:E to index:NUMERIC <- 
  ( + old_upper:INTEGER;
    ? { index >= lower};
    old_upper:=upper;
    
    ( index <= upper ).if {
      storage.put element to index;
    }.elseif { index = (upper + 1) } then {
      add_last element;
    } else {
      resize (index + 1);
      storage.put element to index;
    }; // end if
    ? { upper = index.max old_upper };
    ? { item index = element };
  ); // end force
  
  
  
  - remove_first <- 
  ( + old_lower,old_upper,old_count:INTEGER;
    + void_storage:NATIVE_ARRAY[E];
    ? { not is_empty };
    old_lower := lower;
    old_upper := upper;
    old_count := count;
    ( upper = 0).if {
      storage := void_storage;
      capacity := 0;
      upper := -1;
    } else {
      storage.remove_first upper;
      upper := upper - 1;
    }; // end if
    
    ? { count = old_count - 1};
    ? {(lower = old_lower + 1) ^ (upper = old_upper - 1)};
  ); // end remove_first
  
  
  
  - remove index:NUMERIC <- 
  ( + old_count,old_upper:INTEGER;
    ? { valid_index(index)};
    old_count := count;
    old_upper := upper;
    storage.remove index until upper;
    upper := upper - 1;
    ? { count = old_count - 1};
    ? { upper = old_upper - 1}; 
  ); // end remove
  
  
  
  - get_new_iterator: ITERATOR[E] <- 
  (
    ITERATOR_ON_COLLECTION[E].make self
  ); // end get_new_iterator
  
