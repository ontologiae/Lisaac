/****************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  - name        := COLLECTION3[E];
  - comment     :=
    "Abstract definition of a 3 dimensional collection of elements of type E.  \
    \The Lisaac standard library (Lisaac/lib/base) provides two implementations\
    \of COLLECTION3[E]:ARRAY3[E] and FIXED_ARRAY3[E]. All implementations have \
    \exactly the same behavior. Switching from one implementation to another   \
    \only change the memory usedand the execution time.";
  
  - category    := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
section INHERIT
  
  - parent_safe_equal:SAFE_EQUAL[E] := SAFE_EQUAL[E];
  
section PUBLIC
  
  - lower1:INTEGER <-
  // Lower index bound for dimension 1.
  (
    deferred;
  );
  
  
  - lower2:INTEGER <-
  // Lower index bound for dimension 2.
  (
    deferred;
  );
  
  
  - lower3:INTEGER <-
  // Lower index bound for dimension 3.
  (
    deferred;
  );
  
  
  - line_minimum:INTEGER <-
  // Equivalent of `lower1'.
  (
    lower1
  );
  
  
  - column_minimum:INTEGER <-
  // Equivalent of `lower2'.
  (
    lower2
  );
  
  
  - depth_minimum:INTEGER <-
  // Equivalent of `lower3'.
  (
    lower3
  );
  
  
  - upper1:INTEGER <-
  // Upper index bound for dimension 1.
  (
    deferred;
  );
  
  
  - upper2:INTEGER <-
  // Upper index bound for dimension 2.
  (
    deferred;
  );
  
  
  - upper3:INTEGER <-
  // Upper index bound for dimension 3.
  (
    deferred;
  );
  
  
  - line_maximum:INTEGER <-
  // Equivalent of `upper1'.
  (
    upper1
  );
  
  
  - column_maximum:INTEGER <-
  // Equivalent of `upper2'.
  (
    upper2
  );
  
  
  - depth_maximum:INTEGER <-
  // Equivalent of `upper3'.
  (
    upper3
  );
  
  
  // Reading:

  - item line, column, depth:NUMERIC :E <-
  (
    ? {valid_index line,column,depth };
    deferred;
  );
  
  
  // Writing:

  - put element:E to line, column, depth:NUMERIC <-
  (
    ? {valid_index line,column,depth };
    deferred;
    // ? { item(line,column,depth) = element};
  );
  
  
  - force element:E to line, column, depth:NUMERIC <-
  // Put `element' at position (`line',`column',`depth').
  // Collection is resized first when (`line',`column',`depth')
  // is not inside current bounds.
  // New bounds are initialized with default values.
  (
    ? { line >= 0};
    ? { column >= 0};
    ? { depth >= 0};
    deferred;
    //  ? {
    //     item(line,column,depth) = element;
    //	 count >= old count
  );
  
  
  // Index validity:

  - valid_line line:NUMERIC :BOOLEAN <-
  (
    (lower1 <= line) && {line <= upper1}
  );
  
  
  - valid_index1 line:NUMERIC :BOOLEAN <-
  (
    valid_line line
  );
  
  
  - valid_column column:NUMERIC :BOOLEAN <-
  (
    (lower2 <= column) && {column <= upper2}
  );
  
  
  - valid_index2 column:NUMERIC :BOOLEAN <-
  (
    valid_column column
  );
  
  
  - valid_depth depth:NUMERIC :BOOLEAN <-
  (
    (lower3 <= depth) && {depth <= upper3}
  );
  
  
  - valid_index3 depth:NUMERIC :BOOLEAN <-
  (
    valid_depth depth
  );
  
  
  - valid_index line, column, depth:NUMERIC :BOOLEAN <-
  (
    (valid_line line) && {valid_column column} && {valid_depth depth}
  );
  
  
  // Counting:
  
  - count1:INTEGER <-
  // Size of the first dimension.
  (
    deferred;
    // ? {
    //	 result = upper1 - lower1 + 1;
  );
  

  - line_count:INTEGER <-
  // Equivalent of `count1'.
  (
    count1
  );
  
  
  - count2:INTEGER <-
  // Size of the second dimension.
  (
    deferred;
    // ? {
    // result = upper2 - lower2 + 1;
  );
  
  
  - column_count:INTEGER <-
  (
    count2
  );
  
  
  - count3:INTEGER <-
  // Size of the third dimension.
  (
    deferred;
    // ? {
    //   result = upper3 - lower3 + 1;
  );
  
  
  - depth_count:INTEGER <-
  (
    count3
  );
  
  
  - count:INTEGER <-
  // Total number of elements.
  (
    deferred;
    // ? {
    //   result = line_count * column_count * depth_count
  );


  - swap line1, column1, depth1:NUMERIC with line2, column2, depth2:NUMERIC <-
  // Swap the element at index (`line1',`column1',`depth1')
  // with the element at index (`line2',`column2',`depth2').
  (
    ? { valid_index line1,column1,depth1};
    ? { valid_index line2,column2,depth2};
    
    deferred;
    //? {
    // item(line1,column1,depth1) = old item(line2,column2,depth2);
    //item(line2,column2,depth2) = old item(line1,column1,depth1);
    //count = old count
  );
  
  
  - set_all_with v:E <-
  // Set all item with value `v'.
  (
    deferred;
    //? {
    // count = old count
  );

  - clear_all <-
  // Set all items to default values.
  (
    + value:E;
    set_all_with value;
    ? {	count = old count };
  );
  
  
  // Creating or initializing:
  
  - from_collection3 model:COLLECTION3[E] <-
  //  Uses `model' to initialize self.
  (
    ? { model != NULL};
    
    deferred;
    //  ? {
    // count1 = model.count1;
    // count2 = model.count2;
    // count3 = model.count3
  );
  
  
  - from_model model:COLLECTION[COLLECTION[COLLECTION[E]]] <-
  // The `model' is used to fill line by line self.
  // Assume all sub-collections have the same
  // dimension.
  (
    ? { model != NULL};
    
    deferred;
    //? {
    // count1 = model.count;
    // count2 > 0 -> count2 = model.first.count;
    // count3 > 0 -> count3 = model.first.first.count
  );
  

  // Looking and comparison:

  - all_default:BOOLEAN <-
  // Do all items have their type's default value?
  (
    deferred;
  );


  - same_as other:COLLECTION3[E] :BOOLEAN <-
  // Unlike `is_equal', this feature can be used to compare
  // distinct implementation of COLLECTION3.
  (
    ? { other != NULL};
    
    deferred;
    // ? {
    //	 result -> standard_same_as(other)
  );
  
  
  // Printing:

  - fill_tagged_out_memory <-
  (
    + line:INTEGER;
    + v:E;
    
    tagged_out_memory.append "lower1:";
    lower1.append_in tagged_out_memory;
    tagged_out_memory.append " upper1:";
    upper1.append_in tagged_out_memory;
    tagged_out_memory.append " lower2:";
    lower2.append_in tagged_out_memory;
    tagged_out_memory.append " upper2:";
    upper2.append_in tagged_out_memory;
    tagged_out_memory.append " lower3:";
    lower3.append_in tagged_out_memory;
    tagged_out_memory.append " upper3:";
    upper3.append_in tagged_out_memory;
    tagged_out_memory.append " [\n";
    
    line := lower1;
    { (line > upper1) || { tagged_out_memory.count > 4096}}.until_do {
      tagged_out_memory.append "line ";
      line.append_in tagged_out_memory;
      tagged_out_memory.append "\t:";
      
      lower2.to upper2 do { column:INTEGER;
	tagged_out_memory.append "column ";
	column.append_in tagged_out_memory;
	tagged_out_memory.append "\t:";
	
	lower3.to upper3 do { depth:INTEGER;
	  tagged_out_memory.append "depth ";
	  depth.append_in tagged_out_memory;
	  tagged_out_memory.append "\t:";
	  v := item line,column,depth;
	  (v = NULL).if {
	    tagged_out_memory.append "NULL";
	  } else {
	    v.out_in_tagged_out_memory;
	  };
	  tagged_out_memory.extend ' ';
	};
	
	tagged_out_memory.extend '\n';
      };
      
      tagged_out_memory.extend '\n';
      line := line + 1;
    };
    
    (valid_line line).if {
      tagged_out_memory.append "......\n";
    };
  );
  
  
  // Miscellaneous features:
  
  - occurrences elt:E :NUMERIC <-
  // Number of occurrences using `equal'.
  // See also `fast_occurrences' to choose the apropriate one.
  (
    deferred;
    //? {
    // result >= 0
  );


  - fast_occurrences elt:E :NUMERIC <-
  // Number of occurrences using `='.
  // See also `occurrences' to choose the apropriate one.
  (
    deferred;
    //? {
    // result >= 0
  );

  - has x:E :BOOLEAN <-
  // Search if a element x is in the array using `equal'.
  // See also `fast_has' to choose the apropriate one.
  (
    deferred;
  );
   
   
  - fast_has x:E :BOOLEAN <-
  //  Search if a element x is in the array using `='.
  (
    deferred;
  );
   
   
  - replace_all old_value:E with new_value:E <-
  // Replace all occurences of the element `old_value' by `new_value'
  // using `equal' for comparison.
  // See also `fast_replace_all' to choose the apropriate one.
  (
    deferred;
    //? {
    // count = old count;
    // occurrences(old_value) = 0
  );
   
   
  - fast_replace_all old_value:E with new_value:E <-
  // Replace all occurences of the element `old_value' by `new_value'
  // using operator `=' for comparison.
  // See also `replace_all' to choose the apropriate one.
  (
    deferred;
    //? {
    //	 count = old count;
    //      fast_occurrences(old_value) = 0
  );
    
    
  - sub_collection line_min, column_min, depth_min:NUMERIC to line_max, column_max, depth_max:NUMERIC :SELF <-
  // Create a new object using selected area of `self'.
  (
    ? { valid_index line_min,column_min,depth_min};
    ? { valid_index line_max,column_max,depth_max};
    
    deferred;
    //? {
    // result != NULL
  );
  
  
  - set_area line_min, column_min, depth_min:NUMERIC to line_max, column_max, depth_max:NUMERIC with element:E <-
  // Set all the elements of the selected area rectangle with `element'.
  (
    ? { valid_index line_min,column_min,depth_min};
    ? { valid_index line_max,column_max,depth_max};

    line_min.to line_max do { line:INTEGER;
      column_min.to column_max do { column:INTEGER;
	depth_min.to depth_max do { depth:INTEGER;
	  put element to line,column,depth;
	};
      };
    };
    
    ? {	count = old count};
  );
  

  // For `same_as' implementation:

  - standard_same_as other:COLLECTION3[E] :BOOLEAN <-
  (
    + result:BOOLEAN;
    + line, column, depth:INTEGER;
    
    ? { generating_type != other.generating_type};
    
    result := FALSE;
    
    (lower1 != other.lower1).if {
    }.elseif { upper1 != other.upper1 } then {
    }.elseif { lower2 != other.lower2 } then {
    }.elseif { upper2 != other.upper2 } then {
    }.elseif { lower3 != other.lower3 } then {
    }.elseif { upper3 != other.upper3 } then {
    } else {
      result := TRUE;
      line := upper1;
      { ! result || {line < lower1}}.until_do {
	column := upper2;
	{ ! result || {column < lower2}}.until_do {
	  depth := upper3;
	  { ! result || {depth < lower3}}.until_do {
	    result := safe_equal(item line,column,depth),(other.item line,column,depth);
	    depth := depth - 1;
	  };
	  column := column - 1;
	};
	line := line - 1;
      };
    };
    result
  );
  
  
  - same_as_array3 other:ARRAY3[E] :BOOLEAN <-
  (
    ? { other != NULL};
    deferred;
  );

  - same_as_fixed_array3 other:FIXED_ARRAY3[E] :BOOLEAN <-
  (
    ? { other != NULL};
    deferred;
  );
