///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := PIECE;
  
  - author       := "Benoit Sonntag";
  - comment      := "Language shootout - Meteor contest (based on the C++ version)"; 
  
Section Inherit
  
  - parent_any:OBJECT := OBJECT;

Section Private
  
  struct Piece {
   
  - n_elem:INTEGER := 5;
  - n_orient:INTEGER := 12;
  - all_piece_mask:INTEGER := (1 << n_piece_type) - 1;
  - skip_piece:UINTEGER_32 := 5; // it's magic!

   typedef int TPts[N_ELEM][N_DIM];

   static const BitVec BaseVecs[N_PIECE_TYPE];
   static Piece s_basePiece[N_PIECE_TYPE][N_ORIENT];
         
   Instance m_instance[N_PARITY];
};

  
  Piece Piece::s_basePiece[N_PIECE_TYPE][N_ORIENT];
  
  const BitVec Piece::BaseVecs[] = {
   0x10f, 0x0cb, 0x1087, 0x427, 0x465,
   0x0c7, 0x8423, 0x0a7, 0x187, 0x08f
 };
 
  - set_coord_list (vec:UINTEGER_32 , TPts & pts) <- // Static ?
  ( + ipt:INTEGER;
    + mask:UINTEGER_32;
    
    mask := 1;
    0.to (n_row-1) do { y:INTEGER;
      0.to (n_col-1) do { x:INTEGER;
	((mask & vec) != 0).if {
	  pts.put x to (ipt,x);
	  pts.put y to (ipt,y);
	  
	  ipt := ipt + 1;
	};
	mask := mask << 1;
      };
    };
  );

  - to_bit_vector (const TPts & pts) :UINTEGER_32 <- // Static
  ( + y, x:INTEGER;
    + result:UINTEGER_32;
    
    0.to (n_elem-1) do { ipt:INTEGER;
      x := pts.item (ipt,x);
      y := pts.item (ipt,y);
      result := result | (1 << BOARD.get_index (x,y));
    };
    result
  );

  - shift_up_lines (TPts & pts, shift:INTEGER) <- // static
  (
    // vertical shifts have a twist
    0.to (n_elem-1) do { ipt:INTEGER;
      int & rx := pts.item (ipt,x);
      int & ry := pts.item (ipt,y);

      (ry & shift & 01h).if {
	rx := rx + 1;
      };
      ry := ry - shift;
    };
  );    

  - shift_to_x0(TPts & pts, Instance & instance, offset_row:INTEGER) :INTEGER <- // static
  (
    // .. determine shift
    + x, y, ipt,offset:INTEGER;
    + x_min:INTEGER; 
    + x_max:INTEGER; 
    
    x_min := pts.item (0,x);
    x_max := x_min;
    
    1.to (n_elem-1) do { ipt:INTEGER;     
      x := pts.item (ipt,x);
      y := pts.item (ipt,y);
      
      (x < x_min).if {
	x_min := x;
      } else {
	(x > x_max).if {
	  x_max := x;
	};
      };
    };
    
    // I'm dying for a 'foreach' here
    offset := n_elem;
    1.to (n_elem-1) do { ipt:INTEGER;     
      int & rx := pts.item (ipt,x);
      int & ry := pts.item (ipt,y);
      
      rx := rx - x_min;
      
      // check offset -- leftmost cell on top line
      ((ry = offset_row) && {rx < offset}).if {
	offset := rx;
      };
    };
    
    instance.m_offset := offset;
    instance.m_vec := to_bit_vector pts;
    x_max - x_min
  );

  - set_ok_pos (is_odd:UINTEGER_32, w,h:INTEGER) <-
  ( + y,x_pos:INTEGER;
    + piece_vec:UINTEGER_32;
    + pos_mask:UINTEGER_64;
    Instance & p := m_instance.item is_odd;
    TUInt64 & allowed := p.m_allowed := 0;
    pos_mask := 1 << (is_odd * n_col);
   
    y := is_odd;
    {y < n_row - h}.while_do {      
      (p.m_offset).if {
	pos_mask := pos_mask << p.m_offset;
      };      
      x_pos := 0;
      {x_pos < n_col - p.m_offset}.while_do {
	// check if the new position is on the board
	(x_pos < n_col - w).if {
	  // move it to the desired location
	  piece_vec := p.m_vec << x_pos;

	  (! BOARD.has_bad_islands_single (piece_vec, y)).if {            
	    // position is allowed	    
	    allowed := allowed | pos_mask;
	  };
	};
	x_pos := x_pos + 1;
	pos_mask := pos_mask << 1;	
      }
      y := y + 2;
      pos_mask := pos_mask << n_col;
    };
  );

  - gen_orientation (vec:UINTEGER_32 , i_orient:UINTEGER_32, target:PIECE) <- // static
  ( + y,x,ipt,rot,flip,x_new,y_new,y_min,y_max,h,w:INTEGER;
    + pts:TPTS;
    + v_even,v_odd:INSTANCE; 
    // get (x,y) coordinates
    
    set_coord_list (vec, pts);
    
    rot := i_orient % 6;
    flip := i_orient >= 6;
    (flip).if {
      0.to (n_elem-1) do { ipt:INTEGER;
	pts.put (-pts.item (ipt,y)) to (ipt,y);	
      };
    };

    // rotate as necessary
    {rot != 0}.while_do {
      rot := rot - 1;
      0.to (n_elem - 1) do { ipt:INTEGER;      
	x := pts.item (ipt,x);
	y := pts.item (ipt,y);

	// I just worked this out by hand. Took a while.
	x_new := floor(2 * x - 3 * y + 1, 4);
        y_new := floor(2 * x + y + 1, 2);
	pts.put x_new to (ipt,x);
	pts.put y_new to (ipt,y);
      };
    };

    // determine vertical shift
    y_min := pts.item (0,y);
    y_max := y_min;
    1.to (n_elem - 1) do { ipt:INTEGER;      
      y := pts.item (ipt,y);
      
      (y < y_min).if {
	y_min := y;
      } else { 
	(y > y_max).if {
	  y_max := y;
	};
      };
    };
    h := y_max - y_min;
    v_even := target.m_instance.item even;
    v_odd  := target.m_instance.item odd;

    shift_up_lines (pts, y_min);
    w := shift_to_x0 (pts, v_even, 0);
    target.set_ok_pos (even, w, h);
    even.m_vec := even.m_vec >> even.m_offset;

    // shift down one line
    shift_up_lines(pts, -1);
    w := shift_to_x0(pts, v_odd, 1);
    // shift the bitmask back one line
    v_odd.m_vec := v_odd.m_vec >> n_col;
    target.set_ok_pos (odd, w, h);
    v_odd.m_vec := v_odd.m_vec >> v_odd.m_offset;
  );

  - gen_all_orientations <- // static
  ( + ref_piece:UINTEGER_32;
    + p:PIECE;
    + p_i:INSTANCE;
    + allowed:OK_PIECES;
    + n_piece:INTEGER_8;
    
    0.to (n_piece_type - 1) do { i_piece:INTEGER;
      ref_piece := base_vecs.item i_piece;
      0.to (n_orient - 1) do { i_orient:INTEGER;
	p := s_base_piece.item (i_piece,i_orient);
	gen_orientation (ref_piece, i_orient, p);
	((i_piece = skip_piece) && {(i_orient / 3) & 1}).if {
	  p.m_instance.item 0.m_allowed := p.m_instance.item 1.m_allowed := 0;
	};
      };
    };
    
    0.to (n_piece_type - 1) do { i_piece:INTEGER;
      0.to (n_orient - 1) do { i_orient:INTEGER;      
	+ mask:UINTEGER_64;
	mask := 1;
	0.to (n_row - 1) do { i_row:INTEGER;
	  p_i := get_piece (i_piece, i_orient, i_row & 1);
	  0.to (n_col-1) do { i_col:INTEGER;
	    allowed := g_ok_pieces.item (i_row,i_col);
	    ((p.m_allowed & mask) != 0).if {
	      n_piece := allowed.n_pieces.item i_piece;
	      allowed.piece_vec.item (i_piece,n_piece) := p_i.m_vec << i_col;
	      n_piece := n_piece + 1;
	      // allowed.n_pieces.put n_piece to i_piece;
	    };
	    
	    mask := mask << 1;
	  };
	};
      };
    };
  );
  
  - get_piece (i_piece,i_orient,i_parity:UINTEGER_32) :INSTANCE <- // static
  (
    s_base_piece.item (i_piece,i_orient).m_instance.item i_parity
  );

