Section Header

  + name      := NODE;

  - comment   := "Parent for all switch node";

Section Inherit

  + parent_instr:Expanded INSTR;

Section NODE, PROFIL_BLOCK, ITM_OLD_EXPR

  - node_list_base:ARRAY NODE_TYPE := node_list;

  - node_list:ARRAY NODE_TYPE := ARRAY NODE_TYPE .create_with_capacity 512;

  - set_node_list l:ARRAY NODE_TYPE <-
  (
    node_list := l;
  );

Section PROTOTYPE
  
  - extend_pass <-
  ( + j:INTEGER;
    + is_ok:BOOLEAN;

    VARIABLE.update;
    j := node_list.lower;
    {j <= node_list.upper}.while_do {
      is_ok := node_list.item j.update;
      (is_ok).if {
	node_list.remove j;
      } else {
	j := j + 1;
      };
    };
    //(modify_count = 0).if { die_with_code 0; };
  );
/*
  - extend_pass <-
  ( + j,continue:INTEGER;
    + is_ok:BOOLEAN;
    + index:INTEGER;
    
    index := node_list.lower;
    {
      VARIABLE.update;
      j := index;
      modify_count := 0;
      {j <= node_list.upper}.while_do {
        is_ok := node_list.item j.update;
        (is_ok).if {
          node_list.remove j;
        } else {
          j := j + 1;
          (modify_count = 0).if {
            index := index + 1;
            (j != index).if {
              node_list.swap (j-1) with index;
            };
          } else {
            continue := 1;
            modify_count := 0;
          };
        };        
      };
    }.do_while {index <= node_list.upper};
    (continue = 0).if { die_with_code 0; };
    modify_count := continue;
  );
*/
Section Public

  //
  // Extern Creation read.
  //

  - new_read p:POSITION slot s:ITM_SLOT receiver rec:EXPR
  self my_self:EXPR intern is_intern:BOOLEAN :NODE <-
  ( + result:NODE_TYPE;
    + dta:DTA_RD;
    //
    dta := DTA_RD.create p call s self my_self intern is_intern;
    result := NODE_TYPE.create rec with dta;    
    //
    node_list.add_last result;
    result
  );

  - new_read p:POSITION slot s:ITM_SLOT receiver rec:EXPR
  with larg:ARRAY EXPR intern is_intern:BOOLEAN :NODE <-
  ( + dta:DTA_RD_ARGS;
    + result:NODE_TYPE;

    // Control argument type.
    dta := DTA_RD_ARGS.create p call s with larg intern is_intern;
    s.check_arguments larg for dta;
    result := NODE_TYPE.create rec with dta;
    //
    node_list.add_last result;
    result
  );

  //
  // Just for ITM_EXPRESSION.
  //

  - new_read_partial p:POSITION slot s:ITM_SLOT :NODE_TYPE <-
  ( + dta:DTA_RD_ARGS;

    dta := DTA_RD_ARGS.create_partial p call s;
    NODE_TYPE.create_partial dta
  );

  - new_read_finalize (rec:EXPR,s:ITM_SLOT) with larg:ARRAY EXPR <-
  ( + dta:DTA_RD_ARGS;
    // Control argument type.
    dta ?= data;

    dta.make (data.position) call s with larg intern FALSE;
    data.slot.check_arguments larg for dta;
    make rec with data;
    //
    node_list.add_last Self;
  );

  //
  // Extern creation writes.
  //

  - new_write p:POSITION slot s:ITM_SLOT receiver rec:EXPR value val:EXPR :NODE <-
  ( + dta:DTA_WR_VALUE;
    + result:NODE_TYPE;

    dta := DTA_WR_VALUE.create p slot s self rec value val;
    result := NODE_TYPE.create rec with dta;
    //
    node_list.add_last result;
    result
  );

  - new_write p:POSITION slot s:ITM_SLOT receiver rec:EXPR code val:ITM_CODE :NODE <-
  ( + dta:DTA_WR_CODE;
    + result:NODE_TYPE;

    dta := DTA_WR_CODE.create p slot s self rec code val;
    result := NODE_TYPE.create rec with dta;
    //
    node_list.add_last result;
    result
  );

  //
  // Extern creation cast.
  //

  - new_cast p:POSITION type typ:TYPE_FULL with val:EXPR :NODE <-
  [ -? {p != 0}; ]
  ( + dta:DTA_CAST;
    + result:NODE_TYPE;

    dta := DTA_CAST.create p type typ;
    result := NODE_TYPE.create val with dta;
    //
    node_list.add_last result;
    result
  );

  //
  // Extern creation value block.
  //

  - new_block p:POSITION receiver e:EXPR with larg:ARRAY EXPR :NODE <-
  ( + dta:DTA_BLOCK;
    + result:NODE_TYPE;
    + lst_typ_f:ARRAY TYPE_FULL;
    + new_expr:EXPR;
    + block_model:TYPE_BLOCK;
    + pb:PROFIL_BLOCK;
    + pos:POSITION;

    pb ?= e.static_type.raw;
    (pb = NULL).if {
      block_model ?= e.static_type.raw;
    } else {
      block_model := pb.to_type_block;
    };
    // Control argument type.
    lst_typ_f := block_model.argument_list;
    pos       := block_model.position;

    (lst_typ_f.count+1 != larg.count).if {
      string_tmp.copy "Incorrect size of vector argument for this block. (Value:";
      larg.count.append_in string_tmp;
      string_tmp.append ", Type:";
      (lst_typ_f.count+1).append_in string_tmp;
      string_tmp.add_last ')';
      POSITION.put_error semantic text string_tmp;
      pos.put_position;
      p  .put_position;
      POSITION.send_error;
    };
    (larg.lower + 1).to (larg.upper) do { j:INTEGER;
      new_expr := larg.item j.check_type (lst_typ_f.item (j-1)) with pos;
      larg.put new_expr to j;
    };
    //
    (debug_level_option != 0).if {
      (profil_current = NULL).if {
	crash_with_message "NODE";
      };
      list_current.add_last (
	PUSH.create p context (profil_current.context) first FALSE
      );
    };
    //
    dta    := DTA_BLOCK.create block_model with larg;
    result := NODE_TYPE.create e with dta;
    //
    node_list.add_last result;
    result
  );

Section Public

  - position:POSITION <-
  (
    data.position
  );
  /*
  + without_push:BOOLEAN;
  
  - without_push_on <-
  (
    without_push := TRUE;
  );
*/
  + data:DTA;

  + expr:EXPR;

  + first_code:LIST;
  + first_type:TYPE;
  + switch:SWITCH;

  - count:INTEGER <-
  ( + result:INTEGER;

    (switch != NULL).if {
      result := switch.count;
    }.elseif {first_type != NULL} then {
      result := 1;
    };
    result
  );

  - result_expr:EXPR <- deferred;

  //
  // Execute.
  //

  - remove <-
  (
    data.remove;
    (switch = NULL).if {
      expr.remove;
      (first_code != NULL).if {
	first_code.remove;
      };
    } else {
      switch.remove;
    };
  );

  - execute:INSTR <-
  ( + result:INSTR;

    data.remove;
    (switch != NULL).if {
      result := switch.execute;
    } else {
      expr.remove;
      (first_code != NULL).if { // Warning: Dead Code!
	result := first_code.execute;
      };
    };
    result
  );

  - genere buffer:STRING_BUFFER <-
  (
    "Genere NODE!\n".print;
    crash;
  );


Section NODE, DTA

  //
  // Update.
  //

  - update_link self_type:TYPE_FULL :BOOLEAN <-
  (
    deferred;
  );

Section Public

  //
  // Display.
  //

  - display buffer:STRING_BUFFER <-
  (
    (switch = NULL).if {
      (first_code = NULL).if {
	to_pointer.append_in buffer;
	buffer.append "<NODE VIDE=";
	expr.display buffer;
	buffer.append ", Data: ";
	data.display buffer;
	buffer.append ", Result: ";
	result_expr.display buffer;
	buffer.add_last '>';
      } else {
	expr.display buffer;
	first_code.display buffer;
      };
    } else {
      switch.display buffer;
    };
  );

