/***************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
***************************************************************************/

section HEADER
  
  + name        :=TEXT_FILE_READ;
  
  - category    :=MICRO;
  
  - bibliography:="http://IsaacOS.com";
  
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
  - comment     :="Basic input facilities to read a named file on the disc.";
  
section INHERIT
  
  - parent_input_stream:INPUT_STREAM := INPUT_STREAM;
  
section PUBLIC

  + path:ABSTRACT_STRING;
  // Not NULL when connected to the corresponding file on the disk.
  
  - size_max:INTEGER := 32768;
  
  - is_connected: BOOLEAN <-
  (
    path != NULL
  );

  - connect_to new_path:ABSTRACT_STRING <-
  //  Open text file for reading. The stream is positioned at the
  //  beginning of the file.
  (
    ? { ! is_connected };
    ? { ! new_path.is_empty };

    input_stream := basic_io_text_file_read_open (new_path.to_external);
    (input_stream.is_not_null).if {
      push_back_flag := FALSE;
      end_of_input := FALSE;
      path := new_path;
      (capacity = 0).if {
	buffer := NATIVE_ARRAY[CHARACTER].calloc size_max;	
	capacity := size_max;
      };
      end_reached := FALSE;
      buffer_position := 0;
      buffer_size := 0;
    };
  );

  - disconnect <-
  (
    ? { is_connected };
    basic_io_fclose input_stream;    
    path := NULL;
  );
  
  - read_character <-
  (
    push_back_flag := FALSE;
    (buffer_position >= buffer_size).if {
      fill_buffer;
    };
    last_character := buffer.item buffer_position;
    buffer_position := buffer_position + 1;
    end_of_input := end_reached;
  );

  - unread_character <-
  (
    push_back_flag := TRUE;
    end_of_input := FALSE;
    buffer_position := buffer_position - 1;
  );
  
  + last_character:CHARACTER;

  + end_of_input:BOOLEAN;

  + push_back_flag:BOOLEAN;
  
  - read_line_in str:STRING <-
  (
    ? { str != NULL};
    read_character;
    (last_character != '\n').if {
      str.extend last_character;
      { end_of_input || {last_character == '\n'}}.until_do {
	read_character;
	//last_character.print;
	((! end_of_input) && {last_character != '\n'}).if {
	  str.extend last_character;
	};
      };
    };
  ); 
  
  - read_file_in str:STRING <-
  // read the entire file and put it in a STRING
  (
    ? { str != NULL};
    fill_buffer;
    str.from_external_copy buffer;
  );
  
  // FILE_TOOLS

  - same_as other:SELF :BOOLEAN <-
  (
    + result:BOOLEAN;
    + b1, b2:NATIVE_ARRAY[CHARACTER];
    + i:INTEGER;
    
    ? { is_connected };
    ? { other.is_connected };
    fill_buffer;
    b1 := buffer;
    other.fill_buffer;
    b2 := other.buffer;
    result := TRUE;
    { (! result) || { end_reached} || {other.end_reached}}.until_do {
      (buffer_size = other.buffer_size).if {
	(b1.item 0 != b2.item 0).if {
	  result := FALSE;
	} else {
	  // make first character different for loop end
	  b1.put '\r' to 0;
	  b2.put '\n' to 0;
	  i := buffer_size - 1;
	  { b1.item i != b2.item i}.until_do {
	    i := i - 1;
	  };
	  result := i = 0;
	};
	result.if {
	  fill_buffer;
	  other.fill_buffer;
	};
      } else {
	read_character;
	other.read_character;
	{ (! result) || { end_of_input} || {other.end_of_input}}.until_do {
	  result := last_character = other.last_character;
	  read_character;
	  other.read_character;
	};
      };
    };
    result := result && {end_reached} && {other.end_reached};
    disconnect;
    other.disconnect;
    
    ? { ! is_connected };
    ? { ! other.is_connected };
    
    result
  );

  // INPUT_STREAM

  + input_stream:POINTER;
  
  // TEXT_FILE_READ
  
  + buffer:NATIVE_ARRAY[CHARACTER];
  
  + end_reached:BOOLEAN;
  
  + buffer_position:INTEGER;
  
  + buffer_size:INTEGER;
  
  + capacity:INTEGER;

  - fill_buffer <-
  (
    + last: CHARACTER;
    (buffer_size > 0).if {
      last := buffer.item (buffer_size - 1);
    };
    buffer_size := basic_io_fread buffer, capacity, input_stream;  
    buffer_position := 0;
    (buffer_size <= 0).if {
      end_reached := TRUE;
      buffer.put last to 0; // needed for unread_character service
      //if buffer_size = -1 => exception ?
      buffer_size := 1;
      buffer_position := 1;
    };
  );
  
  - create:SELF <-
  (
    + result:SELF;
    result := SELF.clone;
    result.make;
    result
  );
  
  - make <-
  // The new created object is not connected. (See also `connect_to'.)
  (
    ? { ! is_connected };
  );
  
  
section PRIVATE
  
  - basic_io_text_file_read_open path_pointer:NATIVE_ARRAY[CHARACTER] :POINTER <-
  (
    `fopen(((char*)(@path_pointer)),"r")`:POINTER
  );
  
  - basic_io_fread buf:NATIVE_ARRAY[CHARACTER], size:INTEGER, stream_pointer:POINTER :INTEGER <-
  // return size read or 0 if end of input (-1 on error => exception ?)
  (
    `fread((void *)(@buf),(size_t)(1), (size_t)(@size),(FILE*)(@stream_pointer))`:(INTEGER)
  );
  
  - basic_io_fclose stream_pointer:POINTER <-
  (
    `fclose((FILE*)(@stream_pointer))`;
  );