/***************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
***************************************************************************/

section HEADER
  
  * name        :=MAP_NATIVE_ARRAY[E];
  
  - category    :=MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Sonntag Benoit (bsonntag@loria.fr)";

  - comment     :="Mapping Native array of collection library.";
  
section INHERIT
  
  - parent_object:OBJECT := OBJECT;
  
section PUBLIC 
  
  //
  // Basic features:
  //
  
  - object_size:INTEGER := 0;
  
  - element_sizeof: INTEGER <- E.object_size;
  // The size in number of bytes for type `E'.
  
  - calloc_intern nb_elements:INTEGER :MAP_NATIVE_ARRAY[E] <-
  // Allocate a new array of `nb_elements' of type `E'.
  // The new array is initialized with default values.
  ( + result:MAP_NATIVE_ARRAY[E];
    + p:POINTER;
    + capacity:INTEGER;
    ? {nb_elements > 0};
    
    capacity := nb_elements * element_sizeof;
    p        :=MEMORY.allocation capacity;
    result   := `(void*)@p`:MAP_NATIVE_ARRAY[E];
    result
  );
  
  - calloc nb_elements:INTEGER :MAP_NATIVE_ARRAY[E] <-
  // Allocate a new array of `nb_elements' of type `E'.
  // The new array is initialized with default values.
  ( 
    + result:MAP_NATIVE_ARRAY[E];
    ? {nb_elements > 0};
    result:=calloc_intern nb_elements;
    result.clear_all (nb_elements-1); 
    result
  );
  
  - create_at adress:UINTEGER :MAP_NATIVE_ARRAY[E] <-
  // Create a MAP_NATIVE_ARRAY[E] at `adress'.
  (
    `@adress`:MAP_NATIVE_ARRAY[E]
  );
    
  - item index:NUMERIC :E <-
  ( + ofs:INTEGER;
    ? {self != NULL};
    ? {index >= 0};
    
    ofs:=E.object_size*index;
    `(void *)@self+@ofs`:E
  );
  
  - put element:E to index:NUMERIC<-
  (     
    force_put element to index;
    
    ? {element = item index};
  );
  
  //
  // Displacement
  //
  
  - '+' other:INTEGER :MAP_NATIVE_ARRAY[E] <- `@self+@other`:MAP_NATIVE_ARRAY[E];
  
  //
  // Adding:
  // 
  
  //
  // JBJB AJOUT A VOIR...
  // 
  - copy_slice src:NATIVE_ARRAY[E] to dest:INTEGER from src_min:INTEGER to src_max:INTEGER <-
  // Copy range [`src_min' .. `src_max'] of `src' to range
  // [`at' .. `at + src_max - src_min - 1'] of `Current'.
  // No subscript checking.
  ( + i1, i2:INTEGER;
    ? {dest >= 0};
    ? {src_min <= src_max + 1};
    
    i1 := dest;
    i2 := src_min;
    {i2 > src_max}.until_do {
      put (src.item i2) to i1;
      i2 := i2 + 1;
      i1 := i1 + 1;
    };
  );
  
  //
  // Comparison:
  //
  
  - memcmp other:MAP_NATIVE_ARRAY[E] until capacity:INTEGER :BOOLEAN <-
  // True if all elements in range [0..capacity-1] are
  // identical using `equal'. Assume Current and `other'
  // are big enough.
  // See also `fast_memcmp'.
  ( + i:INTEGER;
    ? {(capacity > 0) ->> {other.is_not_null}};
    
    i:=capacity-1;
    {(i>=0) && {item i == other.item i}}.while_do {
      i:=i-1;
    };
    i<0
  );
    
  - deep_memcmp other:MAP_NATIVE_ARRAY[E] until capacity:INTEGER :BOOLEAN <-
  // Same jobs as `memcmp' but uses `is_deep_equal' instead `equal'.
  ( + i:INTEGER;
    ? {(capacity > 0) ->> {other.is_not_null}};
    
    i:=capacity-1;
    {(i>=0) && {(item i).is_deep_equal (other.item i)}}.while_do {
      i:=i-1;
    };
    i<0
  );
  
  //
  // Searching:
  //
  
  - index_of element:E until upper:INTEGER :INTEGER <-
  // Give the index of the first occurrence of `element' using
  // `==' for comparison.
  // Answer `upper + 1' when `element' is not inside.
  ( + idx:INTEGER;
    ? {upper>=-1};
    
    {(idx>upper) || {element == item idx}}.until_do	{
      idx:=idx+1;
    };
    idx
  );
  
  - fast_index_of element:E until upper:INTEGER :INTEGER <-
  // Same as `index_of' but use basic `=' for comparison.
  ( + idx:INTEGER;
    ? {upper>=-1};
    
    {(idx>upper) || {element = item idx}}.until_do {
      idx:=idx+1;
    };
    idx
  );
  
  - has element:E until upper:INTEGER :BOOLEAN <-
  // Look for `element' using `==' for comparison.
  // Also consider `has' to choose the most appropriate.
  ( ? {upper >= -1};
    
    index_of element until upper <= upper
  );
  
  - fast_has element:E until upper:INTEGER :BOOLEAN <-
  // Look for `element' using basic `=' for comparison.
  // Also consider `has' to choose the most appropriate.
  ( ? {upper >= -1};
    
    fast_index_of element until upper <= upper
  );
  
  - clear_all upper:INTEGER <-
  // Set all elements in range [0 .. `upper'] with
  // the default value.
  ( 
    upper.downto 0 do { i:INTEGER;
      MEMORY.copy (item i.to_pointer) from (E.to_pointer) size (E.object_size);
    };
  );

