////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             MPEG2 Decode Video                             //
//                                                                            //
//                     LORIA - UHP - INRIA - ST - FRANCE                      //
//               (c) INRIA (see `licence.txt' for more details)               //
//                     Benoit SONNTAG - bsonntag@loria.fr                     //
//                           http://www.IsaacOS.com                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := IDCT;
  
  - bibliography := "http://IsaacOS.com";
  - author       := "Sonntag Benoit (bsonntag@loria.fr)";
  - comment      := "inverse fast discrete cosine transform."; 
  
Section Inherit
  
  - parent_any_mpg2:ANY_MPG2 := ANY_MPG2;
  
Section Public

// **********************************************************
// * inverse two dimensional DCT, Chen-Wang algorithm       *
// * (cf. IEEE ASSP-32, pp. 803-816, Aug. 1984)             *
// * 32-bit integer arithmetic (8 bit coefficients)         *
// * 11 mults, 29 adds per DCT                              *
// *                                      sE, 18.8.91       *
// **********************************************************
// * coefficients extended to 12 bit for IEEE1180-1990      *
// * compliance                           sE,  2.1.94       *
// **********************************************************

// this code assumes >> to be a two's-complement arithmetic
// right shift: (-2)>>1 == -1 , (-3)>>1 == -2               

Section Private
  
  // Constant.
  - w1:INTEGER := 2841; // 2048*sqrt(2)*cos(1*pi/16) 
  - w2:INTEGER := 2676; // 2048*sqrt(2)*cos(2*pi/16) 
  - w3:INTEGER := 2408; // 2048*sqrt(2)*cos(3*pi/16) 
  - w5:INTEGER := 1609; // 2048*sqrt(2)*cos(5*pi/16) 
  - w6:INTEGER := 1108; // 2048*sqrt(2)*cos(6*pi/16) 
  - w7:INTEGER :=  565; // 2048*sqrt(2)*cos(7*pi/16) 

  - iclip:ARRAY(INTEGER_16) := 
  // clipping table 
  ( + result:ARRAY(INTEGER_16);
    
    result := ARRAY(INTEGER_16).create (-512) to 511;
    result.set_slice (-512) to (-256) with (-256);
    result.set_slice 255    to 511    with 255;
    (-255).to 254 do { i:INTEGER; 
      result.put (i.to_integer_16) to i;
    };
    result
  );

  - idctrow blk:NATIVE_ARRAY(INTEGER_16) index idx:INTEGER <-
  // row (horizontal) IDCT
  //
  //           7                       pi         1
  // dst[k] = sum c[l] * src[l] * cos( -- * ( k + - ) * l )
  //          l=0                      8          2
  //
  // where: c[0]    = 128
  //        c[1..7] = 128*sqrt(2)
  ( + x0, x1, x2, x3, x4, x5, x6, x7, x8:INTEGER;
    + tmp:INTEGER_16;
    
    // shortcut 
    x1 := blk.item (idx + 4).to_integer << 11;
    x2 := blk.item (idx + 6);
    x3 := blk.item (idx + 2);
    x4 := blk.item (idx + 1);
    x5 := blk.item (idx + 7);
    x6 := blk.item (idx + 5);
    x7 := blk.item (idx + 3);
    ((x1 | x2 | x3 | x4 | x5 | x6 | x7) = 0).if {
      tmp := blk.item idx << 3;
      7.downto 0 do { n:INTEGER;
	blk.put tmp to (idx + n);
      };
    } else {

      x0 := (blk.item idx.to_integer << 11) + 128; // for proper rounding in the fourth stage 

      // first stage 
      x8 := w7 * (x4 + x5);
      x4 := x8 + (w1 - w7) * x4;
      x5 := x8 - (w1 + w7) * x5;
      x8 := w3 * (x6 + x7);
      x6 := x8 - (w3 - w5) * x6;
      x7 := x8 - (w3 + w5) * x7;
      
      // second stage 
      x8 := x0 + x1;
      x0 := x0 - x1;
      x1 := w6 * (x3 + x2);
      x2 := x1 - (w2 + w6) * x2;
      x3 := x1 + (w2 - w6) * x3;
      x1 := x4 + x6;
      x4 := x4 - x6;
      x6 := x5 + x7;
      x5 := x5 - x7;
      
      // third stage 
      x7 := x8 + x3;
      x8 := x8 - x3;
      x3 := x0 + x2;
      x0 := x0 - x2;
      x2 := (181 * (x4 + x5) + 128) >> 8;
      x4 := (181 * (x4 - x5) + 128) >> 8;
      
      // fourth stage 
      blk.put (((x7+x1)>>8).to_integer_16) to (idx + 0);
      blk.put (((x3+x2)>>8).to_integer_16) to (idx + 1);
      blk.put (((x0+x4)>>8).to_integer_16) to (idx + 2);
      blk.put (((x8+x6)>>8).to_integer_16) to (idx + 3);
      blk.put (((x8-x6)>>8).to_integer_16) to (idx + 4);
      blk.put (((x0-x4)>>8).to_integer_16) to (idx + 5);
      blk.put (((x3-x2)>>8).to_integer_16) to (idx + 6);
      blk.put (((x7-x1)>>8).to_integer_16) to (idx + 7);
    };
  );

  - idctcol blk:NATIVE_ARRAY(INTEGER_16) index idx:INTEGER <-
  // column (vertical) IDCT
  //
  //             7                         pi         1
  // dst[8*k] = sum c[l] * src[8*l] * cos( -- * ( k + - ) * l )
  //            l=0                        8          2
  //
  // where: c[0]    = 1/1024
  //        c[1..7] = (1/1024)*sqrt(2)
  ( + x0, x1, x2, x3, x4, x5, x6, x7, x8:INTEGER;
    + tmp:INTEGER_16;
    
    // shortcut 
    x1 := blk.item (idx + 8*4).to_integer << 8;
    x2 := blk.item (idx + 8*6);
    x3 := blk.item (idx + 8*2);
    x4 := blk.item (idx + 8*1);
    x5 := blk.item (idx + 8*7);
    x6 := blk.item (idx + 8*5);
    x7 := blk.item (idx + 8*3);
    
    ((x1 | x2 | x3 | x4 | x5 | x6 | x7) = 0).if {      
      tmp := iclip.item ((blk.item idx.to_integer + 32) >> 6);
      (7*8).downto 0 by 8 do { n:INTEGER;
	blk.put tmp to (idx + n);
      };
    } else {

      x0 := (blk.item idx.to_integer << 8) + 8192;
      
      // first stage 
      x8 := w7 * (x4 + x5) + 4;
      x4 := (x8 + (w1 - w7) * x4) >> 3;
      x5 := (x8 - (w1 + w7) * x5) >> 3;
      x8 := w3 * (x6 + x7) + 4;
      x6 := (x8 - (w3 - w5) * x6) >> 3;
      x7 := (x8 - (w3 + w5) * x7) >> 3;
      
      // second stage 
      x8 := x0 + x1;
      x0 := x0 - x1;
      x1 := w6 * (x3 + x2) + 4;
      x2 := (x1 - (w2 + w6) * x2) >> 3;
      x3 := (x1 + (w2 - w6) * x3) >> 3;
      x1 := x4 + x6;
      x4 := x4 - x6;
      x6 := x5 + x7;
      x5 := x5 - x7;
      
      // third stage 
      x7 := x8 + x3;
      x8 := x8 - x3;
      x3 := x0 + x2;
      x0 := x0 - x2;
      x2 := (181 * (x4 + x5) + 128) >> 8;
      x4 := (181 * (x4 - x5) + 128) >> 8;
      
      // fourth stage 
      blk.put (iclip.item ((x7 + x1) >> 14)) to (idx + 8*0);
      blk.put (iclip.item ((x3 + x2) >> 14)) to (idx + 8*1);
      blk.put (iclip.item ((x0 + x4) >> 14)) to (idx + 8*2);
      blk.put (iclip.item ((x8 + x6) >> 14)) to (idx + 8*3);
      blk.put (iclip.item ((x8 - x6) >> 14)) to (idx + 8*4);
      blk.put (iclip.item ((x0 - x4) >> 14)) to (idx + 8*5);
      blk.put (iclip.item ((x3 - x2) >> 14)) to (idx + 8*6);
      blk.put (iclip.item ((x7 - x1) >> 14)) to (idx + 8*7);
    };
  );

Section Public

  - idct block:NATIVE_ARRAY(INTEGER_16) <-
  // two dimensional inverse discrete cosine transform 
  (          
    0.to 7 do { i:INTEGER;
      idctrow block index (8 * i);
    };

    0.to 7 do { i:INTEGER;
      idctcol block index i;
    };
  );

  
