Section Header
  
  + name     := PIECE;
  
  - comment   := "3D Chess Game";
  
  - author    := "Damien Bouvarel (dams.bouvarel@wanadoo.fr)";
  
Section Inherit
  
  - parent_object:OBJECT := OBJECT;
  
Section Public
  
  + id:INTEGER; // for selection stack
  - player:INTEGER <- (id & 01h) + 1; // 1 or 2
  
  + square:SQUARE; // position in chessboard
  
  + height:REAL_32; // lift position
  
  + is_captured:BOOLEAN;
  
  
  
  - name:STRING_CONSTANT;
  - model:MODEL <- deferred;
  
  - move_lerp:REAL_32;
  
  
  - is_black:BOOLEAN <- player = 1;
  - is_white:BOOLEAN <- player = 2;
  
  //
  // Creation.
  //
  
  - create (px,py,player:INTEGER) index i:INTEGER :SELF <-
  ( + result:SELF;
    result := SELF.clone;
    result.make (px,py,player,i);
    result
  );
  
  - make (px,py,pl,i:INTEGER) <- 
  (  
    square := SQUARE.create (px,py);
    id := (i << 1) | (pl-1);
    
    // shared model for each type of piece
    (model = NULL).if {
      model := MD2_MODEL.create ("models/"+name+".md2");
    };
  ); 
  
  - check_move orig:SQUARE to dest:SQUARE :BOOLEAN <- deferred;
  
  - render r:RENDERER <-
  (      
    + texture:TEXTURE;
    + x,y:REAL_32;
    + sz:INTEGER;
    
    is_captured.if_false {
      
      // (x,y) := square.position; // compilo bug
      x := square.x;
      y := square.y;
      
      sz := CHESS.square_size;
      
      r.transform.new_matrix {
        
        // translate to origin of board
        r.transform.translatef (3*CHESS.square_size+CHESS.square_size/2, 0, -3*CHESS.square_size-CHESS.square_size/2);
        
        (CHESS.gamestate.is_moving && {CHESS.gamestate.move_dest.piece = Self}).if {
          // piece is moving
          
          x := (x - CHESS.gamestate.move_orig.x).to_real * move_lerp + CHESS.gamestate.move_orig.x;
          y := (y - CHESS.gamestate.move_orig.y).to_real * move_lerp + CHESS.gamestate.move_orig.y;
        };
        // translate to square
        r.transform.translatef (-x*CHESS.square_size, height, y*CHESS.square_size);       
        
        is_black.if {
          texture := CHESS.black_texture;
        } else {
          texture := CHESS.white_texture;
        };
        
        // quake2 z axis is opengl y axis 
        r.transform.rotatef(-90, 1,0,0);
        r.transform.rotatef(90, 0,0,1);
        
        model.render_with texture;
      };
    };
  );
  
  - update_selected t:REAL_32 <-
  (
    (height < 10).if {
      height := height + t;
    };
  );
  
  - update t:REAL_32 <-
  (
    (height != 0).if {
      height := height - t;
      (height < 0).if {
        height := 0;
      };
    };
    (CHESS.gamestate.is_moving && {Self = CHESS.gamestate.move_dest.piece}).if {
      move_lerp := move_lerp + t*0.05;
      (move_lerp >= 1.0).if {
        move_lerp := 0;
        
        CHESS.gamestate.change_player; // end of move
      };
    };
  );
  
  - capture <-
  (
    is_captured := TRUE;
  );
  
  - set_square sq:SQUARE <- (square := sq;);
  
  
  - set_renderer r:RENDERER at_position sq:SQUARE <-
  // translate to square
  ( + x,y:REAL_32;
    
    x := sq.x;
    y := sq.y;
    r.transform.translatef (3*CHESS.square_size+CHESS.square_size/2, 0, -3*CHESS.square_size-CHESS.square_size/2);
    
    r.transform.translatef (-x*CHESS.square_size, 0, y*CHESS.square_size);
  );
  
Section PIECE
  
  - check_path_between p1:SQUARE and p2:SQUARE :BOOLEAN <-
  ( + start,end:SQUARE;
    + x,y,delta_x,delta_y:INTEGER;
    + result:BOOLEAN;
    
    (p1.x > p2.x).if {
      start := p2;
      end := p1;
    } else {
      start := p1;
      end := p2;
    };
    (end.x != start.x).if {
      delta_x := 1;
    };
    (end.y != start.y).if {
      delta_y := (end.y - start.y) / ((end.y - start.y).abs);
    };
    
    x := start.x;
    y := start.y;
    result := TRUE;
    
    {
      x := x + delta_x;
      y := y + delta_y;
      
      ((x = end.x) && {y = end.y}).if_false {
        ((x = start.x) && {y = start.y}).if_false {
          result := CHESS.chessboard.item (y*8+x) = NULL;
        };
      };
    }.do_while {
      result &&
      {(x != end.x) || {y != end.y}} &&
      {(x != start.x) || {y != start.y}}
    };
    result
  );
  