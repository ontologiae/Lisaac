/****************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  + name        := LINKED_LIST[E] ;
  - comment     :="One way linked list with internal automatic memorization of the last access.";
  
  - category    := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
section INHERIT
  
  * parent_linked_collection:LINKED_COLLECTION[E];
  
section PUBLIC
  
  + first_link:LINK[E];
  // NULL when empty or gives access to the first element.
  
  // LINKED_LIST
  
  + last_link:LINK[E];
  // NULL when empty or gives access to the last element.
  
  + mem_idx:INTEGER; 
  + mem_lnk:LINK[E];
  // To speed up accessing, `mem_idx' and `mem_lnk' is the
  // memory of the last access done. For example, after
  // item(1), `mem_idx' is 1 and `mem_lnk' is `first_link'.
  // When list is empty, `first_link' is NULL as well as
  // `mem_lnk' and `mem_idx' is 0;
  
  - create:SELF <-
  ( + result:SELF;    
    result := clone;
    result.make;    
    result
  );
  
  - make <-
  // Make an empty list;
  (
    first_link := NULL;
    upper := 0;
    last_link := NULL;
    mem_idx := 0;
    mem_lnk := NULL;
    ? { count = 0};
  );
  
  - is_empty:BOOLEAN <-
  ( + result:BOOLEAN;
    result := first_link = NULL;
    ? { result = (count = 0)};
    result
  );
  
  -  add_first element:E <-
  ( + old_count,old_lower,old_upper:INTEGER;
    old_count := count;
    old_lower := lower;
    old_upper := upper;
    (first_link = NULL).if {
      first_link := LINK[E].create element next NULL;
      upper := 1;
      last_link := first_link;
      mem_idx := 1;
      mem_lnk := first_link;
    } else {
      first_link := LINK[E].create element next first_link;
      upper := upper + 1;
      mem_idx := mem_idx + 1;
    };
    ? { first = element };
    ? { count = 1 + old_count };
    ? { lower = old_lower };
    ? { upper = 1 + old_upper };
  );
  
  - add_last element:E <-
  ( + lnk:LINK[E];
    + old_count,old_lower,old_upper:INTEGER;
    old_count := count;
    old_lower := lower;
    old_upper := upper;
    (first_link = NULL).if {
      first_link := LINK[E].create element next NULL;
      upper := 1;
      last_link := first_link;
      mem_idx := 1;
      mem_lnk := first_link;
    } else {
      lnk := LINK[E].create element next NULL;
      last_link.set_next lnk;
      upper := upper + 1;
      last_link := lnk;
    };
    ? { last = element };
    ? { count = 1 + old_count };
    ? { lower = old_lower };
    ? { upper = 1 + old_upper };
  );
  
  - add element:E to index:NUMERIC <-
  ( + link:LINK[E];
    + old_count,old_upper:INTEGER;
    ? { index.in_range lower to (upper + 1)};
    old_count := count;
    old_upper := upper;
    (index = 1).if {
      add_first element;
    }.elseif { index = upper + 1 } then {
      add_last element;
    } else {
      ((index - 1) != mem_idx ).if {
	go_item (index - 1);
      };
      link := LINK[E].create element next (mem_lnk.next);
      mem_lnk.set_next link;
      upper := upper + 1;
    };
    ? { item index = element };
    ? { count = 1 + old_count };
    ? { upper = 1 + old_upper };   
  );
  
  - remove_first <-
  ( + old_lower,old_upper,old_count:INTEGER;
    ? { ! is_empty };
    old_lower := lower;
    old_upper := upper;
    old_count := count;
    ( upper = 1 ).if {
      make;
    } else {
      first_link := first_link.next;
      ( mem_idx = 1).if {
	mem_lnk := first_link;
      } else {
	mem_idx := mem_idx - 1;
      };
      upper := upper - 1;
    };
    ? { count = old_count - 1};
    ? {(lower = old_lower + 1) ^ (upper = old_upper - 1)};    
  );
  
  - remove index:NUMERIC <-
  ( + link:LINK[E];    
    + old_count,old_upper:INTEGER;
    ? { valid_index(index)};
    old_count := count;
    old_upper := upper;
    ( index = 1).if {
      remove_first;
    }.elseif { index = upper } then {
      remove_last;
    } else {
      ((index - 1) != mem_idx).if {
	go_item (index - 1);
      };
      link := mem_lnk.next;
      mem_lnk.set_next (link.next);
      upper := upper - 1;
    };
    ? { count = old_count - 1};
    ? { upper = old_upper - 1};    
  );
  
  - first:E <-
  ( + result:E;
    ? {count >= 1};
    result := first_link.item;
    ? { result = item lower};
    result
  );
  
  - last:E <-
  ( + result:E;
    ? {! is_empty};    
    result := last_link.item;
    ? { result = item upper};
    result
  );
  
  - item i:NUMERIC :E <-
  (
    ? { valid_index i};
    ( i != mem_idx).if {
      go_item i;
    };
    mem_lnk.item
  );
  
  - '@' left 1 index:NUMERIC :E <-
  (
    item index
  );
  
  -  put element:E to index:NUMERIC <-
  ( + old_count:INTEGER;
    old_count := count;
    ? { valid_index index};
    (index != mem_idx).if {
      go_item index;
    };
    mem_lnk.set_item element;
    ? { item index = element};
    ? { count = old_count};
  );
  
  - count:INTEGER <-
  ( + result:INTEGER;
    result := upper;
    ? {result = upper - lower + 1};
    result
  );
  
  - set_all_with v:E <-
  ( + old_count:INTEGER;
    old_count := count;
    (first_link != NULL).if {
      first_link.set_all_with v;
    };
    ? { count = old_count };
  );
  
  - copy other:SELF <-
  (
    from_collection other;
  );
  
  - '=='  right 60 other:SELF :BOOLEAN <-
  ( + result:BOOLEAN;
    + lnk1, lnk2:LINK[E];
    
    result := FALSE;
    (self = other).if {
      result := TRUE;
    }.elseif { upper = other.upper} then {
      result := TRUE;
      lnk1 := first_link;
      lnk2 := other.first_link;
      { (lnk1 = NULL) || {! result}}.until_do {
	result := lnk1.item = lnk2.item;
	lnk1 := lnk1.next;
	lnk2 := lnk2.next;
      };
    };
    ? { result ->> {(lower = other.lower) & (upper = other.upper)}};
    result
  );
  
  - is_equal_map other:SELF :BOOLEAN <-
  ( + result:BOOLEAN;
    + lnk1, lnk2:LINK[E];    
    result := FALSE;    
    ( self = other).if {
      result := TRUE;
    }.elseif { upper = other.upper} then {
      result := TRUE;
      lnk1 := first_link;
      lnk2 := other.first_link;
      { (lnk1 = NULL) || ! result}.until_do {
	result := safe_equal (lnk1.item),(lnk2.item);
	lnk1 := lnk1.next;
	lnk2 := lnk2.next;
      };
    };
    ? { result ->> {(lower = other.lower) & (upper = other.upper)}};    
    result
  );
  
  - index_of x:E :INTEGER <-
  ( + result:INTEGER;
    result := lower;
    {(result > upper) || {safe_equal x,(item result)}}.until_do {
      result := result + 1;
    };
    ? { lower <= result };
    ? { result <= upper + 1 };
    ? { (result <= upper) ->> { element == (item result)}};    
    result
  );
  
  - fast_index_of x:E :INTEGER <-
  ( + u:INTEGER;
    + result:INTEGER;
    result := lower;
    u := upper;
    { (result > u) || { x = item result}}.until_do {
      result := result + 1;
    };
    ? { lower <= result };
    ? { result <= upper + 1 };
    ? { (result <= upper) ->> { x = item result}};    
    result
  );
  
  - clear <-
  (
    ( first_link != NULL).if {
      first_link := NULL;
      mem_idx := 0;
      mem_lnk := NULL;
      upper := 0;
      last_link := NULL;
    };
    ? { is_empty };    
    ? { upper = 0 };
  );
  
  - from_collection model:COLLECTION[E] <-
  ( + lnk:LINK[E];
    ? { model != NULL };    
    ( first_link = NULL).if {
      (model.lower).to (model.upper) do { i:INTEGER;
	add_last (model.item i);
      };
    } else {
      lnk := first_link;
      (model.lower).to (model.upper) do { i:INTEGER;
	( lnk = NULL).if {
	  add_last (model.item i);
	} else {
	  lnk.set_item (model.item i);
	  lnk := lnk.next;
	};
      };
      ( lnk = first_link ).if {
	? { model.count = 0 };	
	clear;
      }.elseif { lnk != NULL } then {
	+ i:INTEGER;
	i := model.count;
	( mem_idx != i ).if {
	  go_item i;
	};
	? { lnk = mem_lnk.next };	
	mem_lnk.set_next NULL;
	upper := i;
	last_link := mem_lnk;
      };
    };
    ? { count = model.count };
  );
  
  - slice low:NUMERIC to up:NUMERIC :SELF <-
  ( + result:SELF;
    + lnk:LINK[E];
    ? { lower <= min };
    ? { max <= upper };
    ? { min <= max + 1 };
    result := SELF.create;
    
    ( mem_idx != low ).if {
      go_item low;
    };
    lnk := mem_lnk;
    (up - low + 1).downto 1 do { i:INTEGER;
      result.add_last lnk.item;
      lnk := lnk.next;
    };
    ? { same_dynamic_type result };
    ? { result.count = max - min + 1};
    ? { result.lower = lower };    
    result
  );
  
  - occurrences element:E :INTEGER <-
  ( + lnk:LINK[E];
    + result:INTEGER;
    
    lnk := first_link;
    
    { lnk = NULL}.until_do {
      (safe_equal element,(lnk.item)).if {
	result := result + 1;
      };
      lnk := lnk.next;
    };
    ? { result >= 0};  
    result
  );
  
  - fast_occurrences element:E :INTEGER <-
  ( + lnk:LINK[E];
    + result:INTEGER;
    lnk := first_link;
    { lnk = NULL}.until_do {
      ( element = lnk.item ).if {
	result := result + 1;
      };
      lnk := lnk.next;
    };
    ? { result >= 0};
    result
  );
  
  - force element:E to index:NUMERIC <-
  ( + v:E;
    { index <= upper }.until_do {
      add_last v;
    };
    put element to index;
  );
  
  - all_default:BOOLEAN <-
  ( + result:BOOLEAN;
    + l:LINK[E];
    + d:E;
    result := TRUE;
    l := first_link;
    { ! result || {l = NULL}}.until_do {
      result := (d = l.item);
      l := l.next;
    };
    
    result
  );
  
  - remove_last <-
  ( + old_count,old_upper:INTEGER;
    ? {! is_empty};
    old_count := count;
    old_upper := upper;
    ( upper = 1 ).if {
      make;
    } else {
      ( (upper - 1) != mem_idx).if {
	go_item (upper - 1);
      };
      upper := upper - 1;
      last_link := mem_lnk;
      last_link.set_next NULL;
    };
    ? { count = old_count - 1};
    ? { upper = old_upper - 1};    
  );
  
  - replace_all old_value:E with new_value:E <-
  ( + old_count:INTEGER;
    old_count := count;
    lower.to upper do { i:INTEGER;
      (safe_equal (item i),old_value).if {
	put new_value to i;
      };
    };
    ? { count = old_count};
    ? { occurrences old_value = 0};    
  );
  
  
  - fast_replace_all old_value:E with new_value:E <-
  ( + old_count:INTEGER;
    old_count := count;
    lower.to upper do { i:INTEGER;
      (item i = old_value).if {
	put new_value to i;
      };
    };
    ? { count = old_count};
    ? { occurrences old_value = 0};    
  );
  
  - get_new_iterator:ITERATOR[E] <-
  (
    ITERATOR_ON_LINKED_LIST[E].create self
  );
  
section PRIVATE
  
  - go_item i:NUMERIC <-
  (
    ? { valid_index i};
    ? { mem_idx != i};
    ? { mem_idx > 0};
    ? { mem_lnk != NULL};
    
    (mem_idx > i).if {
      mem_idx := 1;
      mem_lnk := first_link;
    };
    { i = mem_idx }.until_do {
      mem_lnk := mem_lnk.next;
      mem_idx := mem_idx + 1;
    };
    ? { mem_idx = i};
    ? { mem_lnk != NULL};
  );
  
  - invariant:BOOLEAN <-
  (
    ( (first_link = NULL) ->>  { (last_link = NULL) & (upper = 0) & (mem_idx = 0) & (mem_lnk = NULL)}) &&
    { (first_link != NULL) ->> { (last_link != NULL) & (upper > 0) & (mem_idx > 0) & (mem_lnk != NULL)}}
  );
  
