Section Header
  
  + name      := PARSER;

  - comment   := "Parser for Lisaac language.";

  // You can to get with
  // `grep "//++" parser.li' : Current grammar.
  // `grep "//--" parser.li' : Syntax rules.
  // `grep "////" parser.li' : lip grammar.
Section Inherit

  - parent_any:ANY := ANY;

Section Public

  //
  // Shorter Section.
  //

  - is_active_short:BOOLEAN;

  - short_dico:HASHED_DICTIONARY(LINKED_LIST STRING_ALIAS,STRING_ALIAS) :=
  HASHED_DICTIONARY(LINKED_LIST STRING_ALIAS ,STRING_ALIAS).create;

  - short_derive:INTEGER;

  - token:STRING_BUFFER := STRING_BUFFER.create 100;

  - short key:STRING_ALIAS token beg:INTEGER to end:INTEGER <-
  ( + pos:INTEGER;
    + add_text:STRING;
    + fmt:LINKED_LIST(STRING_ALIAS);

    (is_shorter).if {
      (is_active_short).if {
	//
	// SHORTER
	//
	(short_dico.fast_has key).if {
	  // Extract token.
	  token.clear;
	  pos := beg + short_derive;
	  beg.to (end-1) do { j:INTEGER;
	    token.add_last (source.item j);
	    output_code.remove pos;
	  };
	  short_derive := short_derive - token.count;
	  // Insert format.
	  fmt := short_dico.at key;
	  fmt.lower.to (fmt.upper) do { j:INTEGER;
	    (fmt.item j = NULL).if {
	      add_text := token;
	    } else {
	      add_text := fmt.item j;
	    };
	    output_code.insert_string add_text to pos;
	    pos := pos + add_text.count;
	    short_derive := short_derive + add_text.count;
	  };
	};
      };
    };
  );

  - short_remove begin:INTEGER to end:INTEGER <-
  (
    output_code.remove_between
    (begin + short_derive) to (end + short_derive);
    short_derive := short_derive - (end - begin + 1);
  );

  - short_local:HASHED_SET(STRING_ALIAS);

Section Private
  
  - has_list:BOOLEAN;
  
  - stack_string_buffer:ARRAY STRING_BUFFER := ARRAY STRING_BUFFER.create_with_capacity 5;  
  
  - new_string_buffer:STRING_BUFFER <-
  ( + result:STRING_BUFFER;

    (stack_string_buffer.is_empty).if {
      result := STRING_BUFFER.create 128;
    } else {
      result := stack_string_buffer.last;
      stack_string_buffer.remove_last;
    };
    result
  );

  - free_string_buffer str:STRING_BUFFER :STRING_ALIAS <-
  ( + result:STRING_ALIAS;

    result := str.to_string_alias;
    stack_string_buffer.add_last str;
    str.clear;
    result
  );
  
  //
  // Source information.
  //

  - object   : PROTOTYPE;

  - source   : NATIVE_ARRAY CHARACTER;
  - source_upper:INTEGER;
  - source_lower:INTEGER := 0;

  - position : INTEGER;

  - pos_cur  : INTEGER;
  - pos_line : INTEGER;
  - pos_col  : INTEGER;

  - begin_position:INTEGER; // begin item position

  - current_position:POSITION <-
  ( + result:POSITION;
    ? {pos_cur <= position};

    {pos_cur = position}.until_do {
      (source.item pos_cur = '\n').if {
	pos_col := 0;
	pos_line := pos_line + 1;
      } else {
	pos_col := pos_col + 1;
      };
      pos_cur := pos_cur + 1;
    };
    (pos_line > 32767).if {
      result := POSITION.create object line 32767 column pos_col;
      syntax_error (result,"Line counter overflow.");
    };
    (pos_col > 255).if {
      result := POSITION.create object line pos_line column 255;
      syntax_error (result,"Column counter overflow (line too long).");
    };
    POSITION.create object line pos_line column pos_col
  );

  //
  // AMBIGU Manager.
  //

  - old_position:INTEGER;
  - old_pos_cur :INTEGER;
  - old_pos_line:INTEGER;
  - old_pos_col :INTEGER;
  //
  - old_short_derive:INTEGER;

  - save_context <-
  (
    old_position := position;
    old_pos_cur  := pos_cur;
    old_pos_line := pos_line;
    old_pos_col  := pos_col;
    //
    old_short_derive := short_derive;
  );

  - restore_context <-
  ( + beg:INTEGER;

    (is_shorter).if {
      token.clear;
      beg := old_position + old_short_derive;
      output_code.remove_between beg to (position+short_derive-1);
      (old_position).to (position-1) do { j:INTEGER;
	token.add_last (source.item j);
      };
      output_code.insert_string token to beg;
      short_derive := old_short_derive;
    };

    position := old_position;
    pos_cur  := old_pos_cur;
    pos_line := old_pos_line;
    pos_col  := old_pos_col;
  );

  //
  // Syntax parser.
  //

  - last_character:CHARACTER <-
  ( + result:CHARACTER;
    (position > source_upper).if {
      result := 0.to_character;
      } else {
      result := source.item position;
    };
    result
  );

  - last_integer : INTEGER_64;
  - last_real    : STRING_ALIAS;
  - last_string  : STRING_ALIAS;
  - is_parameter_type:BOOLEAN;

  - last_comment_extern:STRING_ALIAS;
  - last_comment_slot  :STRING_ALIAS;
  - skip_comment:BOOLEAN;

  - put_new_line_comment str:STRING_BUFFER with cmt:STRING_ALIAS <-
  ( + lst:LINKED_LIST(STRING_ALIAS);
    + idx,idx_beg:INTEGER;
    lst := PARSER.short_dico.fast_reference_at cmt;
    (lst != NULL).if {
      {(idx := str.index_of '\n' since (idx+1)) < str.upper}.while_do {
        idx_beg := idx;
        idx := idx + 1;
        {
          (idx <= str.upper) &&
          {str.item idx <= ' ' } &&
          {str.item idx != '\n'}
        }.while_do {
          idx := idx + 1;
        };
        (str.item idx = '\n').if {
          str.replace_substring (lst.first) from idx_beg to (idx-1);
          idx := idx_beg + (lst.first.count)-1;
        };
      };
    };
  );

  - read_space:BOOLEAN <-
  ( + posold,pos,pos2:INTEGER;
    + level_comment:INTEGER;
    + stat:INTEGER;

    pos := position;
    posold := -1;
    (is_shorter2).if {
      string_tmp3.clear;
      string_tmp4.clear;
    };
    {posold = position}.until_do {
      posold := position;

      // Skip spaces :
      {(last_character = 0.to_character) || {last_character > ' '}}.until_do {
        ((is_shorter2) || {is_shorter}).if {
          (last_character = '\n').if {
            (stat)
            .when 0 then { stat := 1; }
            .when 1 then { stat := 2; }
            .when 2 then {            };
          };
        };
	position := position + 1;
      };

      (position < source_upper).if {
	// Skip C++ comment style :
	((last_character = '/') && {source.item (position + 1) = '/'}).if {
	  position := position + 2;
          pos2 := position;
	  {
	    (last_character = 0.to_character) ||
	    {last_character = '\n'}
          }.until_do {
            (is_shorter2).if {
              (stat)
              .when 0 or 1 then {
                string_tmp3.add_last last_character;
              }
              .when 2 then {
                string_tmp4.add_last last_character;
              };
            };
	    position := position + 1;
          };
          (is_shorter2).if {
            (stat)
            .when 0 or 1 then { string_tmp3.add_last '\n'; }
            .when 2      then { string_tmp4.add_last '\n'; };
          };
          (is_shorter).if {
            // BSBS: A revoir ...
            ((pos2-2+short_derive).in_range (output_code.lower) to (output_code.upper)).if {
              output_code.remove_between (pos2-2+short_derive) to (pos2-1+short_derive);
              short_derive := short_derive - 2;
            };
            // Bug ?
            ( + nb,p:INTEGER;
              p := pos2 - 3;
              {(p >= source_lower) && {source.item p <= ' '}}.while_do {
                (source.item p = '\n').if {
                  nb := nb + 1;
                };
                p := p - 1;
              };
              (nb > 1).if {
                stat := 2;
              };
            );
            (stat)
            .when 0 or 1 then {
              short "comment_slot_line" token pos2 to position;
            }
            .when 2 then {
              short "comment_line" token pos2 to position;
            };
          };
          position := position + 1;
	};
      };
      (position < source_upper).if {
	// Skip C comment style :
	pos2 := position;
	((last_character = '/') && {source.item (position+1) = '*'}).if {
	  position := position + 2;
	  level_comment := 1;
	  {
	    (last_character = 0.to_character) || {level_comment = 0}
	  }.until_do {
	    ((last_character = '/') && {source.item (position+1) = '*'}).if {
	      level_comment := level_comment + 1;
	      position := position + 2;
	    }.elseif {
	      (last_character = '*') && {source.item (position+1) = '/'}
	    } then {
	      level_comment := level_comment - 1;
	      position := position + 2;
	    } else {
	      position := position+1;
	    };
	  };
	  (level_comment != 0).if {
	    position := pos2;
	    syntax_error (current_position,"End of comment not found !");
	  };
	  //position := position+2;
	  short "comment" token pos2 to position;
	};
      };
    };
    ((is_shorter2) && {! skip_comment}).if {
      (string_tmp3.is_empty).if {
        last_comment_slot := NULL;
      } else {
        put_new_line_comment string_tmp3 with "comment_new_line_slot";
        last_comment_slot := string_tmp3.to_string_alias;
      };
      (string_tmp4.is_empty).if_false {
        put_new_line_comment string_tmp4 with "comment_new_line_extern";
        last_comment_extern := string_tmp4.to_string_alias;
      };
    };
    // FALSE : Last character.
    begin_position := position;
    ((position != pos) | (last_character != 0.to_character))
  );

  - read_symbol st:STRING_ALIAS :BOOLEAN <-
  ( + posold,j:INTEGER;
    + result:BOOLEAN;
    // On passe les espaces :
    (! read_space).if {
      result := FALSE;
    } else {
      posold := position;
      j := st.lower;
      {(last_character = 0.to_character) ||
      {(j > st.upper) || {last_character != st.item j}}}.until_do {
	j := j+1;
	position := position+1;
      };
      (j > st.upper).if {
        result := TRUE;
        last_string := st;
      } else {
	position := posold;
	result := FALSE;
      };
    };
    result
  );

  - read_character ch:CHARACTER :BOOLEAN <-
  ( + result:BOOLEAN;
    // On passe les espaces :
    (! read_space).if {
      result := FALSE;
    } else {
      (last_character = ch).if {
	position := position + 1;
	result := TRUE;
      };
    };
    result
  );

  //-- affect         -> ":=" | "<-" | "?="
  - read_affect:BOOLEAN <-
  (
    (read_symbol ":=") ||
    {read_symbol "?="} ||
    {read_symbol "<-"}
  );

  //-- style          -> '-' | '+'
  - read_style:CHARACTER <-
  ( + result:CHARACTER;
    read_character '-'.if {
      result := '-';
      short "slot_style" token (position-1) to position;
    }.elseif {read_character '+'} then {
      result := '+';
      short "slot_style" token (position-1) to position;
    } else {
      result := ' ';
    };
    result
  );
  
  //-- identifier     -> 'a'-'z' {'a'-'z' | '0'-'9' | '_'}
  - read_identifier:BOOLEAN <-
  ( + result:BOOLEAN;
    + posold,idx:INTEGER;

    // On passe les espaces :
    ((! read_space) || {! last_character.is_lower}).if {
      result := FALSE;
    } else {
      posold := position;
      string_tmp.clear;
      {
	(last_character = 0.to_character) ||
	{
	  (! last_character.is_lower) &&
	  {! last_character.is_digit} &&
	  {last_character != '_'}
	}
      }.until_do {
	string_tmp.add_last last_character;
	position := position+1;
      };
      (! string_tmp.is_empty).if {
	idx := string_tmp.first_substring_index "__";
	(idx != -1).if {
	  position := posold+idx;
	  syntax_error (current_position,"Identifier is incorrect.");
	};
	last_string := string_tmp.to_string_alias;
	result := TRUE;
      };
    };
    result
  );

  - read_word st:STRING_ALIAS :BOOLEAN <-
  ( + posold,idx:INTEGER;
    + result:BOOLEAN;
    // On passe les espaces :
    (! read_space).if {
      result := FALSE;
    } else {
      posold := position;
      idx := st.lower;
      {(idx > st.upper) || {last_character != st.item idx}}.until_do {
	position := position+1;
	idx := idx+1;
      };
      (idx>st.upper).if {
	last_string := st;
	result := TRUE;
      } else {
	position := posold;
      };
    };
    result
  );

  - read_this_keyword st:STRING_ALIAS :BOOLEAN <-
  ( + result:BOOLEAN;

    result := read_word st;
    (is_shorter).if {
      (result).if {
	(st = "Section").if {
	  short "Section" token (position-last_string.count) to position;
	} else {
	  short "keyword" token (position-last_string.count) to position;
	};
      };
    };
    result
  );

  //-- keyword        -> 'A'-'Z' 'a'-'z' {'a'-'z' | '0'-'9' | '_'}
  - read_keyword:BOOLEAN <-
  ( + result:BOOLEAN;
    // On passe les espaces :
    ((! read_space) || {! last_character.is_upper}).if {
      result := FALSE;
    } else {
      string_tmp.clear;
      string_tmp.add_last last_character;
      position := position + 1;
      (last_character.is_lower).if {
	string_tmp.add_last last_character;
	position := position + 1;
	{(last_character != 0.to_character) &&
	  {(last_character.is_lower) ||
	    {last_character.is_digit} ||
	{last_character = '_'}}}.while_do {
	  string_tmp.add_last last_character;
	  position := position+1;
	};
	last_string := string_tmp.to_string_tmp;
	result := TRUE;
	short "keyword" token
	(position-last_string.count) to position;
      } else {
	position := position - 1;
	result := FALSE;
      };
    };
    result
  );

  //-- cap_identifier -> 'A'-'Z' {'A'-'Z' | '0'-'9' | '_'}
  - read_cap_identifier:BOOLEAN <-
  ( + posold,idx:INTEGER;
    + result:BOOLEAN;
    + car:CHARACTER;
    // On passe les espaces :
    ((! read_space) || {! last_character.is_upper}).if {
      result := FALSE;
    } else {
      posold := position;
      string_tmp.clear;
      string_tmp.add_last last_character;
      position := position + 1;
      is_parameter_type := TRUE;
      {
	(last_character = 0.to_character) ||
	{
	  (! last_character.is_upper) &&
	  {! last_character.is_digit} &&
	  {last_character != '_'}
	}
      }.until_do {
        car := last_character;
        is_parameter_type := is_parameter_type && {car.is_digit};
	string_tmp.add_last car;
        position := position+1;
      };
      idx := string_tmp.first_substring_index "__";
      (idx != -1).if {
        position := posold + idx;
        syntax_error (current_position,"Identifier is incorrect.");
      };
      last_string := string_tmp.to_string_alias; 
      result := TRUE;
    };
    result
  );

  //-- integer        -> number
  //-- number         -> '0'-'9' {'0'-'9' | '_' | '\''} ['d']
  //--                 | '0'-'9' {'0'-'9' | 'A'-'F' | 'a'-'f' | '_' | '\''} 'h'
  //--                 | '0'-'7' {'0'-'7' | '_' | '\''} 'o'
  //--                 | ('0' | '1') {'0' | '1' | '_' | '\''} 'b'
  - read_integer:BOOLEAN <-
  ( + result:BOOLEAN;
    + pos_old:INTEGER;

    // On passe les espaces :
    ((read_space) && {last_character.is_digit}).if {
      result := TRUE;
      string_tmp.clear;
      string_tmp.add_last last_character;
      pos_old := position;
      position := position + 1;
      {(last_character.is_hexadecimal_digit) || {last_character = '_'} || {last_character = '\''}}.while_do {
	((last_character != '_') && {last_character != '\''}).if {
	  string_tmp.add_last last_character;
	};
	position := position + 1;
      };
      (last_character = 'h').if {
	last_integer := string_tmp.to_hexadecimal;
	position := position+1;
      } else {
	(string_tmp.last > '9').if {
	  string_tmp.remove_last 1;
	  position := position - 1;
	};
	(last_character='o').if {
	  (! string_tmp.is_octal).if {
	    syntax_error (current_position,"Incorrect octal number.");
	  };
	  last_integer := string_tmp.to_octal;
	  position := position+1;
	}.elseif {last_character='b'} then {
	  (! string_tmp.is_bit).if {
	    syntax_error (current_position,"Incorrect binary number.");
	  };
	  last_integer := string_tmp.to_binary;
	  position := position+1;
	} else {
	  (last_character='d').if {
	    position := position+1;
	  };
	  (! string_tmp.is_integer_64).if {
	    syntax_error (current_position,"Incorrect decimal number.");
	  };
	  last_integer := string_tmp.to_integer_64;
	};
      };
    };
    (result).if {
      short "integer" token pos_old to position;
    };
    result
  );

  - read_real:BOOLEAN <-
  //-- real           -> '0'-'9' {'0'-'9' | '_' | '\''} [ '.' {'0'-'9'} ] [ 'E' ['+'|'-'] '0'-'9' {'0'-'9'}
  ( + result:BOOLEAN;
    + pos_old:INTEGER;

    // On passe les espaces :
    ((read_space) && {last_character.is_digit}).if {
      string_tmp.clear;
      string_tmp.add_last last_character;
      pos_old := position;
      position := position + 1;
      {(last_character.is_digit) || {last_character = '_'} || {last_character = '\''}}.while_do {
	((last_character != '_') && {last_character != '\''}).if {
	  string_tmp.add_last last_character;
	};
	position := position + 1;
      };
      (last_character = '.').if {
	string_tmp.add_last '.';
	position := position + 1;
	(last_character.is_digit).if {
	  result := TRUE;
	  string_tmp.add_last last_character;
	  position := position + 1;
	  {last_character.is_digit}.while_do {
	    string_tmp.add_last last_character;
	    position := position + 1;
	  };
	};
	(last_character = 'E').if {
	  result := TRUE;
	  string_tmp.add_last 'E';
	  position := position + 1;
	  ((last_character = '+') || {last_character = '-'}).if {
	    string_tmp.add_last last_character;
	    position := position + 1;
	  };
	  (last_character.is_digit).if {
	    string_tmp.add_last last_character;
	    position := position + 1;
	    {last_character.is_digit}.while_do {
	      string_tmp.add_last last_character;
	      position := position + 1;
	    };
	  } else {
	    syntax_error (current_position,"Incorrect real number.");
	  };
	};
      };
      (result).if {
	last_real := string_tmp.to_string_alias;
      } else {
	position := pos_old;
      };
    };
    (result).if {
      short "integer" token pos_old to position;
    };
    result
  );

  //-- escape         -> '\\' separator {separator} '\\'
  //--                 | '\\' escape_seq
  //--                 | '\\' integer '\\'
  //-- escape_seq     -> 'a' | 'b'  | 'f' | 'n'  | 'r'  | 't'
  //--                 | 'v' | '\\' | '?' | '\'' | '\"' | '0'
  - read_escape_character <-
  ( + nothing:BOOLEAN;
    + val:INTEGER;
    last_character.is_separator.if {
      read_space;      
      (last_character='\\').if {
	string_tmp.remove_last 1;
	position := position+1;
      }.elseif {last_character != 0.to_character} then {
	syntax_error (current_position,"Unknown escape sequence. (1)");
      };
    }.elseif {last_character != 0.to_character} then {
      ( (last_character = 'a')  ||
	{last_character = 'b'}  ||
	{last_character = 'f'}  ||
	{last_character = 'n'}  ||
	{last_character = 'r'}  ||
	{last_character = 't'}  ||
	{last_character = 'v'}  ||
	{last_character = '\\'} ||
	{last_character = '?'}  ||
	{last_character = '\''} ||
	{last_character = '\"'}
      ).if {
	string_tmp.add_last last_character;
	position := position+1;
      }.elseif {last_character.in_range '0' to '9'} then {
	(
          (last_character='0') &&
	  {position<source_upper} &&
          {! source.item(position+1).is_hexadecimal_digit}
        ).if {
	  string_tmp.add_last last_character;
	  position := position+1;
	} else {
	  string_tmp2.copy string_tmp;
	  nothing := read_integer; // result is Always TRUE.
	  string_tmp.copy string_tmp2;
	  (last_integer > 255).if {
	    syntax_error (current_position,
	    "Invalid range character number [0,255].");
	  };
	  val := last_integer.to_integer;
	  string_tmp.add_last ((val / 64).decimal_digit);
	  string_tmp.add_last (((val % 64) / 8).decimal_digit);
	  string_tmp.add_last ((val % 8).decimal_digit);
	  (last_character='\\').if {
	    position := position + 1;
	  } else {
	    syntax_error (current_position,"Character '\' is needed.");
	  };
	};
      } else {
	syntax_error (current_position,"Unknown escape sequence. (2)");
      };
    };
  );

  //-- character      -> '\'' ascii '\''
  - read_characters:BOOLEAN <-
  ( + result:BOOLEAN;
    + old_pos:INTEGER;
    + count:INTEGER;
    // On passe les espaces :
    ((read_space) && {last_character='\''}).if {
      old_pos := position;
      position := position+1;
      string_tmp.clear;
      {
        (last_character=0.to_character) ||
	{last_character='\n'} ||
        {last_character='\''}
      }.until_do {
	string_tmp.add_last last_character;
	(last_character='\\').if {
	  position := position+1;
          read_escape_character;
          count := count + 1;
	} else {
          position := position+1;
          count := count + 1;
	};
      };
      (last_character='\'').if {
	position := position+1;
	last_string := string_tmp.to_string_alias;
	(count != 1).if {
	  position := begin_position;
	  syntax_error (current_position,"Character constant too long.");
	};
	result := TRUE;
	short "character" token old_pos to position;
      } else {
	position := begin_position;
	syntax_error (current_position,"Unterminated character constant.");
      };
    };
    result
  );

  //-- string         -> '\"' string_char '\"'
  //-- string_char    -> escape
  //--                 | ascii
  - read_string:BOOLEAN <-
  ( + result:BOOLEAN;
    + old_pos:INTEGER;
    // On passe les espaces :
    ((read_space) && {last_character='\"'}).if {
      old_pos := position;
      position := position+1;
      string_tmp.clear;
      {
        (last_character=0.to_character) ||
	{last_character='\n'} ||
        {last_character='\"'}
      }.until_do {
	string_tmp.add_last last_character;
	(last_character='\\').if {
	  position := position+1;
	  read_escape_character;
	} else {
	  position := position+1;
	};
      };
      (last_character='\"').if {
	position := position+1;
	last_string := string_tmp.to_string_alias;
	result := TRUE;
	short "string" token old_pos to position;
      } else {
	position := begin_position;
	syntax_error (current_position,"Unterminated string constant.");
      };
    };
    result
  );

  //-- external       -> '`' ascii_c_code '`'
  - read_external:BOOLEAN <-
  ( + result:BOOLEAN;
    + pos_old:INTEGER;
    // On passe les espaces :
    ((! read_space) || {last_character != '`'}).if {
      result := FALSE;
    } else {
      pos_old:=position;
      position := position+1;
      string_tmp.clear;
      {(last_character = 0.to_character) | (last_character='`')}.until_do {
	string_tmp.add_last last_character;
	(last_character='\\').if {
	  position := position+1;
	  string_tmp.add_last last_character;
	  (last_character != 0.to_character).if {
	    position := position+1;
	  };
	} else {
	  position := position+1;
	};
      };
      (last_character != 0.to_character).if {
	position := position+1;
	last_string := string_tmp.to_string_alias;
	result := TRUE;
	short "external" token pos_old to position;
      } else {
	result := FALSE;
      };
    };
    result
  );

  //-- operator       -> '!' | '@' | '#' | '$' | '%' | '^' | '&' | '<' | '|'
  //--                 | '*' | '-' | '+' | '=' | '~' | '/' | '?' | '\' | '>'
  - read_operator:BOOLEAN <-
  ( + result:BOOLEAN;
    + old_pos:INTEGER;
    // On passe les espaces :
    (read_space).if {
    };
    old_pos:=position;
    string_tmp.clear;
    {(last_character = 0.to_character) ||
    {! "!@#$%^&<|*-+=~/?\\>".has last_character}}.until_do {
      string_tmp.add_last last_character;
      position := position+1;
    };
    (! string_tmp.is_empty).if {
      last_string := string_tmp.to_string_alias;
      (
	(last_string = ":=") ||
	{last_string = "<-"} ||
	{last_string = "?="}
      ).if {
	syntax_error (current_position,"Incorrect operator.");
      };
      short "operator" token old_pos to position;

      ((last_string = "=") || {last_string = "!="}).if {
        count_equal_parse := count_equal_parse + 1;
      };

      result := TRUE;
    };
    result
  );

  //
  // Variable & function Global.
  //

  - last_slot:ITM_SLOT;

  - last_group:ITM_LIST;

  - last_section:SECTION_;

  //
  // PARSER
  //

  //++ PROGRAM      -> { "Section" SECTION [CONTRACT] { SLOT } [CONTRACT] }
  //++ SECTION      -> ('Header' | 'Inherit' | 'Insert' | 'Interrupt' | 'External' | 'Mapping') [ ',' ACCESS ] 
  //++               | ACCESS  
  - read_program:BOOLEAN <-
  ( + result:BOOLEAN;
    + pos_sec,old_derive:INTEGER;

    result := TRUE;

    pos_sec := position;
    old_derive := short_derive;

    read_space;

    (is_shorter).if {
      output_code.remove_between (source_lower+old_derive) to (position-1+short_derive);
      short_derive := short_derive - ((position+short_derive) - (source_lower+old_derive));
    };
    pos_sec := position;
    old_derive := short_derive;
    last_comment_extern := NULL;
    //
    // Read Section Header.
    //
    (read_this_keyword "Section").if_false {
      syntax_error (current_position,"`Section' is needed.");
    };
    (read_this_keyword "Header").if_false {
      syntax_error (current_position,"Section `Header' is needed.");
    };
    last_section := SECTION_.create current_position;
    last_section.set_style "Header";
        
    object.set_pattern_in read_contract;
    read_character ';';
    
    (read_slot_header TRUE).if_false {
      syntax_error (current_position,"Slot `name' not found.");
    };
    {read_slot_header FALSE}.while_do {
    }; // loop

    (is_shorter2).if {
      object.set_comment_header last_comment_extern;
    };
    
    object.set_pattern_out read_contract;
    read_character ';';
    
    //
    // Read Section Other.
    //
    {read_this_keyword "Section"}.while_do {
      last_comment_extern := NULL;
      last_section := SECTION_.create current_position;
      (
        (read_this_keyword "Inherit")  || {read_this_keyword "Insert"} || {read_this_keyword "Interrupt"} ||
        {read_this_keyword "External"} || {read_this_keyword "Mapping"}
      ).if {
        last_section.set_style last_string;
        (last_section.is_mapping).if {
          object.set_mapping;          
        }.elseif {last_section.is_external} then {
          object.set_external;
        };
        (read_character ',').if {
          read_access;
        };
      } else {        
        read_access;
      };
            
      last_section.set_pattern_in read_contract;            
      read_character ';';
      
      {read_slot}.while_do {
      }; // loop      
      last_section.set_pattern_out read_contract;
      read_character ';';
            
      (is_shorter).if {
	(
	  (! is_short_private) &&
	  {last_section.is_private}
	).if {
	  output_code.remove_between
	  (pos_sec + old_derive) to (position + short_derive - 1);
	  short_derive := old_derive - (position - pos_sec);
	};

	pos_sec:=position;
	old_derive:=short_derive;
      };  
    }; // loop
    
    // End of file :
    result := result | read_space;
    (last_character != 0.to_character).if {
      syntax_error (current_position,"Incorrect symbol.");
    };
    result
  );  // read_program
  
  //++ ACCESS       -> 'Directory' | 'Public' | 'Private' | PROTOTYPE { ',' PROTOTYPE }
  - read_access <-
  ( + ts:ARRAY ITM_TYPE_MONO;
    + t:ITM_TYPE_MONO;
    ((read_this_keyword "Public") || {read_this_keyword "Private"} || {read_this_keyword "Directory"}).if {
      last_section.set_access_name last_string;
      (
        (last_section.is_inherit_or_insert) &&
        {object.last_slot != NULL} &&
        {! object.last_slot.id_section.is_inherit_or_insert}
      ).if {
        syntax_error (current_position,"`Section Inherit/Insert' must to be first section.");
      }.elseif {
        (last_section.is_inherit) &&
        {object.type_style = "Expanded"} &&
        {object.name != "TRUE" } &&
        {object.name != "FALSE"}
      } then {
        warning_error (current_position,
        "`Section Inherit' is not possible with Expanded object (Use `Section Insert').");
      };      
    } else {      
      t := read_prototype;
      (t = NULL).if {
        syntax_error (current_position,"Incorrect type Section.");
      };
      ts := ALIAS_ARRAY ITM_TYPE_MONO.new;
      ts.add_last t;
      {read_character ','}.while_do {
        t := read_prototype;
        (t = NULL).if {
          syntax_error (current_position,"Incorrect access Section.");
        };
        ts.add_last t;
      };
      last_section.set_access_list (ALIAS_ARRAY ITM_TYPE_MONO.alias ts);
    };
  );
  
  //++ SLOT         -> style TYPE_SLOT [':' TYPE_RESULT][ affect DEF_SLOT ]';'
  - read_slot:BOOLEAN <-
  ( + result:BOOLEAN;
    + t:ITM_TYPE;   
    + style:CHARACTER;
    + affect:CHARACTER;
    + old_pos,old_derive:INTEGER;
    + s:ITM_SLOT;

    style  := read_style;
    (style != ' ').if {
      //
      // Classic slot.
      //
      result := TRUE;
      //
      last_slot := read_type_slot;
      (last_slot = NULL).if {
	syntax_error (current_position,"Incorrect slot declaration.");
      };

      last_slot.set_style style;

      (read_affect).if {
	affect := last_string.first;
      } else {
	affect := ' ';
      };

      // ':' TYPE_RESULT
      ((affect = ' ') && {read_character ':'}).if {
	t := read_type_result;
        (t = NULL).if {
          syntax_error (current_position,"Type result not found.");
        };
	(read_affect).if {
	  affect := last_string.first;
	};
      } else {
	t := ITM_TYPE_SIMPLE.type_void;
      };
      last_slot.set_result_type t;
      last_slot.set_affect affect;

      (affect != ' ').if {
        read_space;
        (is_shorter2).if {
          (last_comment_slot != NULL).if {
            last_slot.set_comment last_comment_slot;
          };
          (last_comment_extern != NULL).if {
            last_slot.set_comment_chapter last_comment_extern;
          };
          skip_comment := TRUE;
        };
	old_pos    := position;
        old_derive := short_derive;
	read_def_slot;
      };

      (read_character ';').if_false {
	warning_error (current_position,"Added ';'.");
      };
      (is_shorter2).if {
        skip_comment := FALSE;
        read_space;
        ((last_slot.comment = NULL) && {last_comment_slot != NULL}).if {
          last_slot.set_comment last_comment_slot;
        };
      };

      (is_shorter).if {
	(
	  (! is_short_code) &&
	  {old_pos != 0} &&
	  {! last_section.is_header}
	).if {
	  (current_position.column<5).if {
	    {
	      (last_character != 0.to_character) &&
	      {last_character.is_separator} &&
	      {last_character != '\n'}
	    }.while_do {
	      position := position + 1;
	    };
	    (last_character = '\n').if {
	      position := position + 1;
	    };
	  };
	  output_code.remove_between
	  (old_pos + old_derive) to (position + short_derive - 1);
	  short_derive := old_derive - (position - old_pos);
	};
      };

      // Added slot in prototype :
      s := object.slot_list.fast_reference_at (last_slot.name);
      (s != NULL).if {
	POSITION.put_error semantic text "Double slot declaration.";
	s.position.put_position;
	last_slot.position.put_position;
	POSITION.send_error;
      };
      object.add_slot last_slot;

      (is_shorter).if {
	short_local.clear;
      };
    };
    result
  );  // read_slot

  //++ TYPE_SLOT    -> [ LOC_ARG '.' ] identifier [ LOC_ARG { identifier LOC_ARG } ]
  //++               | [ LOC_ARG ] '\'' operator '\'' [("Left"|"Right") [integer]] [LOC_ARG]
  - read_type_slot:ITM_SLOT <-
  ( + arg:ITM_ARGUMENT;
    + result:ITM_SLOT;
    + list_arg:ARRAY ITM_ARGUMENT;

    list_arg := ALIAS_ARRAY ITM_ARGUMENT.new;
    //warning_error (current_position,"LA");
    has_list := FALSE;
    arg := read_loc_arg FALSE self TRUE;

    (arg = NULL).if {
      (read_character '\'').if {
	result := read_slot_operator list_arg;
      } else {        
        arg := ITM_ARG.create current_position name "Self" type (ITM_TYPE_SIMPLE.type_self);
	list_arg.add_last arg;
	result := read_slot_keyword list_arg;
      };
    } else {
      list_arg.add_last arg;
      (read_character '.').if {
	result := read_slot_keyword list_arg;
      }.elseif {read_character '\''} then {
	result := read_slot_operator list_arg;
      };
    };
    (result != NULL).if {
      list_arg := ALIAS_ARRAY ITM_ARGUMENT.alias list_arg;
      result.set_argument_list list_arg with_list has_list;
    };
    result
  );

  - read_slot_keyword list_arg:ARRAY ITM_ARGUMENT :ITM_SLOT <-
  ( + n:STRING_BUFFER;
    + arg:ITM_ARGUMENT;
    + result:ITM_SLOT;

    read_identifier.if {
      short "slot" token (position-last_string.count) to position;

      n  := new_string_buffer;
      n.copy last_string;
      arg := read_loc_arg FALSE self FALSE;
      (arg != NULL).if {
	list_arg.add_last arg;
	(read_identifier).if {
	  (last_section.is_external).if {
	    syntax_error (current_position,"Incorrect in `Section External'.");
	  };
	  {
	    short "slot" token
	    (position-last_string.count) to position;
	    n.append "__";
	    n.append last_string;
	    arg := read_loc_arg FALSE self FALSE;
	    (arg = NULL).if {
	      syntax_error (current_position,"Incorrect symbol.");
	    }; // if
	    list_arg.add_last arg;
	  }.do_while {read_identifier}; // loop
	};
      }; // if
      result := ITM_SLOT.create current_position name (free_string_buffer n) feature last_section;
    };
    result
  );

  - read_slot_operator list_arg:ARRAY ITM_ARGUMENT :ITM_SLOT <-
  ( + name,pretty_name:STRING_ALIAS;
    + associativity:STRING_ALIAS;
    + priority:INTEGER;
    + arg:ITM_ARGUMENT;
    + result:ITM_SLOT_OPERATOR;

    (! read_operator).if {
      syntax_error (current_position,"Operator is needed.");
    };
    (
      (last_string = "=") ||
      {last_string = "!="}
    ).if {
      syntax_error (current_position,"Incorrect operator.");
    };
    pretty_name := name := last_string;
    (! read_character '\'').if {
      warning_error (current_position,"Added `''.");
    };
    (
      (read_this_keyword "Left") ||
      {read_this_keyword "Right"}
    ).if {
      associativity := last_string;
      (read_integer).if {
	priority := last_integer.to_integer;
      };
    };

    (list_arg.is_empty).if {
      // Prefix operator.
      arg := read_loc_arg FALSE self TRUE;
      (arg = NULL).if {
	syntax_error (current_position,"Operator declaration invalid.");
      };
      list_arg.add_last arg;
      name := operator "__prefix" name name;
      (associativity != NULL).if {
	syntax_error (current_position,"Not associativity for postfix operator.");
      };
    } else {
      arg := read_loc_arg FALSE self FALSE;
      (arg != NULL).if {
	// Infix operator.
	list_arg.add_last arg;
	name := operator "__infix" name name;
	(associativity = NULL).if {
	  associativity := "Left";
	};
      } else {
	// Postfix operator.
	name := operator "__postfix" name name;
	(associativity != NULL).if {
	  syntax_error (current_position,"Not associativity for prefix operator.");
	};
      };
    };
    result := ITM_SLOT_OPERATOR.create current_position name name feature last_section;
    result.set_associativity associativity priority priority;
    result.set_pretty_name pretty_name;
    result
  );  // read_slot_operator

  //++ DEF_SLOT     -> [CONTRACT] EXPR [CONTRACT]
  - read_def_slot <-
  ( + expr:ITM_CODE;

    last_slot.set_pattern_in read_contract;
    expr := read_expr;
    (expr = NULL).if {
      syntax_error (current_position,"Incorrect expression.");
    };
    last_slot.set_value expr type object;
    last_slot.set_pattern_out read_contract;
  );
  
  //++ TYPE_RESULT  -> TYPE
  //++               | '(' TYPE_LIST ')'
  - read_type_result:ITM_TYPE <-
  ( + result:ITM_TYPE;    
    result := read_type;
    ((result = NULL) && {read_character '('}).if {
      result := read_type_list;
      (result = NULL).if {
        syntax_error (current_position,"Incorrect type.");
      };
      (read_character ')').if_false {
        warning_error (current_position,"Added ')'.");
      };
    };
    result
  );
  
  //++ TYPE_LIST    -> TYPE [ ',' ( TYPE { ',' TYPE } } | '...' ) ]  
  - read_type_list:ITM_TYPE <-
  ( + lst:ARRAY ITM_TYPE;
    + t:ITM_TYPE;    
    + result:ITM_TYPE;

    result := read_type;
    ((result != NULL) && {read_character ','}).if {
      (read_word "...").if {
        result := result.set_list;
      }.elseif {(t := read_type) != NULL} then {        
        lst := ALIAS_ARRAY ITM_TYPE.new;
        lst.add_last result;
        lst.add_last t;
        {read_character ','}.while_do {
          t := read_type;
          (t = NULL).if {
            syntax_error (current_position,"Incorrect type list.");
          };	
          lst.add_last t;
        };
        lst := ALIAS_ARRAY ITM_TYPE.alias lst;
        result := ITM_TYPE_MULTI.get lst;
      } else {
        syntax_error (current_position,"Incorrect type list.");
      };
    };
    result
  );

  //++ LOC_ARG      -> identifier ':' TYPE
  //++               | '(' ARG ')'
  - read_loc_arg mute:BOOLEAN self self_first:BOOLEAN :ITM_ARGUMENT <-
  ( + result:ITM_ARGUMENT;
    + t:ITM_TYPE;
    + pos:POSITION;
    + n:STRING_ALIAS;
    + tb:ITM_TYPE_BLOCK;

    (
      ((  self_first) && {read_this_keyword "Self"}) ||
      {(! self_first) && {read_identifier}}
    ).if {
      pos := current_position;
      n   := last_string;
      ((read_character ':') && {last_character != '='}).if {
	t := read_type;
	(t = NULL).if {
	  syntax_error (current_position,"Incorrect type.");
        };
	(
	  (self_first) &&
          {t != ITM_TYPE_SIMPLE.type_self} &&
          {
            (object.name != "BLOCK") ||
            {tb ?= t; tb = NULL}
          }
        ).if {
	  syntax_error (current_position,"Type `SELF' is needed.");
	};
	result := ITM_ARG.create pos name n type t;

	(is_shorter).if {
	  short_local.add n;
	};
      } else {
        (!mute).if {
          warning_error (current_position,"Added ':' is needed.");
        };
      };
    }.elseif {read_character '('} then {
      result := read_arg mute self self_first;
      ((result = NULL) && {!mute}).if {	
        syntax_error (current_position,"Incorrect argument definition.");
      };
      ((result != NULL) && {! read_character ')'}).if {
        warning_error (current_position,"Added ')'.");
      };
    };
    result
  );
  
  //++ ARG          -> identifier { [':' TYPE] ',' identifier } ':' TYPE [ ',' '...' ]
  - read_arg mute:BOOLEAN self self_first:BOOLEAN :ITM_ARGUMENT <-
  ( + result:ITM_ARGUMENT;
    + t:ITM_TYPE;   
    + n_lst:ARRAY STRING_ALIAS;
    + t_lst:ARRAY ITM_TYPE;
    + is_type,is_stop:BOOLEAN;
    n_lst := ALIAS_ARRAY STRING_ALIAS.new;
    t_lst := ALIAS_ARRAY ITM_TYPE.new;
    (
      ((! self_first) && {read_identifier         }) || 
      {(  self_first) && {read_this_keyword "Self"}}
    ).if {      
      {(! is_stop) && {(is_type := read_character ':' && {last_character != '='}) || {read_character ','}}}.while_do {
        n_lst.add_last last_string;
        (is_type).if {
          t := read_type;
          (t = NULL).if {
            (mute).if {
              is_stop := TRUE;
            } else {
              syntax_error (current_position,"Incorrect type.");
            };
          };
          (! is_stop).if {            
            (read_character ',').if {
              (! read_identifier).if {
                (! read_word "...").if {
                  syntax_error (current_position,"Incorrect argument.");
                };
                (n_lst.count > 1).if {
                  semantic_error (current_position,"List argument must to be on one argument.");
                };
                t := t.set_list;              
                has_list := TRUE;
                is_stop := TRUE;
              };            
            };
            {n_lst.count != t_lst.count}.while_do { t_lst.add_last t; };
          };
        } else {  
          ((! read_identifier) && {! mute}).if { 
            syntax_error (current_position,"Incorrect argument.");
          };
        };
      };      
      ((n_lst.count != t_lst.count) || {n_lst.count = 0}).if {
        (! mute).if {
          syntax_error (current_position,"Incorrect argument vector.");
        };
      } else {
        (n_lst.count = 1).if {
          result := ITM_ARG.create (current_position) name (n_lst.first) type (t_lst.first);
          ALIAS_ARRAY STRING_ALIAS.free n_lst;
          ALIAS_ARRAY ITM_TYPE.free t_lst;
        } else {
          result := ITM_ARGS.create (current_position) name (ALIAS_ARRAY STRING_ALIAS.alias n_lst) 
          type (ITM_TYPE_MULTI.get (ALIAS_ARRAY ITM_TYPE.alias t_lst));
        };
      };
    };
    result
  );
  
  //++ LOCAL        -> identifier { ',' identifier } ':' TYPE [ ',' '...' ] 
  - read_local :ARRAY ITM_LOCAL <-
  ( + t:ITM_TYPE;
    + result,lst:ARRAY ITM_LOCAL;

    (read_identifier).if {
      lst := ALIAS_ARRAY ITM_LOCAL.new;      
      lst.add_last (ITM_LOCAL.create current_position name last_string);
      {(read_character ',') && {read_identifier}}.while_do {
        lst.add_last (ITM_LOCAL.create current_position name last_string);
      };	
      ((read_character ':') && {last_character != '='}).if {
        t := read_type;
        (t = NULL).if {
          syntax_error (current_position,"Incorrect local type.");
        };
        (read_character ',').if {
          (read_word "...").if_false {
            syntax_error (current_position,"'...' needed.");
          };
          t := t.set_list;            
        };
        0.to (lst.upper) do { j:INTEGER;          
          lst.item j.set_type t;
        };        
        result := ALIAS_ARRAY ITM_LOCAL.copy lst;
      } else {
        ALIAS_ARRAY ITM_LOCAL.free lst;
      };

      (is_shorter).if {
        (result.lower).to (result.upper) do { j:INTEGER;
          short_local.add (result.item j.name);
        };
      };
    };

    result
  );  // read_local
  
  //++ TYPE         -> PROTOTYPE
  //++               | TYPE_VECTOR
  - read_type:ITM_TYPE <-
  ( + result:ITM_TYPE;
    result := read_prototype;
    (result = NULL).if {
      result := read_type_vector;      
    };
    result
  );
  
  //++ TYPE_SHORT   -> TYPE_BEGIN
  //++               | TYPE_VECTOR
  - read_type_short:ITM_TYPE <-
  ( + result:ITM_TYPE;
    + styl:UINTEGER_8;
    + nam:STRING_ALIAS;
    (result, styl, nam) := read_type_begin;
    (result = NULL).if {
      (nam != NULL).if {
        (styl = 0).if {
          result := ITM_TYPE_SIMPLE.get nam;
        } else {            
          result := ITM_TYPE_STYLE.get nam style styl;
        };
      } else {
        result := read_type_vector;      
      };
    };
    result
  );
  
  //++ TYPE_VECTOR  -> '(' TYPE { ',' TYPE } ')'
  //++               | '{' [ TYPE_RESULT ';' ] [ TYPE_LIST ] '}'
  - read_type_vector:ITM_TYPE <-
  ( + result,t,typ_arg,typ_res:ITM_TYPE;
    + lt:ARRAY ITM_TYPE;
    + lst:ARRAY ITM_TYPE;
    (read_character '{').if {
      // '{' [ TYPE_RESULT ';' ] [ TYPE_LIST ] '}'
      t := read_type_result;
      (t != NULL).if {
        (read_character ';').if {
          typ_arg := t;
          typ_res := read_type_list;
        } else {
          lst := ALIAS_ARRAY ITM_TYPE.new;
          lst.add_last t;          
          {read_character ','}.while_do {
            t := read_type;
            (t = NULL).if {
              syntax_error (current_position,"Type not found.");
            };
            lst.add_last t;
          };
          (lst.count > 1).if { 
            lst := ALIAS_ARRAY ITM_TYPE.alias lst;
            typ_res := ITM_TYPE_MULTI.get lst;
          } else {
            typ_res := lst.first;  
            ALIAS_ARRAY ITM_TYPE.free lst;            
          };          
        };        
      };
      (! read_character '}').if {
	warning_error (current_position,"Added '}'.");
      }; // if
      result := ITM_TYPE_BLOCK.get typ_arg and typ_res;
    }.else_if {read_character '('} then {
      result := read_type;
      lt := ALIAS_ARRAY ITM_TYPE.new;
      lt.add_last result;      
      (result = NULL).if {
        syntax_error (current_position,"Type not found.");
      };
      {read_character ','}.while_do {
        t := read_type;
        (t = NULL).if {
          syntax_error (current_position,"Type not found.");
        };
        lt.add_last t;
      };
      result := ITM_TYPE_MULTI.get (ALIAS_ARRAY ITM_TYPE.alias lt);
      (read_character ')').if_false {
        warning_error (current_position,"Added ')'.");
      };
    };
    result
  );    
    
  //++ TYPE_BEGIN   -> ("Strict" | "Expanded") cap_identifier{('.'|'...')cap_identifier}  
  - read_type_begin:(ITM_TYPE_MONO, UINTEGER_8, STRING_ALIAS) <-
  ( + style:UINTEGER_8;
    + result:ITM_TYPE_MONO;
    + nam:STRING_ALIAS;
    + old_pos,old_derive,pos_before:INTEGER;
    + continue:BOOLEAN;
    
    (      
      (read_this_keyword "Expanded") ||
      {read_this_keyword "Strict"}
    ).if {
      (last_string = "Expanded").if {
        style := TYPE_FULL.expanded_bit;
      } else {
        style := TYPE_FULL.strict_bit;	       
      };
    };
    // PROTOTYPE
    //style := style | (read_character '\\'.to_integer << 7); // See TYPE_FULL for bit number.
    (read_cap_identifier).if {
      old_pos    := position;
      old_derive := short_derive;
      string_tmp2.copy last_string;
      {
        continue := read_word "...";
        (continue).if {
          (read_cap_identifier).if_false {
            syntax_error (current_position,"Prototype name needed.");
          };
          string_tmp2.append "...";
          string_tmp2.append last_string;
        } else {
          pos_before := position;
          ((read_character '.') && {read_cap_identifier}).if {
            continue := TRUE;
            string_tmp2.add_last '.';
            string_tmp2.append last_string;
          } else {
            position := pos_before;
          };
        };
      }.do_while {continue};      
      //
      nam := string_tmp2.to_string_alias;        
      (is_parameter_type).if {
        (style != 0).if {
          warning_error (current_position,"Style Expanded, Strict or \'\\\' is ignored.");
        };
        result := ITM_TYPE_PARAMETER.get nam;
      }.elseif {nam = "SELF"} then {
        ((style & ~TYPE_FULL.escape_bit) != 0).if {
          warning_error (current_position,"Style Expanded or Strict ignored.");
        };
        ((style & TYPE_FULL.escape_bit) != 0).if {            
          result := ITM_TYPE_SIMPLE.type_self_with_escape;
        } else {
          result := ITM_TYPE_SIMPLE.type_self;
        };
      };
    } else {
      (style != 0).if {
        warning_error (current_position,"Style (Expanded or Strict) ignored.");
      };
    };
    result, style, nam
  );
    
  //++ PROTOTYPE    -> TYPE_BEGIN [ TYPE_SHORT { cap_identifier TYPE_SHORT } ]
  - read_prototype:ITM_TYPE_MONO <-
  ( + nam:STRING_ALIAS;
    + genericity:ARRAY ITM_TYPE;
    + t:ITM_TYPE;
    + result:ITM_TYPE_MONO;
    + styl:UINTEGER_8;
    
    (result, styl, nam) := read_type_begin;
    (result = NULL).if {      
      (nam != NULL).if {
        t := read_type_short;
        (t != NULL).if {
          // Multiple Genericity.
          genericity := ALIAS_ARRAY ITM_TYPE.new;
          genericity.add_last t;        
          //warning_error (current_position,"LA");
          {read_cap_identifier}.while_do {
            string_tmp2.copy nam;
            string_tmp2.append "__";
            string_tmp2.append last_string;
            nam := string_tmp2.to_string_alias;
            t := read_type_short;
            (t = NULL).if {
              syntax_error (current_position,"Type needed.");
            };
            genericity.add_last t;
          };
          //nam.print; '\n'.print;
          genericity := ALIAS_ARRAY ITM_TYPE.alias genericity;
          result     := ITM_TYPE_GENERIC.get nam style styl with genericity;
        } else { 
          (styl = 0).if {
            result := ITM_TYPE_SIMPLE.get nam;
          } else {            
            result := ITM_TYPE_STYLE.get nam style styl;
          };
        }; 
      }; 
    };
    result
  );  // read_prototype

  //++ EXPR         -> { ASSIGN !!AMBIGU!! affect } EXPR_OPERATOR
  //++ ASSIGN       -> '(' IDF_ASSIGN { ',' IDF_ASSIGN } ')'
  //++               | IDF_ASSIGN
  //++ IDF_ASSIGN   -> identifier { identifier }
  - read_expr:ITM_CODE <-
  ( + result,value:ITM_CODE;
    + affect:CHARACTER;
    + again:BOOLEAN;
    + l_assignment:ARRAY STRING_ALIAS;
    + p:INTEGER;
    + name:STRING_ALIAS;

    // !! AMBIGU resolution !!
    save_context;
    (read_character '(').if {
      l_assignment := ALIAS_ARRAY STRING_ALIAS.new;
      {
	again := FALSE;
	(read_identifier).if {
	  p := position - last_string.count;
	  string_tmp2.copy last_string;
	  {read_identifier}.while_do {
	    string_tmp2.append "__";
	    string_tmp2.append last_string;
	  };
	  name := string_tmp2.to_string_alias;
	  l_assignment.add_last name;

	  (is_shorter).if {
	    (! short_local.fast_has name).if {
	      short "slot_call" token p to position;
	    };
	  };

	  (read_character ',').if {
	    again := TRUE;
	  };
	};
      }.do_while {again};
      ((! l_assignment.is_empty) && {read_character ')'} && {read_affect}).if {
	l_assignment := ALIAS_ARRAY STRING_ALIAS.copy l_assignment;
	result := ITM_LIST_IDF.create current_position with l_assignment;
	affect := last_string.first;
	value  := read_expr;
	(value = NULL).if {
	  syntax_error (current_position,"Incorrect expression.");
	};
	(affect)
	.when ':' then {
	  result := ITM_WRITE_VALUE.create (result.position) assign result with value;
	}
	.when '<' then {
	  syntax_error (current_position,"Impossible '<-' style assignment with vector.");
	}
	.when '?' then {
	  syntax_error (current_position,"Sorry, Not yet implemented !");
	  result := ITM_WRITE_CAST.create (result.position) assign result with value;
	};
      } else {
	ALIAS_ARRAY STRING_ALIAS.free l_assignment;
      };
    }.elseif {read_identifier} then {
      p := position - last_string.count;
      string_tmp2.copy last_string;
      {read_identifier}.while_do {
	string_tmp2.append "__";
	string_tmp2.append last_string;
      };
      name := string_tmp2.to_string_alias;

      (is_shorter).if {
	(! short_local.fast_has name).if {
	  short "slot_call" token p to position;
	};
      };

      (read_affect).if {
	result := ITM_READ.create current_position name name;
	affect := last_string.first;
	value  := read_expr;
	(value = NULL).if {
	  syntax_error (current_position,"Incorrect expression.");
	};
	(affect)
	.when ':' then {
	  result := ITM_WRITE_VALUE.create (result.position) assign result with value;
	}
	.when '<' then {
	  result := ITM_WRITE_CODE.create (result.position) assign result with value;
	}
	.when '?' then {
	  result := ITM_WRITE_CAST.create (result.position) assign result with value;
	};
      };
    };
    (result = NULL).if {
      restore_context;
      result := read_expr_operator;
    };
    result
  );

  //++ EXPR_OPERATOR-> { operator } EXPR_MESSAGE { operator {operator} EXPR_MESSAGE } {operator}
  - read_expr_operator:ITM_CODE <-
  ( + result:ITM_CODE;
    + expr :ITM_CODE;
    + l_expr:ARRAY ITM_CODE;
    + itm_op:ITM_OPERATOR;
    + last_msg,first_msg:INTEGER;

    l_expr := ALIAS_ARRAY ITM_CODE.new;
    {read_operator}.while_do {
      expr := ITM_OPERATOR.create current_position name last_string;
      l_expr.add_last expr;
    };
    expr := read_expr_message;
    (expr = NULL).if {
      // Error.
      (! l_expr.is_empty).if {
	syntax_error (current_position,"Incorrect expression.");
      };
      ALIAS_ARRAY ITM_CODE.free l_expr;
    } else {
      // { operator {operator} EXPR_MESSAGE } {operator}
      first_msg := l_expr.count;
      {
	last_msg := l_expr.count;
	l_expr.add_last expr;
	(read_operator).if {
	  {
	    expr := ITM_OPERATOR.create current_position name last_string;
	    l_expr.add_last expr;
	  }.do_while {read_operator};
	  expr := read_expr_message;
	} else {
	  expr := NULL;
	};
      }.do_while {expr != NULL};

      // Last Post-fix operator.
      {last_msg < l_expr.upper}.while_do {
	itm_op ?= l_expr.item (last_msg + 1);
	expr := ITM_READ_ARG1.create (itm_op.position)
	name (operator "__postfix" name (itm_op.name))
	arg (l_expr.item last_msg);
	l_expr.put expr to last_msg;
	l_expr.remove (last_msg + 1);
      };
      ((last_msg - first_msg) < 3).if {
	// First Pre-fix operator.
	{first_msg != 0}.while_do {
	  itm_op ?= l_expr.item (first_msg - 1);
	  expr := ITM_READ_ARG1.create (itm_op.position)
	  name (operator "__prefix" name (itm_op.name))
	  arg (l_expr.item first_msg);
	  l_expr.put expr to first_msg;
	  first_msg := first_msg - 1;
	  l_expr.remove first_msg;
	};
      };
      (l_expr.count = 1).if {
	result := l_expr.first;
	ALIAS_ARRAY ITM_CODE.free l_expr;
      }.elseif {l_expr.count = 3} then {
	// Simple binary message.
	itm_op ?= l_expr.second;
	result := ITM_READ_ARG2.create (itm_op.position)
	name (operator "__infix" name (itm_op.name))
	args (l_expr.first,l_expr.item 2);
	//
	ALIAS_ARRAY ITM_CODE.free l_expr;
      } else {
	// Complex expression.
	l_expr := ALIAS_ARRAY ITM_CODE.copy l_expr;
	result := ITM_EXPRESSION.create l_expr;
      };
    };
    result
  );  // read_expr_operator

  //++ EXPR_MESSAGE -> EXPR_BASE { '.' SEND_MSG }
  - read_expr_message:ITM_CODE <-
  ( + result:ITM_CODE;

    result := read_expr_base;
    (result != NULL).if {
      {read_character '.'}.while_do {
	result := read_send_msg result;
	(result=NULL).if {
	  syntax_error (current_position,"Incorrect message.");
	}; // if
      }; // loop
    }; //if
    result
  );  // read_expr_message

  //++ EXPR_BASE    -> "Old" EXPR
  //++               | '...'
  //++               | EXPR_PRIMARY
  //++               | SEND_MSG
  - read_expr_base:ITM_CODE <-
  ( + result,old_value:ITM_CODE;

    (read_this_keyword "Old").if {
      old_value := read_expr;
      (old_value = NULL).if {
        syntax_error (current_position,"Expression is needed.");
      };
      result := ITM_OLD_EXPR.create current_position value old_value;      
    }.elseif {read_word "..."} then {  
      result := ITM_SUPER.create current_position;  
    } else {
      result := read_expr_primary;
      (result = NULL).if {
	result := read_send_msg NULL;
      };
    };
    result
  );  // read_expr_base

  //++ EXPR_PRIMARY -> "Self"
  //++               | result
  //++               | PROTOTYPE
  //++               | CONSTANT
  //++               | '(' GROUP ')'
  //++               | '{' [ LOC_ARG ';' !! AMBIGU!! ] GROUP '}'
  //++               | external [ ':' ['('] TYPE ['{' TYPE_LIST '}'] [')'] ]
  - read_expr_primary:ITM_CODE <-
  ( + result:ITM_CODE;
    + type :ITM_TYPE;
    + ltype:ITM_TYPE;
    + ext  :ITM_EXTERNAL_TYPE;
    + group_sav:ITM_LIST;
    + arg:ITM_ARGUMENT;
    + result_id:STRING_ALIAS;

    (read_this_keyword "Self").if {
      result := ITM_READ.create current_position name last_string;
    }.elseif {read_this_keyword "Result"} then {
      (last_character = '_').if {
	position := position + 1;
	string_tmp.copy "Result";
	string_tmp.add_last '_';
	{last_character.is_digit}.while_do {
	  string_tmp.add_last last_character;
	  position := position + 1;
	};
	(string_tmp.is_empty).if {
	  syntax_error (current_position,"Incorrect Result number.");
	};
	result_id := string_tmp.to_string_alias;
      } else {
	result_id := "Result";
      };
      result := ITM_READ.create current_position name result_id;
    }.elseif {      
      type := read_prototype;
      type != NULL
    } then {
      result := ITM_PROTOTYPE.create current_position type type;
    }.elseif {(result := read_constant) != NULL} then {
    }.elseif {read_character '(' } then {
      group_sav := last_group;
      last_group := ITM_LIST.create current_position; 
      result := last_group;
      last_group.set_code read_group;
      (read_character ')').if_false {
	warning_error (current_position,"Added ')'.");
      }; // if
      last_group := group_sav;
    }.elseif {read_character '{' } then {
      //               | '{' [ LOC_ARG ';' !! AMBIGU!! ] GROUP '}'
      short "block" token (position-1) to position;
      group_sav := last_group;
      last_group := ITM_LIST.create current_position;

      save_context; // !! SAVE CONTEXT !!

      //
      arg := read_loc_arg TRUE self FALSE;
      //
      (arg != NULL).if {
	(read_character ';').if_false {
	  warning_error (current_position,"Added ';'.");
	}; // if
      } else {

	restore_context; // !! RESTORE CONTEXT !!

      };
      result := ITM_BLOCK.create last_group argument arg;

      last_group.set_code read_group;
      (! read_character '}').if {
	warning_error (current_position,"Added '}'.");
      }; // if
      short "block" token (position-1) to position;
      last_group := group_sav;
    }.elseif {read_external} then {
      (! read_character ':').if {
	result := ITM_EXTERNAL.create current_position text last_string;
      } else {
	ext := ITM_EXTERNAL_TYPE.create current_position text
	last_string persistant (read_character '(');
	type := read_type;
	(type = NULL).if {
	  syntax_error (current_position,"Incorrect type.");
	};
	ext.set_type type;
	(read_character '{').if {
	  ltype := read_type_list;
	  (ltype = NULL).if {
	    syntax_error (current_position,"Incorrect live type list.");
	  };
	  (! read_character '}').if {
	    warning_error (current_position,"Added '}'.");
	  };
	  ext.set_type_list ltype;
	};
	((ext.is_persistant) && {! read_character ')'}).if {
	  warning_error (current_position,"Added ')'.");
	};
	result := ext;
      };
    };
    result
  );  // read_expr_primaire

  //++ CONSTANT     -> integer
  //++               | real
  //++               | characters
  //++               | string
  - read_constant:ITM_CONSTANT <-
  ( + result:ITM_CONSTANT;

    (read_real).if {
      result := ITM_REAL.create current_position value last_real;
    }.elseif {read_integer} then {
      result := ITM_NUMBER.create current_position value last_integer;
    }.elseif {read_characters} then {
      result := ITM_CHARACTER.create current_position char last_string;
    }.elseif {read_string} then {
      result := ITM_STRING.create current_position text last_string;
    };
    result
  );

  //++ GROUP        -> DEF_LOCAL {EXPR ';'} [ EXPR {',' {EXPR ';'} EXPR } ]
  - read_group:ARRAY ITM_CODE <-
  ( + e:ITM_CODE;
    + result:ARRAY ITM_CODE;

    read_def_local;

    result := ALIAS_ARRAY ITM_CODE.new;
    e := read_expr;
    {(e != NULL) && {read_character ';'}}.while_do {
      result.add_last e;
      e := read_expr;
    };
    (e != NULL).if {
      (read_character ',').if {
	{
	  e := ITM_RESULT.create e;
	  result.add_last e;
	  e := read_expr;
	  {(e != NULL) && {read_character ';'}}.while_do {
	    result.add_last e;
	    e := read_expr;
	  };
	  (e = NULL).if {
	    syntax_error (current_position,"Incorrect multiple result expression.");
	  };
        }.do_while {read_character ','};
      };
      e := ITM_RESULT.create e;
      result.add_last e;
    };
    ALIAS_ARRAY ITM_CODE.copy result
  );

  //++ CONTRACT     -> '[' GROUP ']'
  - read_contract:ITM_LIST <-
  ( + result:ITM_LIST;
    (read_character '[').if {
      result := last_group := ITM_LIST.create current_position;
      last_group.set_code read_group;
      (! read_character ']').if {
	warning_error (current_position,"Added ']'.");
      };
    };
    result
  );

  //++ DEF_LOCAL    -> { style LOCAL ';' } !! AMBIGU !!
  - read_def_local <-
  ( + loc_lst:ARRAY ITM_LOCAL;
    + local_list,static_list:ARRAY ITM_LOCAL;
    + styl:CHARACTER;

    save_context; // !! SAVE CONTEXT !!

    styl    := read_style;
    local_list  := ALIAS_ARRAY ITM_LOCAL.new;
    static_list := ALIAS_ARRAY ITM_LOCAL.new;
    {styl != ' '}.while_do {
      loc_lst := read_local;
      (loc_lst != NULL).if {
	(styl = '+').if {
	  local_list.append_collection loc_lst;
	} else {
	  static_list.append_collection loc_lst;
	};
	(read_character ';').if_false {
	  warning_error (current_position,"Added ';'.");
	};

	save_context; // !! SAVE CONTEXT !!

	styl := read_style;
      } else {

	restore_context; // !! RESTORE CONTEXT !!

	styl := ' ';
      };
    };
    (local_list.is_empty).if {
      ALIAS_ARRAY ITM_LOCAL.free local_list;
    } else {
      last_group.set_local_list  (ALIAS_ARRAY ITM_LOCAL.copy local_list);
    };
    (static_list.is_empty).if {
      ALIAS_ARRAY ITM_LOCAL.free static_list;
    } else {
      last_group.set_static_list (ALIAS_ARRAY ITM_LOCAL.copy static_list);
    };
  );

  //++ SEND_MSG     -> identifier [ ARGUMENT { identifier ARGUMENT } ]
  - read_send_msg first_arg:ITM_CODE :ITM_CODE <-
  ( + result:ITM_CODE;
    + name :STRING_ALIAS;
    + n:STRING_BUFFER;
    + l_arg:ARRAY ITM_CODE;
    + arg:ITM_CODE;
    + p1,p2,old_derive,sav_derive:INTEGER;

    read_identifier.if {
      //
      // Classic Message.
      //
      p1 := position - last_string.count;
      p2 := position;
      old_derive := short_derive;

      n := new_string_buffer;
      n.copy last_string;
      // Argument list.
      l_arg := ALIAS_ARRAY ITM_CODE.new;
      arg := read_argument;
      (arg != NULL).if {
	l_arg.add_last arg;
	{read_identifier}.while_do {

	  short "slot_call" token
	  (position-last_string.count) to position;

	  n.append "__";
	  n.append last_string;
	  arg := read_argument;
	  (arg = NULL).if {
	    syntax_error (current_position,"Incorrect argument.");
	  }; // if
	  l_arg.add_last arg;
	}; // loop
      }; // if
      name := free_string_buffer n;

      (is_shorter).if {
	(
	  (! l_arg.is_empty) ||
	  {first_arg != NULL} ||
	  {! short_local.fast_has last_string}
	).if {
	  sav_derive := short_derive;
	  short_derive := old_derive;
	  short "slot_call" token p1 to p2;
	  short_derive := sav_derive + (short_derive-old_derive);
	};
      };

      l_arg.is_empty.if {
	(first_arg=NULL).if {
	  // Local ou Implicite Slot without argument.
	  result := ITM_READ.create current_position name name;
	} else {
	  result := ITM_READ_ARG1.create current_position name name arg first_arg;
	};
	ALIAS_ARRAY ITM_CODE.free l_arg;
      }.elseif {l_arg.count=1} then {
	result := ITM_READ_ARG2.create current_position name
	name args (first_arg,(l_arg.first));
	ALIAS_ARRAY ITM_CODE.free l_arg;
      } else {
	l_arg.add_first first_arg;
	l_arg := ALIAS_ARRAY ITM_CODE.copy l_arg;
	result := ITM_READ_ARGS.create current_position name name args l_arg;
      };
    }; // if
    result
  );  // read_send_msg

  //++ ARGUMENT     -> EXPR_PRIMARY
  //++               | identifier
  - read_argument:ITM_CODE <-
  ( + result:ITM_CODE;
    result := read_expr_primary;
    ((result = NULL) && {read_identifier}).if {
      (is_shorter).if {
	(short_local.fast_has last_string).if_false {
	  short "slot_call" token (position-last_string.count) to position;
	};
      };
      result := ITM_READ.create current_position name last_string;
    };
    result
  );  // read_argument

  // name, export, import, type, default, external, version, lip,
  // date, comment, author, bibliography, language, bug_report,
  // copyright.
  - read_slot_header first:BOOLEAN :BOOLEAN <-
  ( + result:BOOLEAN;
    + v:ITM_CODE;
    + cast:ITM_TYPE;
    + style:CHARACTER;
    + is_export:BOOLEAN;
    + instr:LIP_CODE;
    + name:STRING_ALIAS;

    style := read_style;
    (style != ' ').if {
      result := TRUE;
      ((! first) && {style = '+'}).if {
	warning_error (current_position,"Incorrect style slot ('-').");
      };
      (first).if {
	(read_word "name").if {
	  //
	  // Read `name' slot.
	  //
          
          // style "name" ':=' [type] cap_identifier [ PARAM { cap_identifier PARAM } ]
          // PARAM -> cap_idf
          //        | '(' cap_idf { ',' cap_idf } ')'
	  short "slot" token
	  (position-last_string.count) to position;

	  object.set_position current_position;
          object.set_style style;
	  (read_symbol ":=").if_false {
	    warning_error (current_position,"Added ':='.");
	  };

	  (
	    (read_this_keyword "Expanded") ||
	    {read_this_keyword "Strict"}
	  ).if {
	    object.set_type_style last_string;
	  };

	  (! read_cap_identifier).if {
	    syntax_error (current_position,"Prototype identifier is needed.");
	  };
	  short "prototype" token (position-last_string.count) to position;	  
          name := last_string;
          // Generic loader.
          (read_name_param).if {
            {read_cap_identifier}.while_do {
              string_tmp.copy name;
              string_tmp.append "__";
              string_tmp.append last_string;
              name := string_tmp.to_string_alias;
              (! read_name_param).if {
                syntax_error (current_position,"Incorrect genericity definition.");
              };
            };
          };
          (object.shortname != name).if {
            warning_error (current_position,"Incorrect name (filename != name).");            
          };
	} else {
	  syntax_error (current_position,"Slot `name' must to be first slot.");
	};
      }.elseif {
	(is_export := read_word "export") || {read_word "import"}
      } then {
	// - ("export"|"import") ':=' TYPE_LIST
	short "slot" token (position-last_string.count) to position;

	(read_symbol ":=").if_false {
	  warning_error (current_position,"Added ':='.");
	};
	cast := read_type_list;
	(cast = NULL).if {
	  syntax_error (current_position,"Incorrect type list.");
	};
	(is_export).if {
	  object.set_export_list cast;
	} else {
	  object.set_import_list cast;
	};
      }.elseif {read_word "external"} then {
	//
	// Read `external' slot.
	//

	// - "external" ':=' `<code_c>`
	short "slot" token (position-last_string.count) to position;

	(read_symbol ":=").if_false {
	  warning_error (current_position,"Added ':='.");
	};
	(read_external).if_false {
	  syntax_error (current_position,"Incorrect external.");
	};
	output_decl.append "/* ";
	output_decl.append (object.name);
	output_decl.append " */\n";
	output_decl.append last_string;
	output_decl.add_last '\n';
      }.elseif {read_word "default"} then {
	//
	// Read `default' slot.
	//

	// '-' "default" ':=' EXPR_PRIMARY
	short "slot" token (position-last_string.count) to position;

	(read_symbol ":=").if_false {
	  warning_error (current_position,"Added ':='.");
	};
	v := read_expr_primary;
	(v = NULL).if {
	  syntax_error (current_position,"Incorrect expr.");
	};
	(object.default_value != NULL).if {
	  semantic_error (current_position,"Double `default' slot definition.");
	};
	object.set_default_value v;
      }.elseif {read_word "type"} then {
	//
	// Read `type' slot.
	//

	// '-' "type" ':=' `<type C>`
	short "slot" token (position-last_string.count) to position;

	(read_symbol ":=").if_false {
	  warning_error (current_position,"Added ':='.");
	};
	(read_external).if_false {
	  syntax_error (current_position,"Incorrect external.");
	};
	(object.type_c != NULL).if {
	  semantic_error (current_position,"Double `type' slot definition.");
	};
	object.set_c_type last_string;
      }.elseif {read_word "version"} then {
	//
	// Read `version' slot.
	//

	// '-' "version" ':=' integer
	short "slot" token (position-last_string.count) to position;

	(read_symbol ":=").if_false {
	  warning_error (current_position,"Added ':='.");
	};
	(read_integer).if_false {
	  syntax_error (current_position,"Incorrect number.");
        };

      }.elseif {read_word "lip"} then {
	//
	// LIP interpreter.
	//

        // '-' lip <- ( { LIP_EXPR ';' } )
        (read_symbol "<-").if_false {
          warning_error (current_position,"Added '<-' is needed.");
        };
        (read_character '(').if_false {
          warning_error (current_position,"Added '(' is needed.");
        };
        {(instr := readlip_expr) != NULL}.while_do {
          ((! is_shorter) && {! is_shorter2}).if {
            instr.run;
          };
          (read_character ';').if_false {
            warning_error (current_position,"Added ';' is needed.");
          };
        };
        (read_character ')').if_false {
          warning_error (current_position,"Added ')' is needed.");
        };
      }.elseif {
	(read_word "date") || {read_word "comment"} ||
	{read_word "author"} ||	{read_word "bibliography"} ||
	{read_word "language"} || {read_word "copyright"} ||
	{read_word "bug_report"}
      } then {
	//
	// Read `date', `comment', `author', `bibliography',
	// `language', `copyright' or `bug_report' slots.
	//

	// '-' ("date"|"comment"|"author"|"bibliography"|"language"|"copyright"|"bug_report")
        // ':=' string
	short "slot" token (position-last_string.count) to position;

	(read_symbol ":=").if_false {
	  warning_error (current_position,"Added ':='.");
	};
	(read_string).if_false {
	  syntax_error (current_position,"Incorrect string.");
        };
        (is_shorter2).if {
          object.set_comment_slot last_string;
        };
      } else {
	warning_error (current_position,"Incorrect slot.");
      };
      (read_character ';').if_false {
	warning_error (current_position,"Added ';'.");
      };
    };
    result
  );
  
  // PARAM -> cap_identifier | '(' cap_identifier { ',' cap_identifier } ')'
  - read_name_param:BOOLEAN <-
  ( + result:BOOLEAN;
    + typ:ITM_TYPE_PARAMETER;
    (read_character '(').if {
      ((! read_cap_identifier) || {! is_parameter_type}).if {
        syntax_error (current_position,"Generic type needed.");
      };        
      typ ?= ITM_TYPE_PARAMETER.get last_string;
      object.idf_generic_list.add_last typ;
      {read_character ','}.while_do {        
        ((! read_cap_identifier) || {! is_parameter_type}).if {
          syntax_error (current_position,"Generic type needed.");
        };
        typ ?= ITM_TYPE_PARAMETER.get last_string;
        object.idf_generic_list.add_last typ;        
      };
      (! read_character ')').if {
        warning_error (current_position,"',' added.");
      };
      result := TRUE;
    }.elseif {(read_cap_identifier) && {is_parameter_type}} then {
      typ ?= ITM_TYPE_PARAMETER.get last_string;
      object.idf_generic_list.add_last typ;
      result := TRUE;
    };
    result
  );
  
  //
  // Parser for LIP file.
  //

  - readlip_program <-
  //// PROGRAM      -> { 'Section' ('Inherit' | 'Public' | 'Private') { SLOT ';' } }
  ( + idx:INTEGER;
    + section:STRING_ALIAS;

    idx := LIP_CODE.list_parent.lower;
    {read_this_keyword "Section"}.while_do {
      (read_this_keyword "Inherit").if {
        // { '+' string ':' STRING [ ':=' string ] ';' }
        {read_character '+'}.while_do {
          (read_identifier).if_false {
            warning_error (current_position,"Identifier needed.");
          };
          (read_character ':').if_false {
            warning_error (current_position,"Added ':' is needed.");
          };
          (read_word "STRING").if_false {
            warning_error (current_position,"`STRING' type needed.");
          };
          (read_symbol ":=").if {
            (read_string).if_false {
              syntax_error (current_position,"String needed.");
            };
            string_tmp.copy (object.filename);
            {
              (!string_tmp.is_empty)    &&
              {string_tmp.last != '/'}  &&
              {string_tmp.last != '\\'}
            }.while_do {
              string_tmp.remove_last 1;
            };
            string_tmp.append last_string;
          } else {
            string_tmp.clear;
          };
          LIP_CODE.list_parent.add (string_tmp.to_string_alias) to idx;
          idx := idx + 1;
          (read_character ';').if_false {
            warning_error (current_position,"Added ';' is needed.");
          };
        };
      }.elseif {
        (read_this_keyword "Public")  ||
        {read_this_keyword "Private"}
      } then {
        section := last_string;
        {readlip_slot section}.while_do {
          (read_character ';').if_false {
            warning_error (current_position,"Added ';' is needed.");
          };
        };
      } else {
        syntax_error (current_position,"`Public' or `Private' or `Inherit' needed.");
      };
    };
  );

  - readlip_slot sec:STRING_ALIAS :BOOLEAN <-
  //// SLOT         -> '+' identifier ':' TYPE [ ':=' EXPR_CONSTANT ]
  ////               | '-' identifier [ identifier ':' TYPE ] '<-' EXPR
  ( + result:BOOLEAN;
    + t:LIP_CONSTANT;
    + n,na:STRING_ALIAS;
    + data:LIP_SLOT_DATA;
    + slot_code:LIP_SLOT_CODE;
    + exp:LIP_CODE;
    + pos:POSITION;
    + cst:LIP_CONSTANT;
    
    (sec = "Public").if {
      is_shorter2 := TRUE;
      read_space;
      is_shorter2 := FALSE;
      (last_comment_extern != NULL).if {      
        string_tmp.copy last_comment_extern;
        {(!string_tmp.is_empty) && {(string_tmp.first = ' ') || {string_tmp.first = '\n'}}}.while_do { string_tmp.remove_first 1; };
        {(!string_tmp.is_empty) && {(string_tmp.last  = ' ') || {string_tmp.last  = '\n'}}}.while_do { string_tmp.remove_last 1;  };
        (last_comment_extern.is_empty).if {
          last_comment_extern := NULL;
        } else {
          last_comment_extern := string_tmp.to_string_alias;
        };                
      } else {
        last_comment_extern := NULL;
      };
    };

    (read_character '+').if {
      // Data.
      result := TRUE;
      (sec = "Public").if {
        syntax_error (current_position,"No data in Public section.");
      };
      (read_identifier).if_false {
        syntax_error (current_position,"Identifier is incorrect.");
      };
      n := last_string;
      (read_character ':').if_false {
        warning_error (current_position,"Added ':' is needed.");
      };
      t := readlip_type;
      (t = NULL).if {
        syntax_error (current_position,"type is incorrect.");
      };
      (! read_symbol ":=").if {
        data := LIP_SLOT_DATA.create current_position name n value t argument FALSE;
      } else {
        cst := readlip_expr_constant;
        (cst = NULL).if {
          syntax_error (current_position,"Incorrect expression.");
        };
        (cst.name !== t.name).if {
          syntax_error (current_position,"Incorrect expression type.");
        };
        data := LIP_SLOT_DATA.create current_position name n value cst argument FALSE;
        //data.set_value cst;
        //cst.free;
      };
    }.elseif {read_character '-'} then {
      // Function.
      result := TRUE;
      (read_identifier).if_false {
        syntax_error (current_position,"Identifier is incorrect.");
      };
            
      pos := current_position;
      n := last_string;
      (read_identifier).if {
        na := last_string;
        (read_character ':').if_false {
          warning_error (current_position,"Added ':' is needed.");
        };
        t := readlip_type;
        (t = NULL).if {
          syntax_error (current_position,"Incorrect type.");
        };
        data := LIP_SLOT_DATA.create current_position name na value t argument TRUE;
      };
      //
      (read_symbol "<-").if_false {
        warning_error (current_position,"Added '<-' is needed.");
      };
      is_shorter2 := TRUE;
      read_space;
      is_shorter2 := FALSE;
      exp := readlip_expr;
      (exp = NULL).if {
        syntax_error (current_position,"Expression needed.");
      };
      slot_code := LIP_SLOT_CODE.create pos section sec
      name n argument data code exp;
      (sec = "Public").if {
        (last_comment_slot = NULL).if {
          warning_error (pos,"Comment needed.");
        } else {
          slot_code.set_comment last_comment_slot;
          slot_code.set_comment_chapter last_comment_extern;
        };
      };
    };
    result
  );

  - readlip_type:LIP_CONSTANT <-
  //// TYPE         -> 'BOOLEAN' | 'STRING' | 'INTEGER' | 'LIP'
  ( + result:LIP_CONSTANT;

    (read_cap_identifier).if {
      (last_string = "INTEGER").if {
        result := LIP_INTEGER.get 0;
      }.elseif {last_string = "STRING"} then {
        result := LIP_STRING.get "";
      }.elseif {last_string = "BOOLEAN"} then {
        result := LIP_BOOLEAN.get FALSE;
      }.elseif {last_string = "LIP"} then {
        not_yet_implemented;
      } else {
        last_string.to_pointer.print; ' '.print;
        "STRING".to_pointer.print; ' '.print;
        
        
        string_tmp.copy "`"; 
        string_tmp.append last_string;
        string_tmp.append "': Incorrect type.";
        syntax_error (current_position,string_tmp);
      };
    };
    result
  );

  - readlip_expr_affect:LIP_CODE <-
  //// EXPR_AFFECT  -> [ identifier !!AMBIGU!! ':=' ] EXPR
  ( + result,val:LIP_CODE;
    + nam:STRING_ALIAS;

    save_context; // !! SAVE CONTEXT !!

    (read_identifier).if {
      nam := last_string;
      (read_symbol ":=").if {
        val := readlip_expr;
        (val = NULL).if {
          syntax_error (current_position,"Incorrect expression.");
        };
        result := LIP_AFFECT.create current_position name nam value val;
      } else {
        restore_context; // !! RESTORE CONTEXT !!
      };
    };
    (result = NULL).if {
      result := readlip_expr;
    };
    result
  );

  - readlip_expr:LIP_CODE <-
  //// EXPR         -> EXPR_CMP { ('|' | '&') EXPR_CMP }
  ( + result,right:LIP_CODE;
    + is_or:BOOLEAN;

    result := readlip_expr_cmp;
    (result != NULL).if {
      {(is_or := read_character '|') || {read_character '&'}}.while_do {
        right := readlip_expr_cmp;
        (right = NULL).if {
          syntax_error (current_position,"Incorrect expression.");
        };
        (is_or).if {
          result := LIP_BINARY.create current_position with result operator '|' and right;
        } else {
          result := LIP_BINARY.create current_position with result operator '&' and right;
        };
      };
    };
    result
  );

  - readlip_expr_cmp:LIP_CODE <-
  //// EXPR_CMP     -> EXPR_BINARY { ('='|'!='|'>'|'<'|'>='|'<=') EXPR_BINARY }
  ( + result,right:LIP_CODE;
    + op:STRING_ALIAS;
    + type:CHARACTER;

    result := readlip_expr_binary;
    (result != NULL).if {
      {
        (read_symbol ">=") || {read_symbol "<="} || {read_symbol "!="} ||
        {read_symbol "=" } || {read_symbol ">" } || {read_symbol "<" }
      }.while_do {
        op := last_string;
        right := readlip_expr_binary;
        (right = NULL).if {
          syntax_error (current_position,"Incorrect expression.");
        };
        (op)
        .when ">=" then { type := 'S'; }
        .when "<=" then { type := 'I'; }
        .when "!=" then { type := 'E'; }
        .when "="  then { type := '='; }
        .when ">"  then { type := '>'; }
        .when "<"  then { type := '<'; };
        result := LIP_BINARY.create current_position with result operator type and right;
      };
    };
    result
  );

  - readlip_expr_binary:LIP_CODE <-
  //// EXPR_BINARY  -> EXPR_UNARY { ('-'|'+') EXPR_UNARY }
  ( + result,right:LIP_CODE;
    + is_sub:BOOLEAN;

    result := readlip_expr_unary;
    (result != NULL).if {
      {(is_sub := read_character '-') || {read_character '+'}}.while_do {
        right := readlip_expr_unary;
        (right = NULL).if {
          syntax_error (current_position,"Incorrect expression.");
        };
        (is_sub).if {
          result := LIP_BINARY.create current_position with result operator '-' and right;
        } else {
          result := LIP_BINARY.create current_position with result operator '+' and right;
        };
      };
    };
    result
  );

  - readlip_expr_unary:LIP_CODE <-
  //// EXPR_UNARY   -> ( '-' | '!' ) EXPR_UNARY
  ////               | EXPR_BASE
  ( + result:LIP_CODE;
    + is_neg:BOOLEAN;
    + type:CHARACTER;

    ((is_neg := read_character '-') || {read_character '!'}).if {
      result := readlip_expr_unary;
      (result = NULL).if {
        syntax_error (current_position,"Incorrect expression.");
      };
      (is_neg).if {
        type := '-';
      } else {
        type := '!';
      };
      result := LIP_UNARY.create current_position operator type with result;
    } else {
      result := readlip_expr_base;
    };
    result
  );

  - readlip_expr_list cod:ARRAY LIP_CODE <-
  //// EXPR_LIST    -> { EXPR_AFFECT ';' } [ EXPR_AFFECT ]
  ( + instr:LIP_CODE;
    {
      ((instr := readlip_expr_affect) != NULL) &&
      {read_character ';'}
    }.while_do {
      cod.add_last instr;
    };
    cod.add_last instr;
  );

  - readlip_expr_base:LIP_CODE <-
  //// EXPR_BASE    -> EXPR_RECEIVER { '.' EXPR_MESSAGE }
  ( + result:LIP_CODE;

    result := readlip_expr_receiver;
    {read_character '.'}.while_do {
      result := readlip_expr_message result;
      (result = NULL).if {
        syntax_error (current_position,"Incorrect message.");
      };
    };
    result
  );

  - readlip_expr_receiver:LIP_CODE <-
  //// EXPR_RECEIVER-> EXPR_PRIMARY
  ////               | EXPR_MESSAGE
  ( + result:LIP_CODE;
    result := readlip_expr_primary;
    (result = NULL).if {
      result := readlip_expr_message NULL;
    };
    result
  );

  - readlip_expr_message rec:LIP_CODE :LIP_CODE <-
  //// EXPR_MESSAGE -> identifier [ EXPR_ARGUMENT ]
  ////               | 'if' '{' EXPR_LIST '}' [ 'else' '{' EXPR_LIST '}' ]
  ( + result,arg:LIP_CODE;
    + nam:STRING_ALIAS;
    + the,els:ARRAY LIP_CODE;

    (read_word "if").if {
      the := ALIAS_ARRAY LIP_CODE.new;
      (read_character '{').if_false {
        warning_error (current_position,"Added '(' is needed.");
      };
      readlip_expr_list the;
      (read_character '}').if_false {
        warning_error (current_position,"Added '(' is needed.");
      };
      the := ALIAS_ARRAY LIP_CODE.copy the;
      (read_word "else").if {
        els := ALIAS_ARRAY LIP_CODE.new;
        (read_character '{').if_false {
          warning_error (current_position,"Added '(' is needed.");
        };
        readlip_expr_list els;
        (read_character '}').if_false {
          warning_error (current_position,"Added '(' is needed.");
        };
        els := ALIAS_ARRAY LIP_CODE.copy els;
      };
      result := LIP_IF.create current_position if rec then the else els;
    }.elseif {read_identifier} then {
      nam := last_string;
      arg := readlip_expr_argument;
      result := LIP_CALL.create current_position
      receiver rec name nam with arg;
    };
    result
  );

  - readlip_expr_argument:LIP_CODE <-
  //// EXPR_ARGUMENT-> identifier
  ////               | EXPR_PRIMARY
  ( + result:LIP_CODE;

    (read_identifier).if {
      result := LIP_CALL.create current_position
      receiver NULL name last_string with NULL;
    } else {
      result := readlip_expr_primary;
    };
    result
  );

  - readlip_expr_primary:LIP_CODE <-
  //// EXPR_PRIMARY -> EXPR_CONSTANT
  ////               | '(' EXPR_LIST ')'
  ( + result:LIP_CODE;
    + val:LIP_CONSTANT;
    + lst:ARRAY LIP_CODE;

    val := readlip_expr_constant;
    (val != NULL).if {
      result := LIP_VALUE.create current_position with val;
    }.elseif {read_character '('} then {
      lst := ALIAS_ARRAY LIP_CODE.new;
      readlip_expr_list lst;
      (read_character ')').if_false {
        warning_error (current_position,"Added ')'.");
      };
      lst := ALIAS_ARRAY LIP_CODE.copy lst;
      result := LIP_LIST.create current_position with lst;
    };
    result
  );

  - readlip_expr_constant:LIP_CONSTANT <-
  //// EXPR_CONSTANT-> integer
  ////               | string
  ////               | TRUE
  ////               | FALSE
  ( + result:LIP_CONSTANT;

    (read_integer).if {
      result := LIP_INTEGER.get last_integer;
    }.elseif {read_string} then {
      result := LIP_STRING.get last_string;
    }.elseif {read_cap_identifier} then {
      (last_string = "TRUE").if {
        result := LIP_BOOLEAN.get TRUE;
      }.elseif {last_string = "FALSE"} then {
        result := LIP_BOOLEAN.get FALSE;
      } else {
        syntax_error (current_position,"Type incorrect.");
      };
    };
    result
  );

  //
  // Parser for FORMAT.LI
  //

  //|| FORMAT -> { '-' identifier ':=' SHORT_DEF ';' }
  - read_format <-
  ( + def:LINKED_LIST(STRING_ALIAS);

    {read_character '-'}.while_do {
      (read_identifier).if_false {
	syntax_error (current_position,"Incorrect slot identifier.");
      };
      def := LINKED_LIST(STRING_ALIAS).create;
      (short_dico.fast_has last_string).if {
	syntax_error (current_position,"Double definition slot.");
      };
      short_dico.fast_put def to last_string;
      (read_symbol ":=").if_false {
	syntax_error (current_position,"Assignment ':=' is needed.");
      };
      (read_short_def def).if_false {
	syntax_error (current_position,"Incorrect definition.");
      };
      (read_character ';').if_false {
	warning_error (current_position,"Added ';' is needed.");
      };
    };

    // End of file :
    read_space;
    (last_character != 0.to_character).if {
      syntax_error (current_position,"Incorrect symbol.");
    };
  );

  //|| SHORT_DEF -> { SHORT_ELT '+' } SHORT_ELT
  - read_short_def def:LINKED_LIST(STRING_ALIAS) :BOOLEAN <-
  ( + result:BOOLEAN;

    read_short_elt.if {
      result := TRUE;
      def.add_last last_string;
      {read_character '+'}.while_do {
	(read_short_elt).if_false {
	  syntax_error (current_position,"Incorrect format expression.");
	};
	def.add_last last_string;
      };
    };
    result
  );

  //|| SHORT_ELT -> "token" | string
  - read_short_elt:BOOLEAN <-
  ( + result:BOOLEAN;
    + j:INTEGER;

    read_identifier.if {
      (last_string != "token").if {
	warning_error (current_position,"Variable not `token'.");
      };
      last_string := NULL;
      result := TRUE;
    }.elseif {read_string} then {
      string_tmp.clear;
      j := last_string.lower;
      {j <= last_string.upper}.while_do {
	(last_string.item j = '\\').if {
	  j := j+1;
	  last_string.item j
	  .when 'a'  then { string_tmp.add_last '\a'; }
	  .when 'b'  then { string_tmp.add_last '\b'; }
	  .when 'f'  then { string_tmp.add_last '\f'; }
	  .when 'n'  then { string_tmp.add_last '\n'; }
	  .when 'r'  then { string_tmp.add_last '\r'; }
	  .when 't'  then { string_tmp.add_last '\t'; }
	  .when 'v'  then { string_tmp.add_last '\v'; }
	  .when '\\' then { string_tmp.add_last '\\'; }
	  .when '?'  then { string_tmp.add_last '\?'; }
	  .when '\'' then { string_tmp.add_last '\''; }
	  .when '\"' then { string_tmp.add_last '\"'; };
	} else {
	  string_tmp.add_last (last_string.item j);
	};
	j := j+1;
      };
      last_string := string_tmp.to_string_alias;
      result := TRUE;
    };
    result
  );

Section Public

  //
  // Parser Entry.
  //

  //- counter_line:INTEGER;

  - go_on obj:PROTOTYPE <-
  (
    ? { object=NULL};

    // Source information.
    object   := obj;
    source   := obj.source.to_external;
    source_upper := obj.source.upper;

    //counter_line := counter_line + source.occurrences '\n';

    position := source_lower;
    pos_cur  := source_lower;
    pos_line := 1;
    pos_col  := 0;

    (is_shorter).if {
      is_active_short := TRUE;
      short_derive := 0;
      output_code.copy (object.source);
      short_local := HASHED_SET(STRING_ALIAS).create;
      short "begin" token 1 to 1;
    };

    // Parse.
    (! read_program).if {
      syntax_error (current_position,"Incorrect symbol.");
    };

    short "end" token (source_upper) to (source_upper);

    object := NULL; // Parser is Free (see require test...)
  );

  - read_lip path_lip:STRING_ALIAS :BOOLEAN <-
  ( + entry:POINTER;
    
    entry := FS_MIN.open_read path_lip;
    (entry != NULL).if {      
      FS_MIN.close entry;
      object := PROTOTYPE.create path_lip
      name path_lip generic_count 0;

      source  := object.source.to_external;
      source_upper := object.source.upper;
      position := source_lower;
      pos_cur := source_lower;
      pos_line:=1;
      pos_col :=0;
      is_shorter := is_shorter2 := FALSE;
      
      // Parse.
      readlip_program;
      //
      is_shorter  := Old is_shorter;
      is_shorter2 := Old is_shorter2;
      object := NULL; // Parser is Free (see require test...)
    }
  );

  - parse_format fmt_name:STRING_ALIAS <-
  (
    // Source information.
    (FILE_SYSTEM.get_entry fmt_name = NULL).if {
      STD_ERROR.put_string "Error: File format `";
      STD_ERROR.put_string fmt_name;
      STD_ERROR.put_string "' is not open !\n";
      die_with_code exit_failure_code;
    };

    object := PROTOTYPE.create fmt_name
    name "__SHORT_LISAAC_FORMAT__" generic_count 0;

    source       := object.source.storage;
    source_upper := object.source.upper;
    position := source_lower;
    pos_cur  := source_lower;
    pos_line := 1;
    pos_col  := 0;

    // Parse.
    read_format;

    object := NULL; // Parser is Free (see require test...)
  );


