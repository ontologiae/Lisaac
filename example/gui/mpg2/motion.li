////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             MPEG2 Decode Video                             //
//                                                                            //
//                     LORIA - UHP - INRIA - ST - FRANCE                      //
//               (c) INRIA (see `licence.txt' for more details)               //
//                     Benoit SONNTAG - bsonntag@loria.fr                     //
//                           http://www.IsaacOS.com                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := MOTION;
  
  - bibliography := "http://IsaacOS.com";
  - author       := "Sonntag Benoit (bsonntag@loria.fr)";
  - comment      := "motion vector decoding.";
  
Section Inherit
  
  - parent_any_mpg2:ANY_MPG2 := ANY_MPG2;
  
Section Public
  
  - motion_vectors (pmv:PMV,dmvector:VECTOR,
  motion_vertical_field_select:FAST_ARRAY2(BOOLEAN),
  s,motion_vector_count:INTEGER,mv_format:BOOLEAN,h_r_size,v_r_size:INTEGER,dmv,mvscale:BOOLEAN) <-
  // ISO/IEC 13818-2 sections 6.2.5.2, 6.3.17.2, and 7.6.3: Motion vectors   
  //  
  // int motion_vertical_field_select[2][2];  
  ( + bits:BOOLEAN;
    
    (motion_vector_count = 1).if {
      ((mv_format = mv_field) && {! dmv}).if {	
	bits := ld.get_boolean;
	motion_vertical_field_select.put bits to (1,s); 
	motion_vertical_field_select.put bits to (0,s);
      };

      motion_vector (pmv,0,s,dmvector,h_r_size,v_r_size,dmv,mvscale,FALSE);

      // update other motion vector predictors 
      pmv.put (pmv.item (0,s,0)) to (1,s,0);
      pmv.put (pmv.item (0,s,1)) to (1,s,1);      
    } else {
      bits := ld.get_boolean;
      motion_vertical_field_select.put bits to (0,s);

      motion_vector (pmv,0,s,dmvector,h_r_size,v_r_size,dmv,mvscale,FALSE);
      
      bits := ld.get_boolean;
      motion_vertical_field_select.put bits to (1,s);
      
      motion_vector (pmv,1,s,dmvector,h_r_size,v_r_size,dmv,mvscale,FALSE);
    };
  );

  - motion_vector (pmv:PMV,pmv1,pmv2:INTEGER,dmvector:VECTOR,
  h_r_size,v_r_size:INTEGER,dmv,mvscale,full_pel_vector:BOOLEAN) <-
  // get and decode motion vector and differential motion vector for one prediction
  //
  // int dmv;              MPEG-2 only: get differential motion vectors 
  // int mvscale;          MPEG-2 only: field vector in frame pic 
  // int full_pel_vector;  MPEG-1 only 
  ( + motion_code, motion_residual, new:INTEGER;
    
    // horizontal component 
    // ISO/IEC 13818-2 Table B-10 
    motion_code := GETVLC.get_motion_code;        
    ((h_r_size != 0) && {motion_code != 0}).if {
      motion_residual := ld.get_bits h_r_size;
    };
    new := decode_motion_vector ((pmv.item (pmv1,pmv2,0)),h_r_size,motion_code,motion_residual,full_pel_vector);
    pmv.put new to (pmv1,pmv2,0);
    (dmv).if {
      dmvector.put_first (GETVLC.get_dmvector);
    };

    // vertical component
    motion_code     := GETVLC.get_motion_code;
    ((v_r_size != 0) && {motion_code != 0}).if {
      motion_residual := ld.get_bits v_r_size;
    } else {
      motion_residual := 0;
    };
    (mvscale).if {      
      pmv.put (pmv.item (pmv1,pmv2,1) >> 1) to (pmv1,pmv2,1);
    };
    new := decode_motion_vector ((pmv.item (pmv1,pmv2,1)),v_r_size,motion_code,motion_residual,full_pel_vector);
    pmv.put new to (pmv1,pmv2,1);
    (mvscale).if {
      pmv.put (pmv.item (pmv1,pmv2,1) << 1) to (pmv1,pmv2,1);
    };
    (dmv).if {
      dmvector.put_second (GETVLC.get_dmvector);
    };
  );
  
Section Private
  
  - decode_motion_vector (pred,r_size,motion_code,motion_residual:INTEGER,full_pel_vector:BOOLEAN) :INTEGER <-
  // calculate motion vector component 
  // ISO/IEC 13818-2 section 7.6.3.1: Decoding the motion vectors 
  // Note: the arithmetic here is more elegant than that which is shown 
  // in 7.6.3.1.  The end results (PMV[][][]) should, however, be the same.
  //
  // int *pred;              BSBS: Return new `pred'.
  // int full_pel_vector;    MPEG-1 (ISO/IEC 11172-1) support
  ( + lim, vec, result:INTEGER;

    lim := 16 << r_size;
    (full_pel_vector).if {
      vec := pred >> 1;
    } else {
      vec := pred;
    };

    (motion_code > 0).if {
      vec := vec + ((motion_code - 1) << r_size) + motion_residual + 1;
      (vec >= lim).if {
	vec := vec - (lim + lim);
      };
    } else {
      (motion_code < 0).if {
	vec := vec - (((-motion_code-1) << r_size) + motion_residual + 1);
	(vec < -lim).if {
	  vec := vec + lim + lim;
	};
      };
    };
    
    (full_pel_vector).if {
      result := vec << 1;
    } else {
      result := vec;
    };
    result
  );
  
Section Public

  - dual_prime_arithmetic (dmv:FAST_ARRAY2(INTEGER),dmvector:VECTOR,mvx,mvy:INTEGER) <-
  // ISO/IEC 13818-2 section 7.6.3.6: Dual prime additional arithmetic 
  //
  // int DMV[][2];
  // int *dmvector;    differential motion vector
  // int mvx, mvy;     decoded mv components (always in field format) 
  ( + dmv00,dmv01,dmv10,dmv11:INTEGER;
    + incx,incy:INTEGER;
    + tmpx1,tmpy1,tmpx3,tmpy3:INTEGER;
    
    incx := (mvx > 0).to_integer;
    incy := (mvy > 0).to_integer;
    tmpx1 := ((mvx  + incx) >> 1) + dmvector.first;
    tmpy1 := ((mvy  + incy) >> 1) + dmvector.second;
    (picture_structure = frame_picture).if {
      tmpx3 := ((3*mvx + incx) >> 1) + dmvector.first;
      tmpy3 := ((3*mvy + incy) >> 1) + dmvector.second;
      (top_field_first).if {
	/// vector for prediction of top field from bottom field 
	dmv00 := tmpx1;
	dmv01 := tmpy1 - 1;	
	// vector for prediction of bottom field from top field 
	dmv10 := tmpx3;
	dmv11 := tmpy3 + 1;
      } else {
	// vector for prediction of top field from bottom field 
	dmv00 := tmpx3; 
	dmv01 := tmpy3 - 1;
	// vector for prediction of bottom field from top field 
	dmv10 := tmpx1;
	dmv11 := tmpy1 + 1;
      };      
      dmv.put dmv10 to (1,0);
      dmv.put dmv11 to (1,1);
    } else {
      // vector for prediction from field of opposite 'parity' 
      dmv00 := tmpx1;            
      // correct for vertical field shift 
      (picture_structure = top_field).if {
	dmv01 := tmpy1 - 1;
      } else {
	dmv01 := tmpy1 + 1;
      };
    };
    dmv.put dmv00 to (0,0);
    dmv.put dmv01 to (0,1);
  );
