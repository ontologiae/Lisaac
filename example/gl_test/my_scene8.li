Section Header
  
  + name     := MY_SCENE8;
  
  - comment   := "first program";
  
Section Inherit
  
  + parent_scene:Expanded SCENE;
    
  - parent_test_any:TEST_ANY := TEST_ANY;
  
Section Public  
  
  - main <-
  (
    CAPABILITIES.use_stencil_buffer;
    
    start_test Self using CAPABILITIES;
  );
  
Section Public
  
  //
  //  test model
  //
  
  + model:MODEL;
  + texture:TEXTURE;
  + material:MATERIAL;
  
  + floor:TEXTURE;

  + floor_plane:PLANE;
  + light:LIGHT;
  
  + camera:CAMERA;
  
  - initialize:BOOLEAN <-
  (   
    + ambient,diffuse,specular:COLOR;
    
    camera := CAMERA.create;
    
    camera.position.make (0,10,-200);
    camera.view.make (0,-10,200);
    camera.view.normalize;
    
    // load textures
    texture := renderer.texture2d.create_from (IMAGE.create "data/skin.tga");
    floor := renderer.texture2d.create_from (IMAGE.create "data/floor.tga");
    
    // load model
    model := MD2_MODEL.create "data/model.md2" with texture;
    
    ambient := RGB.create (0.9, 0.9, 0.9); 
    diffuse := RGB.create (1.0, 1.0, 1.0);
    specular := RGB.create (1.0, 1.0, 1.0);
    
    // create a light
    light := renderer.light.create (ambient,diffuse,specular) at (VECTOR3(REAL_32).create (0,10,-200));
    light.set_directional;
    light.enable;  
    
    ambient := RGB.create (0.8, 0.8, 1); 
    diffuse := RGB.create (0, 0, 1);
    
    material := renderer.material.create (ambient,diffuse,specular,RGB.create(0,0,0),50);    
    model.set_material material;
     
    floor_plane := renderer.plane.create_plane (0,0,-1,0);
    
    // clear stencil to false
    renderer.stencil_buffer.set_clear_value 0.0;
    TRUE
  );
  
  - render t:REAL_32 <-
  (       
    model.update (t*10);
    
    renderer.font.enable;
    out.print "MD2 test" at (50,100);
    renderer.font.disable;
    
    camera.look;
    
    //
    // First pass: draw an invisible mask of the floor in the stencil buffer
    //
    
    // disable drawing in color buffer
    renderer.color_buffer.disable;
    
    renderer.stencil_buffer.enable;
    
    // stencil test always pass and set stencil value to 1 
    renderer.stencil_buffer.set_function (renderer.stencil_buffer.always) value 1 mask 1;
    
    // if test successful replace stencil value else keep the old value
    renderer.stencil_buffer.when_pass (renderer.stencil_buffer.replace) when_fail (renderer.stencil_buffer.keep) when_zfail (renderer.stencil_buffer.keep);
    
    renderer.depth_buffer.disable;
    
    draw_floor;
    
    // back to color mode
    renderer.depth_buffer.enable;
    renderer.color_buffer.enable;
    
    //
    // Second pass: draw reflections in the masked floor (stencil test enabled)
    //
    
    // only draw pixels masked with 1 in stencil buffer
    renderer.stencil_buffer.set_function (renderer.stencil_buffer.equal) value 1 mask 1;
    renderer.stencil_buffer.lock; // read-only
    
    renderer.blending.set_alpha_value 0.7;
    renderer.blending.apply (renderer.blending.src_alpha,renderer.blending.one_minus_src_alpha); 
 
    renderer.blending.enable;
    renderer.depth_buffer.disable;
    
    // clip upper part of reflected object
    floor_plane.clip;
    
    renderer.transform.new_matrix {
      
      // mirror y axis
      renderer.transform.scalef (1.0, -1.0, 1.0);
      renderer.transform.translatef (0.0, 130, 0.0);
      
      // quake2 z axis is opengl y axis
      renderer.transform.rotatef(-90, 1,0,0);
      renderer.transform.rotatef(90, 0,0,1);
      
      model.render;
    };
    
    // back to normal mode
    floor_plane.unclip;
    renderer.stencil_buffer.disable;
    renderer.depth_buffer.enable;
    //
    // Third pass: draw scene normally
    //

    draw_floor;
    
    // quake2 z axis is opengl y axis
    renderer.transform.rotatef(-90, 1,0,0);
    renderer.transform.rotatef(90, 0,0,1);
    
    renderer.blending.disable;
    
    model.render;
    
    renderer.vb.draw;
  );
  
  - draw_floor <-
  (        
    floor.bind;
    
    renderer.transform.new_matrix {
      
      renderer.transform.translatef (0.0, -80.0, 0);
      
      renderer.vb.new_quads {
        renderer.vb.add_normal3f (0.0, 1.0, 0.0);
        
        renderer.vb.add_texel2f (0.0, 1.0);
        renderer.vb.add_vertex3f (-200.0, 0.0, 200.0);
        
        renderer.vb.add_texel2f (0.0, 0.0);
        renderer.vb.add_vertex3f (-200.0, 0.0, -200.0);
        
        renderer.vb.add_texel2f (1.0, 0.0);
        renderer.vb.add_vertex3f (200.0, 0.0, -200.0);
        
        renderer.vb.add_texel2f (1.0, 1.0);
        renderer.vb.add_vertex3f (200.0, 0.0, 200.0);
      };
    };
  );
