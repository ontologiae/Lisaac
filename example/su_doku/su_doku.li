///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name := SU_DOKU;
  
  - comment := "Du_doku Solver.";
  
Section Inherit
  
  - parent_object:OBJECT := OBJECT;
  
Section Private
  
  //
  // Data.
  //
  
  - array  :FAST_ARRAY2(INTEGER) := FAST_ARRAY2(INTEGER).create (9,9);
      
  //
  // Example.
  //
  
  - load_example <-
  (
    array.set_all_with 0;
    array.put 9 to (1,0); array.put 7 to (2,0); array.put 8 to (3,0); 
    array.put 1 to (5,0); array.put 5 to (6,0);
    array.put 4 to (1,1);
    array.put 1 to (2,2); array.put 2 to (4,2); array.put 9 to (8,2);
    array.put 4 to (6,3); array.put 8 to (7,3);
    array.put 4 to (0,4); array.put 9 to (3,4); array.put 6 to (5,4); array.put 1 to (8,4);
    array.put 5 to (1,5); array.put 2 to (2,5);
    array.put 7 to (0,6); array.put 6 to (4,6); array.put 3 to (6,6);
    array.put 6 to (7,7);
    array.put 5 to (2,8); array.put 2 to (3,8); array.put 3 to (5,8); 
    array.put 8 to (6,8); array.put 1 to (7,8);
  );
  
  //
  // Display.
  //
  
  - display <-
  ( + v:INTEGER;
    
    
    0.to 8 do { y:INTEGER;
      ((y % 3) = 0).if {
        "#####################################\n".print;
      } else {
        "#---+---+---#---+---+---#---+---+---#\n".print;
      };
      0.to 8 do { x:INTEGER;
      ((x % 3) = 0).if {
        "# ".print;
      } else {
        "| ".print;
      };
      v := array.item (x,y);
      (v = 0).if { 
        ' '.print;
      } else {
        v.print;
      };
      ' '.print;
      };
      "#\n".print;
    };
    "#####################################\n".print;
  );
  
  //
  // Solver.
  //

  - is_good value:INTEGER to (x,y:INTEGER) :BOOLEAN <-
  ( + j,k,bx,by:INTEGER;
    + result:BOOLEAN;
    result := TRUE;
    // Horizontal/Vertical test.
    {(j<9) && {result}}.while_do {
      result := (array.item (x,j) != value) && {array.item (j,y) != value};
      j := j + 1;
    };
    (result).if {
      // Block test.
      by := y / 3 * 3;      
      bx := x / 3 * 3;
      j := 0;
      {(j < 3) && {result}}.while_do {
        k := 0;
        {(k < 3) && {result}}.while_do {
          result := array.item (bx+k,by+j) != value;
          k := k + 1;
        };
        j := j + 1;
      };      
    };
    result
  );
  
  - solver (x,y:INTEGER) :BOOLEAN <-
  ( + px,py:INTEGER;
    + v:INTEGER;
    + is_found:BOOLEAN;
    
    px := x; 
    py := y;
    {(py<9) && {array.item (px,py) != 0}}.while_do {
      px := px + 1;
      (px > 8).if {
        px := 0;
        py := py + 1;
      };
    };
    (py = 9).if {
      is_found := TRUE;
    } else {
      v := 1;  
      {
        (is_good v to (px,py)).if { 
          // I love English Girls (2005)
          array.put v to (px,py);
          is_found := solver (px,py);
          (is_found).if_false {
            array.put 0 to (px,py);
          };
        };
        v := v + 1;
      }.do_while {(v < 10) && {! is_found}};
    };
    is_found
  );
  
  - graph_table:FAST_ARRAY2(G_IN);
  
  - array_to_graph <-
  ( + val:INTEGER;
    + in:G_IN;
    0.to 8 do { x:INTEGER;
      0.to 8 do { y:INTEGER;
        val := array.item (x,y);
        in  := graph_table.item (x,y);
        in.text.clear;
        (val != 0).if {
          val.append_in (in.text);
        };
        in.refresh;
      };
    };
  );
  
  - graph_to_array <-
  ( + val:INTEGER;
    + in:G_IN;
    0.to 8 do { x:INTEGER;
      0.to 8 do { y:INTEGER;        
        in  := graph_table.item (x,y);
        (in.text.is_empty).if {
          val := 0;
        } else {
          val := in.text.to_integer;
        };
        array.put val to (x,y);
      };
    };
  );
  
  - message:G_OUT;
  
Section Public
  
  - run:G_WIN_OUT <- 
  ( + c1,l1,c2,l2,r:G_EXPR;
    + g:G_IN;
    
    graph_table := FAST_ARRAY2(G_IN).create (9,9); 
    0.to 2 do { xx:INTEGER;
      c2 := NULL;
      0.to 2 do { yy:INTEGER;
        l1 := NULL;
        0.to 2 do { x:INTEGER;
          c1 := NULL;
          0.to 2 do { y:INTEGER;
            g := G_IN.create (2,1) justify (G_IN.center) action { in:G_IN;
              in.text.remove_last 1;
              ((in.text.count > 1) || {! in.text.first.in_range '1' to '9'}).if {
                in.text.clear;
                message.text.copy " Error: Between 1 and 9";                
              } else {
                message.text.copy " Ok.";                
              };
              message.refresh;
            };
            graph_table.put g to (xx*3+x,yy*3+y);
            r := G_RAW.create g;
            (c1 = NULL).if {
              c1 := r;
            } else {
              c1 := c1 / r;
            };
          };
          (l1 = NULL).if {
            l1 := c1;
          } else {
            l1 := l1 | c1;
          };
        };                
        r := G_RAW.create l1;
        (c2 = NULL).if {
          c2 := r;
        } else {
          c2 := c2 / r;
        };
      };
      (l2 = NULL).if {
        l2 := c2;
      } else {
        l2 := l2 | c2;
      };
    };
    G_WIN_OUT.create "Sudoku Solver" with (
      (
        G_BUTTON.create (G_OUT.create "Clear" justify (G_OUT.center)) 
        action { b:G_BUTTON; 
          + in:G_IN;
          0.to 8 do { x:INTEGER;
            0.to 8 do { y:INTEGER;
              in := graph_table.item (x,y);
              in.text.clear;
              in.refresh;
            };
          };
        } |
        G_BUTTON.create (G_OUT.create "Load"  justify (G_OUT.center)) 
        action { b:G_BUTTON;
          load_example;
          array_to_graph;
        } |
        G_BUTTON.create (G_OUT.create "Solve" justify (G_OUT.center))
        action { b:G_BUTTON;
          graph_to_array;
          solver (0,0).if {
            message.text.copy " Found !";
          } else {
            message.text.copy " Not found !";
          };
          message.refresh;
          array_to_graph;
        }
      ).fix_height / 
      l2 / 
      (G_RAW.create (message := G_OUT.create " ")).fix_height
    )
  );
      
  - main <-
  ( + choice:CHARACTER;
        
    "====================================================\n\
    \Welcome the SU DOKU solver (V.1.0 by Sonntag Benoit)\n\
    \====================================================\n\n".print;
    
    {
      "[a]:Load example. [b]:Display. [c]:New. [d]:Solve! [e]:Exit\n\
      \Choice ?\n".print;
      {
        choice := IO.read_character;
      }.do_until {choice.in_range 'a' to 'e'};
      IO.read_character;
      
      choice
      .when 'a' then {
        load_example;
        "Load example: Ok\n".print;
      }
      .when 'b' then {
        display;
      }
      .when 'c' then {
        0.to 8 do { y:INTEGER;
          0.to 8 do { x:INTEGER;
            "Line #".print;
            (y+1).print;
            " Column #".print;
            (x+1).print;
            " ?\n".print;
            {
              choice := IO.read_character;
            }.do_until {(choice.in_range '1' to '9') || {choice = '\n'}};
            (choice = '\n').if {
              array.put 0 to (x,y);
            } else {
              array.put (choice.decimal_value) to (x,y);
              IO.read_character;
            };
          };
        };
      }
      .when 'd' then {
        "Solver result: ".print;
        solver (0,0).if {
          "Found !\n".print;
        } else {
          "Not found!\n".print;
        };
      };
    }.do_while {choice != 'e'};
    "Good bye!\n".print;
  );
