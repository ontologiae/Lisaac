// C code generated by Lisaac compiler (www.isaacOS.com) //
int arg_count;
char **arg_vector;

//==========================//
// EXTERNAL                 //
//==========================//

// INSTALL_LISAAC
#include <unistd.h>
// MEMORY

#define MINIMUM_SIZE 256  
void *table_size[MINIMUM_SIZE/sizeof(void *)];
void *last_block[64];

// SYSTEM_IO

#include <stdio.h>
#include <stdlib.h>
  
// Hardware 'print_char'
void print_char(char car)
{
  fputc(car,stdout);
}

// Hardware 'exit'
int die_with_code(int code)
{
  exit(code);
}


// SYSTEM
#include <time.h>

//==========================//
// TYPE                     //
//==========================//

// Generic Object
struct ___OBJ {
  unsigned long __id;
};

// NULL
#ifndef NULL
#define NULL ((void *)0)
#endif

// INTEGER
typedef int __INTEGER;

// CHARACTER
typedef char __CHARACTER;

// STRING
#define __STRING__ 4
typedef struct STRING_struct __STRING;
struct STRING_struct {
  unsigned long __id;
  __INTEGER count__CB;
  __INTEGER capacity__GFD;
  __CHARACTER *storage__DGD;
};
__STRING STRING_={__STRING__};
#define STRING__ (&STRING_)

// STRING_CONSTANT
#define __STRING_CONSTANT__ 5
typedef struct STRING_CONSTANT_struct __STRING_CONSTANT;
struct STRING_CONSTANT_struct {
  unsigned long __id;
  __INTEGER count__AD;
  __CHARACTER *storage__K3B;
};
__STRING_CONSTANT STRING_CONSTANT_={__STRING_CONSTANT__};
#define STRING_CONSTANT__ (&STRING_CONSTANT_)

// POINTER
typedef void * __POINTER;

// UINTEGER_32
typedef unsigned long __UINTEGER_32;

// MEMORY
#define __MEMORY__ 0
typedef struct MEMORY_struct __MEMORY;
struct MEMORY_struct {
  volatile __UINTEGER_32 previous_linear__4W;
  volatile __UINTEGER_32 size_and_id__5W;
  __MEMORY *next_free__AX;
  __MEMORY *previous_free__BX;
} __attribute__ ((packed));
__MEMORY MEMORY_;
#define MEMORY__ (&MEMORY_)

// NUMERIC
#define __NUMERIC__ 1
typedef struct NUMERIC_struct __NUMERIC;
struct NUMERIC_struct {
  void *Nothing;
};
__NUMERIC NUMERIC_;
#define NUMERIC__ (&NUMERIC_)

// OBJECT
#define __OBJECT__ 2
typedef struct OBJECT_struct __OBJECT;
struct OBJECT_struct {
  void *Nothing;
};
__OBJECT OBJECT_;
#define OBJECT__ (&OBJECT_)

// INSTALL_LISAAC
#define __INSTALL_LISAAC__ 3
typedef struct INSTALL_LISAAC_struct __INSTALL_LISAAC;
struct INSTALL_LISAAC_struct {
  void *Nothing;
};
__INSTALL_LISAAC INSTALL_LISAAC_;
#define INSTALL_LISAAC__ (&INSTALL_LISAAC_)

// TRUE
#define TRUE__ 1

// FALSE
#define FALSE__ 0

// BOOLEAN
typedef char __BOOLEAN;

// INTEGER_8
typedef signed char __INTEGER_8;


void *table_type[4];

//==========================//
// GLOBAL                   //
//==========================//

void *parent_numeric__G;
__POINTER begin_memory__SDC;
__UINTEGER_32 nb_page__DUC;
__UINTEGER_32 capacity_max__GGF;
__MEMORY *first_free__YQI;
__UINTEGER_32 clone_allocation_size__UW;
void *string_tmp__2;
void *path_current__GB;
void *path_home__KB;
void *shell__MB;
__INTEGER step_count__0C;
void *system__FE;

//==========================//
// STRING CONSTANT          //
//==========================//

__STRING_CONSTANT __string_1={__STRING_CONSTANT__,106,"\t\t=================\
===============\n\t\t= Auto-Install Lisaac Compiler =\n\t\t=================\
===============\n\n"};
__STRING_CONSTANT __string_2={__STRING_CONSTANT__,4,"HOME"};
__STRING_CONSTANT __string_3={__STRING_CONSTANT__,5,"SHELL"};
__STRING_CONSTANT __string_4={__STRING_CONSTANT__,17,"Detection system."};
__STRING_CONSTANT __string_5={__STRING_CONSTANT__,48,"  Error : SHELL enviro\
nment variable is empty !\n"};
__STRING_CONSTANT __string_6={__STRING_CONSTANT__,7,"Unknown"};
__STRING_CONSTANT __string_7={__STRING_CONSTANT__,4,"bash"};
__STRING_CONSTANT __string_8={__STRING_CONSTANT__,8,"/.bashrc"};
__STRING_CONSTANT __string_9={__STRING_CONSTANT__,11,"Unix - bash"};
__STRING_CONSTANT __string_10={__STRING_CONSTANT__,29,"\n# **** LISAAC COMPI\
LER ****\n"};
__STRING_CONSTANT __string_11={__STRING_CONSTANT__,12,"export PATH="};
__STRING_CONSTANT __string_12={__STRING_CONSTANT__,12,"/bin:$PATH\n\n"};
__STRING_CONSTANT __string_13={__STRING_CONSTANT__,4,"tcsh"};
__STRING_CONSTANT __string_14={__STRING_CONSTANT__,7,"/.cshrc"};
__STRING_CONSTANT __string_15={__STRING_CONSTANT__,11,"Unix - tcsh"};
__STRING_CONSTANT __string_16={__STRING_CONSTANT__,10,"set path=("};
__STRING_CONSTANT __string_17={__STRING_CONSTANT__,13,"/bin $path)\n\n"};
__STRING_CONSTANT __string_18={__STRING_CONSTANT__,3,"zsh"};
__STRING_CONSTANT __string_19={__STRING_CONSTANT__,8,"/.zshenv"};
__STRING_CONSTANT __string_20={__STRING_CONSTANT__,10,"Unix - zsh"};
__STRING_CONSTANT __string_21={__STRING_CONSTANT__,24,"  Shell not recognize\
d: "};
__STRING_CONSTANT __string_22={__STRING_CONSTANT__,12,"C:\\msdos.sys"};
__STRING_CONSTANT __string_23={__STRING_CONSTANT__,15,"C:\\autoexec.bat"};
__STRING_CONSTANT __string_24={__STRING_CONSTANT__,13,"Windows - DOS"};
__STRING_CONSTANT __string_25={__STRING_CONSTANT__,33,"\r\nREM **** LISAAC C\
OMPILER ****\r\n"};
__STRING_CONSTANT __string_26={__STRING_CONSTANT__,9,"set path="};
__STRING_CONSTANT __string_27={__STRING_CONSTANT__,15,"\\bin;%path%\r\n\r\n"};
__STRING_CONSTANT __string_28={__STRING_CONSTANT__,17,"  System detect: "};
__STRING_CONSTANT __string_29={__STRING_CONSTANT__,7,"path.li"};
__STRING_CONSTANT __string_30={__STRING_CONSTANT__,10,"  + target"};
__STRING_CONSTANT __string_31={__STRING_CONSTANT__,23,"  + target := WINDOWS\
;\n"};
__STRING_CONSTANT __string_32={__STRING_CONSTANT__,34,"\n  Note: Use `mingw'\
 for Windows.\n"};
__STRING_CONSTANT __string_33={__STRING_CONSTANT__,20,"  + target := UNIX;\n"};
__STRING_CONSTANT __string_34={__STRING_CONSTANT__,49,"\n  Search path for `\
libX11.a' : (please wait...)\n"};
__STRING_CONSTANT __string_35={__STRING_CONSTANT__,55,"find /usr -name \"lib\
X11.a\" 2> /dev/null > xlib_path.txt"};
__STRING_CONSTANT __string_36={__STRING_CONSTANT__,13,"xlib_path.txt"};
__STRING_CONSTANT __string_37={__STRING_CONSTANT__,33," Error : `libX11.a' n\
ot found !\n\n"};
__STRING_CONSTANT __string_38={__STRING_CONSTANT__,21,"  + path_lib_x11 := \""};
__STRING_CONSTANT __string_39={__STRING_CONSTANT__,3,"\";\n"};
__STRING_CONSTANT __string_40={__STRING_CONSTANT__,16,"  + path_lib_x11"};
__STRING_CONSTANT __string_41={__STRING_CONSTANT__,19,"rm -f xlib_path.txt"};
__STRING_CONSTANT __string_42={__STRING_CONSTANT__,38,"Installation of envir\
onment variables."};
__STRING_CONSTANT __string_43={__STRING_CONSTANT__,98,"  Auto-install fail !\
\n  You have to change your environment variables as following: \n    set pa\
th="};
__STRING_CONSTANT __string_44={__STRING_CONSTANT__,13,"\\bin;%path%\n\n"};
__STRING_CONSTANT __string_45={__STRING_CONSTANT__,36,"Installation of Lisaa\
c library path."};
__STRING_CONSTANT __string_46={__STRING_CONSTANT__,26,"#define LISAAC_DIRECT\
ORY \""};
__STRING_CONSTANT __string_47={__STRING_CONSTANT__,2,"\"\n"};
__STRING_CONSTANT __string_48={__STRING_CONSTANT__,10,"bin/path.h"};
__STRING_CONSTANT __string_49={__STRING_CONSTANT__,24,"#define LISAAC_DIRECT\
ORY"};
__STRING_CONSTANT __string_50={__STRING_CONSTANT__,10,"src/path.h"};
__STRING_CONSTANT __string_51={__STRING_CONSTANT__,40,"Installation of `lisa\
ac-mode' for Emacs."};
__STRING_CONSTANT __string_52={__STRING_CONSTANT__,67,"  Do you want to inst\
all the `lisaac-mode' for Emacs editor ? (y/n)"};
__STRING_CONSTANT __string_53={__STRING_CONSTANT__,47,"  Not install `lisaac\
-mode' for Emacs editor.\n\n"};
__STRING_CONSTANT __string_54={__STRING_CONSTANT__,2,"C:"};
__STRING_CONSTANT __string_55={__STRING_CONSTANT__,7,"/.emacs"};
__STRING_CONSTANT __string_56={__STRING_CONSTANT__,24,";; **** LISAAC MODE *\
***"};
__STRING_CONSTANT __string_57={__STRING_CONSTANT__,24,"\n(setq load-path (co\
ns \""};
__STRING_CONSTANT __string_58={__STRING_CONSTANT__,28,"/editor/emacs/\" load\
-path))\n"};
__STRING_CONSTANT __string_59={__STRING_CONSTANT__,133,"(add-to-list 'auto-m\
ode-alist '(\"\\\\.li\\\\'\" . lisaac-mode))\n(autoload 'lisaac-mode \"lisaa\
c-mode\" \"Major mode for Lisaac Programs\" t)\n\n"};
__STRING_CONSTANT __string_60={__STRING_CONSTANT__,41,"Installation of `lisa\
ac_v2.xml' for Kate."};
__STRING_CONSTANT __string_61={__STRING_CONSTANT__,39,"  Sorry, not Kate edi\
tor for windows.\n\n"};
__STRING_CONSTANT __string_62={__STRING_CONSTANT__,68,"  Do you want to inst\
all the `lisaac_v2.xml' for Kate editor ? (y/n)"};
__STRING_CONSTANT __string_63={__STRING_CONSTANT__,48,"  Not install `lisaac\
_v2.xml' for Kate editor.\n\n"};
__STRING_CONSTANT __string_64={__STRING_CONSTANT__,42,"mkdir -p ~/.kde/share\
/apps/katepart/syntax"};
__STRING_CONSTANT __string_65={__STRING_CONSTANT__,67,"cp -f editor/kate/lis\
aac_v2.xml ~/.kde/share/apps/katepart/syntax/."};
__STRING_CONSTANT __string_66={__STRING_CONSTANT__,3,"  `"};
__STRING_CONSTANT __string_67={__STRING_CONSTANT__,2,"'\t"};
__STRING_CONSTANT __string_68={__STRING_CONSTANT__,79,"\n  Sorry, auto-insta\
ll fail !\n  You can to read the `editor/kate/README' file.\n"};
__STRING_CONSTANT __string_69={__STRING_CONSTANT__,4,"OK.\n"};
__STRING_CONSTANT __string_70={__STRING_CONSTANT__,37,"Installation of `lisa\
ac.vim' for Vim."};
__STRING_CONSTANT __string_71={__STRING_CONSTANT__,38,"  Sorry, not Vim edit\
or for windows.\n\n"};
__STRING_CONSTANT __string_72={__STRING_CONSTANT__,66,"  Do you want to inst\
all the Lisaac support for Vim editor ? (y/n)"};
__STRING_CONSTANT __string_73={__STRING_CONSTANT__,44,"  Not install `lisaac\
.vim' for Vim editor.\n\n"};
__STRING_CONSTANT __string_74={__STRING_CONSTANT__,22,"mkdir -p ~/.vim/syntax"};
__STRING_CONSTANT __string_75={__STRING_CONSTANT__,22,"mkdir -p ~/.vim/indent"};
__STRING_CONSTANT __string_76={__STRING_CONSTANT__,22,"mkdir -p ~/.vim/backup"};
__STRING_CONSTANT __string_77={__STRING_CONSTANT__,20,"mkdir -p ~/.vim/temp"};
__STRING_CONSTANT __string_78={__STRING_CONSTANT__,49,"cp -f editor/vim/synt\
ax/lisaac.vim ~/.vim/syntax/"};
__STRING_CONSTANT __string_79={__STRING_CONSTANT__,90,"\n  Sorry, auto-insta\
ll fail !\n  You can read the `editor/vim/install_vim_plugin.sh' file.\n"};
__STRING_CONSTANT __string_80={__STRING_CONSTANT__,49,"cp -f editor/vim/inde\
nt/lisaac.vim ~/.vim/indent/"};
__STRING_CONSTANT __string_81={__STRING_CONSTANT__,302,"\n  It is recommande\
d to install the default vimrc file provided by the   \n  lisaac installer. \
                                                    \n\n  If you choose not \
doing this action, your vimrc will only be updated    \n  Do you want to ins\
tall the default config provided by lisaac installer? (y/n)"};
__STRING_CONSTANT __string_82={__STRING_CONSTANT__,7,"/.vimrc"};
__STRING_CONSTANT __string_83={__STRING_CONSTANT__,155,"\nsyntax on         \
                  \nfiletype plugin on                    \nfiletype indent \
on                    \nau BufNewFile,BufRead *.li setf lisaac\n"};
__STRING_CONSTANT __string_84={__STRING_CONSTANT__,31,"cp -f editor/vim/vimr\
c ~/.vimrc"};
__STRING_CONSTANT __string_85={__STRING_CONSTANT__,31,"Compilation of Lisaac\
 compiler."};
__STRING_CONSTANT __string_86={__STRING_CONSTANT__,6,"lisaac"};
__STRING_CONSTANT __string_87={__STRING_CONSTANT__,28,"Compilation of Shorte\
r tool."};
__STRING_CONSTANT __string_88={__STRING_CONSTANT__,7,"shorter"};
__STRING_CONSTANT __string_89={__STRING_CONSTANT__,31,"Build a librarie docu\
mentation."};
__STRING_CONSTANT __string_90={__STRING_CONSTANT__,60,"  Do you want to buil\
d a HTML librarie documentation ? (y/n)"};
__STRING_CONSTANT __string_91={__STRING_CONSTANT__,39,"  Not install librari\
e documentation.\n\n"};
__STRING_CONSTANT __string_92={__STRING_CONSTANT__,38,"bin\\shorter -r -f ht\
ml lib -o lib_html"};
__STRING_CONSTANT __string_93={__STRING_CONSTANT__,38,"bin/shorter -r -f htm\
l lib -o lib_html"};
__STRING_CONSTANT __string_94={__STRING_CONSTANT__,12,"  Execute: `"};
__STRING_CONSTANT __string_95={__STRING_CONSTANT__,2,"'\n"};
__STRING_CONSTANT __string_96={__STRING_CONSTANT__,60,"  OK, you found this \
documentation in `lib_html/index.html'\n"};
__STRING_CONSTANT __string_97={__STRING_CONSTANT__,29,"Welcome to the Lisaac\
 World !"};
__STRING_CONSTANT __string_98={__STRING_CONSTANT__,314,"  Installation succe\
ssfull.                               \n  Run `lisaac' to compile.          \
                    \n\n  Note: You'll have to reboot or reloaded environnem\
ent   \n        to acknowledge the changes.                       \n  Note: \
For bash users, doing a `source ~/.bashrc' should \n        do the job.\n"};
__STRING_CONSTANT __string_99={__STRING_CONSTANT__,5,"Step "};
__STRING_CONSTANT __string_100={__STRING_CONSTANT__,3," : "};
__STRING_CONSTANT __string_101={__STRING_CONSTANT__,1,"="};
__STRING_CONSTANT __string_102={__STRING_CONSTANT__,5,"  A `"};
__STRING_CONSTANT __string_103={__STRING_CONSTANT__,50,"' file has no need t\
o change. Current version is:\n"};
__STRING_CONSTANT __string_104={__STRING_CONSTANT__,39,"' file has been upda\
ted. Old value is:\n"};
__STRING_CONSTANT __string_105={__STRING_CONSTANT__,16,"  New value is:\n"};
__STRING_CONSTANT __string_106={__STRING_CONSTANT__,30,"' file has been upda\
ted with:\n"};
__STRING_CONSTANT __string_107={__STRING_CONSTANT__,30,"' file has been crea\
ted with:\n"};
__STRING_CONSTANT __string_108={__STRING_CONSTANT__,7,"Error: "};
__STRING_CONSTANT __string_109={__STRING_CONSTANT__,16,"Not create file!"};
__STRING_CONSTANT __string_110={__STRING_CONSTANT__,34,"Not open file (Write\
 protection) !"};
__STRING_CONSTANT __string_111={__STRING_CONSTANT__,12,"gcc -O2 bin/"};
__STRING_CONSTANT __string_112={__STRING_CONSTANT__,10,".c -o bin/"};
__STRING_CONSTANT __string_113={__STRING_CONSTANT__,19,"  Execute command `"};
__STRING_CONSTANT __string_114={__STRING_CONSTANT__,20,"' (please wait ...)\n"};
__STRING_CONSTANT __string_115={__STRING_CONSTANT__,51,"  Auto-install fail \
!\n  You want to compile a `bin/"};
__STRING_CONSTANT __string_116={__STRING_CONSTANT__,10,".c' file.\n"};
__STRING_CONSTANT __string_117={__STRING_CONSTANT__,19,"Not enough memory.\n"};

//==========================//
// FUNCTION HEADER          //
//==========================//

// Debug Manager
void print_string(char *str);
// Source code
static __STRING* create__ZB(__INTEGER needed_capacity__1B);
static void print__PB(__STRING_CONSTANT *Self__QB);
static __CHARACTER* to_external__AFD(__STRING *Self__BFD);
static void from_external__TGD(__STRING *Self__UGD,__CHARACTER *p__VGD);
static void copy__JID(__STRING *Self__KID,void *other__LID);
static void* get_environment_variable__AC(void *variable__CC);
static void title__XC(void *str__ZC);
static __STRING* create_from_string__R1(void *str__T1);
static __INTEGER first_substring_index__ORD(__STRING *Self__PRD,void *other__QRD);
static void append__XLD(__STRING *Self__YLD,void *other__ZLD);
static void put_string__WU(void *s__YU);
static void update__idf__with__C2(void *file__E2,void *id__F2,void *new_text__G2);
static __INTEGER execute_command__PAB(void *system_command_line__RAB);
static void prepend__PKD(__STRING *Self__QKD,void *other__RKD);
static void replace_all__with__VPD(__STRING *Self__WPD);
static void compile_file__LS(void *n__NS);
static __STRING* clone__1V();
static __CHARACTER* create__LMH(__INTEGER nb_elements__NMH);
static void add_last__GJF(__STRING *Self__HJF,__CHARACTER ch__IJF);
static void copy_from__until__ZKF(__CHARACTER *Self__0KF,__CHARACTER *model__1KF,__INTEGER upper__2KF);
static void print__CZ(__INTEGER Self__DZ);
static __CHARACTER* realloc__with__INH(__CHARACTER *Self__JNH,__INTEGER old_nb_elts__KNH,__INTEGER new_nb_elts__LNH);
static void copy__to__until__JVJ(__CHARACTER *Self__KVJ,__CHARACTER *src__LVJ,__INTEGER dest__MVJ,__INTEGER src_capacity__NVJ);
static __INTEGER fast_occurrences__until__HHC(__CHARACTER *Self__IHC,__INTEGER upper__KHC);
static void remove__0SF(__STRING *Self__1SF,__INTEGER index__2SF);
static void resize__FHE(__STRING *Self__GHE,__INTEGER new_count__HHE);
static void move__to__by__BQF(__CHARACTER *Self__CQF,__INTEGER lower__DQF,__INTEGER upper__EQF,__INTEGER offset__FQF);
static __POINTER micro_alloc__table__lab__VBC(__UINTEGER_32 new_size__XBC,__POINTER ptr_table__YBC,__UINTEGER_32 lab_type__ZBC);
static __POINTER alloc_dynamic__31H(__UINTEGER_32 sz__51H);
static void print_positif__VEL(__INTEGER Self__WEL);
static void copy__to__size__SII(__POINTER src__UII,__POINTER dst__VII,__UINTEGER_32 sz__WII);
static void to_busy__index__N4J(__MEMORY *Self__O4J,__UINTEGER_32 sz__P4J,__UINTEGER_32 idx__Q4J);
static __MEMORY* search__VPI(__UINTEGER_32 new_size__XPI);
static void add_link_free__ARJ(__MEMORY *Self__BRJ);
static void delete_link_free__QNK(__MEMORY *Self__RNK);
static void clear__to__A2J(__CHARACTER *Self__B2J,__INTEGER lower__C2J,__INTEGER upper__D2J);
static __POINTER new_lab__RTC(__UINTEGER_32 t__TTC);
static __MEMORY* new_page__2FF();

//==========================//
// SOURCE CODE              //
//==========================//

int main(int argc,char **argv)
{
  __POINTER std_file__MD;
  void *new_text__OD,*file__PD,*file_name__YJ,*new_text__ZJ;
  void *file_name__3N;
  void *comment__QD,*path__RD,*path_next__SD;
  __INTEGER result__MEQ;
  __STRING *Self__QWD;
  __CHARACTER *cwd__Y,*ptr__ZVQ;
  __BOOLEAN __tmp__HE,__tmp__5E,result__BNB,__tmp__WF,result__ONB;
  __CHARACTER char__XJ,char__3L,char__2N,char__4S;
  arg_count  = argc;
  arg_vector = argv;
  parent_numeric__G=NUMERIC__;
  STRING_CONSTANT__->count__AD=((__INTEGER )((0)));
  STRING__->count__CB= 0;
  STRING_CONSTANT__->storage__K3B=((__CHARACTER *)(NULL));
  STRING__->storage__DGD=NULL;
  clone_allocation_size__UW= 0;
  nb_page__DUC= 0;
  MEMORY__->size_and_id__5W= 0;
  capacity_max__GGF= 0;
  begin_memory__SDC=((__POINTER )(NULL));
  MEMORY__->previous_linear__4W= 0;
  first_free__YQI=NULL;
  MEMORY__->next_free__AX=NULL;
  MEMORY__->previous_free__BX=NULL;
  STRING__->capacity__GFD= 0;
  string_tmp__2=create__ZB( 256);
  path_current__GB=NULL;
  path_home__KB=NULL;
  shell__MB=NULL;
  step_count__0C= 0;
  system__FE=NULL;
  print__PB((&__string_1));
  ((__STRING *)string_tmp__2)->count__CB= 0;
  cwd__Y=to_external__AFD(string_tmp__2);
  getcwd((cwd__Y),255);
  from_external__TGD(string_tmp__2,cwd__Y);
  path_current__GB=create__ZB(((__STRING *)string_tmp__2)->count__CB);
  copy__JID(path_current__GB,string_tmp__2);
  path_home__KB=get_environment_variable__AC((&__string_2));
  shell__MB=get_environment_variable__AC((&__string_3));
  title__XC((&__string_4));
  std_file__MD=((__POINTER )(NULL));
  new_text__OD=NULL;
  file__PD=NULL;
  comment__QD=NULL;
  path__RD=NULL;
  path_next__SD=NULL;
  if (((void *)shell__MB != (void *)NULL)) {
    file__PD=create_from_string__R1(path_home__KB);
    if ((((__STRING *)shell__MB)->count__CB ==  0)) {
      print__PB((&__string_5));
      system__FE=(&__string_6);
      __tmp__HE=TRUE__;
    } else {
      __tmp__HE=FALSE__;
    };
    if (__tmp__HE) {
      __tmp__5E=TRUE__;
    } else {
      result__BNB=(first_substring_index__ORD(((__STRING *)shell__MB),(&__string_7)) !=  0);
      if (result__BNB) {
        append__XLD(file__PD,(&__string_8));
        system__FE=(&__string_9);
        comment__QD=(&__string_10);
        path__RD=(&__string_11);
        path_next__SD=(&__string_12);
      };
      __tmp__5E=result__BNB;
    };
    if (__tmp__5E) {
      __tmp__WF=TRUE__;
    } else {
      result__ONB=(first_substring_index__ORD(((__STRING *)shell__MB),(&__string_13)) !=  0);
      if (result__ONB) {
        append__XLD(file__PD,(&__string_14));
        system__FE=(&__string_15);
        comment__QD=(&__string_10);
        path__RD=(&__string_16);
        path_next__SD=(&__string_17);
      };
      __tmp__WF=result__ONB;
    };
    if ((! __tmp__WF)) {
      if ((first_substring_index__ORD(((__STRING *)shell__MB),(&__string_18)) !=  0)) {
        append__XLD(file__PD,(&__string_19));
        system__FE=(&__string_20);
        comment__QD=(&__string_10);
        path__RD=(&__string_11);
        path_next__SD=(&__string_12);
      } else {
        print__PB((&__string_21));
        put_string__WU(((__STRING *)shell__MB));
        fputc((int)('\n'),stdout);
        system__FE=(&__string_6);
      };
    };
  } else {
    copy__JID(string_tmp__2,(&__string_22));
    std_file__MD=((__POINTER )(fopen((char*)(to_external__AFD(string_tmp__2)),"rb")));
    if ((std_file__MD != (void *)NULL)) {
      fclose((FILE*)((std_file__MD)));
      file__PD=create_from_string__R1((&__string_23));
      system__FE=(&__string_24);
      comment__QD=(&__string_25);
      path__RD=(&__string_26);
      path_next__SD=(&__string_27);
    } else {
      system__FE=(&__string_6);
    };
  };
  print__PB((&__string_28));
  print__PB(system__FE);
  fputc((int)('\n'),stdout);
  if (((void *)system__FE != (void *)(&__string_6))) {
    if (((void *)system__FE == (void *)(&__string_24))) {
      update__idf__with__C2((&__string_29),(&__string_30),(&__string_31));
      print__PB((&__string_32));
    } else {
      update__idf__with__C2((&__string_29),(&__string_30),(&__string_33));
      print__PB((&__string_34));
      execute_command__PAB((&__string_35));
      copy__JID(string_tmp__2,(&__string_36));
      std_file__MD=((__POINTER )(fopen((char*)(to_external__AFD(string_tmp__2)),"rb")));
      fseek((FILE*)((std_file__MD)),0,SEEK_END);
      result__MEQ=((__INTEGER )(ftell((FILE *)(std_file__MD))));
      fseek((FILE*)((std_file__MD)),0,SEEK_SET);
      if ((result__MEQ ==  0)) {
        print__PB((&__string_37));
      } else {
        new_text__OD=create__ZB(result__MEQ);
        ptr__ZVQ=to_external__AFD(new_text__OD);
        fread((void *)((ptr__ZVQ)),(size_t)(1), (size_t)((result__MEQ)),(FILE*)((std_file__MD)));
        from_external__TGD(new_text__OD,ptr__ZVQ);
        Self__QWD=((__STRING *)new_text__OD);
        if (( 10 > Self__QWD->count__CB)) {
          Self__QWD->count__CB= 0;
        } else {
          Self__QWD->count__CB=(__INTEGER)(Self__QWD->count__CB -  10);
        };
        prepend__PKD(new_text__OD,(&__string_38));
        append__XLD(new_text__OD,(&__string_39));
        update__idf__with__C2((&__string_29),(&__string_40),new_text__OD);
      };
      fclose((FILE*)((std_file__MD)));
      execute_command__PAB((&__string_41));
    };
  };
  fputc((int)('\n'),stdout);
  title__XC((&__string_42));
  if (((void *)system__FE == (void *)(&__string_6))) {
    print__PB((&__string_43));
    put_string__WU(((__STRING *)path_current__GB));
    print__PB((&__string_44));
  } else {
    new_text__OD=create_from_string__R1(comment__QD);
    append__XLD(new_text__OD,path__RD);
    append__XLD(new_text__OD,path_current__GB);
    append__XLD(new_text__OD,path_next__SD);
    update__idf__with__C2(file__PD,comment__QD,new_text__OD);
  };
  title__XC((&__string_45));
  new_text__OD=create_from_string__R1(path_current__GB);
  if (((void *)system__FE == (void *)(&__string_24))) {
    replace_all__with__VPD(new_text__OD);
  };
  prepend__PKD(new_text__OD,(&__string_46));
  append__XLD(new_text__OD,(&__string_47));
  update__idf__with__C2((&__string_48),(&__string_49),new_text__OD);
  fputc((int)('\n'),stdout);
  update__idf__with__C2((&__string_50),(&__string_49),new_text__OD);
  fputc((int)('\n'),stdout);
  title__XC((&__string_51));
  char__XJ='\0';
  file_name__YJ=NULL;
  new_text__ZJ=NULL;
  print__PB((&__string_52));
  while (((char__XJ != 'y') && (char__XJ != 'n'))) {
    char__XJ=((__CHARACTER )(fgetc(stdin)));
  };
  if ((char__XJ == 'n')) {
    print__PB((&__string_53));
  } else {
    file_name__YJ=create__ZB( 100);
    if (((void *)path_home__KB == (void *)NULL)) {
      copy__JID(file_name__YJ,(&__string_54));
    } else {
      copy__JID(file_name__YJ,path_home__KB);
    };
    append__XLD(file_name__YJ,(&__string_55));
    new_text__ZJ=create_from_string__R1((&__string_56));
    append__XLD(new_text__ZJ,(&__string_57));
    append__XLD(new_text__ZJ,path_current__GB);
    if (((void *)system__FE == (void *)(&__string_24))) {
      replace_all__with__VPD(new_text__ZJ);
    };
    append__XLD(new_text__ZJ,(&__string_58));
    append__XLD(new_text__ZJ,(&__string_59));
    update__idf__with__C2(file_name__YJ,(&__string_56),new_text__ZJ);
  };
  title__XC((&__string_60));
  char__3L='\0';
  if (((void *)system__FE == (void *)(&__string_24))) {
    print__PB((&__string_61));
  } else {
    print__PB((&__string_62));
    while (((char__3L != 'y') && (char__3L != 'n'))) {
      char__3L=((__CHARACTER )(fgetc(stdin)));
    };
    if ((char__3L == 'n')) {
      print__PB((&__string_63));
    } else {
      execute_command__PAB((&__string_64));
      copy__JID(string_tmp__2,(&__string_65));
      print__PB((&__string_66));
      put_string__WU(((__STRING *)string_tmp__2));
      print__PB((&__string_67));
      if ((execute_command__PAB(string_tmp__2) !=  0)) {
        print__PB((&__string_68));
      } else {
        print__PB((&__string_69));
      };
    };
    fputc((int)('\n'),stdout);
  };
  title__XC((&__string_70));
  char__2N='\0';
  file_name__3N=NULL;
  if (((void *)system__FE == (void *)(&__string_24))) {
    print__PB((&__string_71));
  } else {
    print__PB((&__string_72));
    while (((char__2N != 'y') && (char__2N != 'n'))) {
      char__2N=((__CHARACTER )(fgetc(stdin)));
    };
    if ((char__2N == 'n')) {
      print__PB((&__string_73));
    } else {
      execute_command__PAB((&__string_74));
      execute_command__PAB((&__string_75));
      execute_command__PAB((&__string_76));
      execute_command__PAB((&__string_77));
      copy__JID(string_tmp__2,(&__string_78));
      print__PB((&__string_66));
      put_string__WU(((__STRING *)string_tmp__2));
      print__PB((&__string_67));
      if ((execute_command__PAB(string_tmp__2) !=  0)) {
        print__PB((&__string_79));
      } else {
        print__PB((&__string_69));
      };
      copy__JID(string_tmp__2,(&__string_80));
      print__PB((&__string_66));
      put_string__WU(((__STRING *)string_tmp__2));
      print__PB((&__string_67));
      if ((execute_command__PAB(string_tmp__2) !=  0)) {
        print__PB((&__string_79));
      } else {
        print__PB((&__string_69));
      };
      char__2N='?';
      print__PB((&__string_81));
      while (((char__2N != 'y') && (char__2N != 'n'))) {
        char__2N=((__CHARACTER )(fgetc(stdin)));
      };
      if ((char__2N == 'n')) {
        file_name__3N=create__ZB( 100);
        if (((void *)path_home__KB == (void *)NULL)) {
          copy__JID(file_name__3N,(&__string_54));
        } else {
          copy__JID(file_name__3N,path_home__KB);
        };
        append__XLD(file_name__3N,(&__string_82));
        update__idf__with__C2(file_name__3N,(&__string_83),(&__string_83));
      } else {
        copy__JID(string_tmp__2,(&__string_84));
        print__PB((&__string_66));
        put_string__WU(((__STRING *)string_tmp__2));
        print__PB((&__string_67));
        if ((execute_command__PAB(string_tmp__2) !=  0)) {
          print__PB((&__string_79));
        } else {
          print__PB((&__string_69));
        };
      };
    };
    fputc((int)('\n'),stdout);
  };
  title__XC((&__string_85));
  compile_file__LS((&__string_86));
  title__XC((&__string_87));
  compile_file__LS((&__string_88));
  title__XC((&__string_89));
  char__4S='\0';
  print__PB((&__string_90));
  while (((char__4S != 'y') && (char__4S != 'n'))) {
    char__4S=((__CHARACTER )(fgetc(stdin)));
  };
  if ((char__4S == 'n')) {
    print__PB((&__string_91));
  } else {
    ((__STRING *)string_tmp__2)->count__CB= 0;
    if (((void *)system__FE == (void *)(&__string_24))) {
      copy__JID(string_tmp__2,(&__string_92));
    } else {
      copy__JID(string_tmp__2,(&__string_93));
    };
    print__PB((&__string_94));
    put_string__WU(((__STRING *)string_tmp__2));
    print__PB((&__string_95));
    execute_command__PAB(string_tmp__2);
    print__PB((&__string_96));
  };
  fputc((int)('\n'),stdout);
  title__XC((&__string_97));
  print__PB((&__string_98));
  return( 0);
}

static __STRING* create__ZB(__INTEGER needed_capacity__1B)
// ({INTEGER}) With resultNo recursive, No inlinable.
{
  __STRING *result__3B,*Self__TJD;
  result__3B=clone__1V();
  Self__TJD=((__STRING *)result__3B);
  if ((needed_capacity__1B >  0)) {
    if ((Self__TJD->capacity__GFD < needed_capacity__1B)) {
      Self__TJD->storage__DGD=create__LMH(needed_capacity__1B);
      Self__TJD->capacity__GFD=needed_capacity__1B;
    };
  };
  Self__TJD->count__CB= 0;
  return(result__3B);
}

static void print__PB(__STRING_CONSTANT *Self__QB)
// ({STRING_CONSTANT}) VoidRecursive, No inlinable.
{
  put_string__WU(Self__QB);
}

static __CHARACTER* to_external__AFD(__STRING *Self__BFD)
// ({STRING}) With resultNo recursive, No inlinable.
{
  if ((Self__BFD->capacity__GFD > Self__BFD->count__CB)) {
    Self__BFD->count__CB=(__INTEGER)(Self__BFD->count__CB +  1);
    if ((((__CHARACTER *)Self__BFD->storage__DGD)[(__INTEGER)(Self__BFD->count__CB -  1)] != '\0')) {
      ((__CHARACTER *)Self__BFD->storage__DGD)[(__INTEGER)(Self__BFD->count__CB -  1)]='\0';
    };
  } else {
    add_last__GJF(Self__BFD,'\0');
  };
  Self__BFD->count__CB=(__INTEGER)(Self__BFD->count__CB -  1);
  return(Self__BFD->storage__DGD);
}

static void from_external__TGD(__STRING *Self__UGD,__CHARACTER *p__VGD)
// ({STRING},{NULLxNATIVE_ARRAYoExpanded_CHARACTERo}) VoidNo recursive, No inlinable.
{
  Self__UGD->count__CB= 0;
  while ((((__CHARACTER *)p__VGD)[Self__UGD->count__CB] != '\0')) {
    Self__UGD->count__CB=(__INTEGER)(Self__UGD->count__CB +  1);
  };
  if (((void *)Self__UGD->storage__DGD != (void *)p__VGD)) {
    Self__UGD->storage__DGD=p__VGD;
    Self__UGD->capacity__GFD=(__INTEGER)(Self__UGD->count__CB +  1);
  };
}

static void copy__JID(__STRING *Self__KID,void *other__LID)
// ({STRING},{NULLxSTRING_CONSTANTxSTRING}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__MID;
  __CHARACTER *__tmp__BJD,*__tmp__DJD;
  if (((struct ___OBJ *)other__LID)->__id==__STRING_CONSTANT__) {
    __tmp__MID=((__STRING_CONSTANT *)other__LID)->count__AD;
  } else {
    __tmp__MID=((__STRING *)other__LID)->count__CB;
  };
  Self__KID->count__CB=__tmp__MID;
  if ((__tmp__MID >  0)) {
    if ((Self__KID->capacity__GFD < __tmp__MID)) {
      Self__KID->storage__DGD=create__LMH(__tmp__MID);
      Self__KID->capacity__GFD=Self__KID->count__CB;
    };
    __tmp__BJD=Self__KID->storage__DGD;
    if (((struct ___OBJ *)other__LID)->__id==__STRING_CONSTANT__) {
      __tmp__DJD=((__STRING_CONSTANT *)other__LID)->storage__K3B;
    } else {
      __tmp__DJD=((__STRING *)other__LID)->storage__DGD;
    };
    copy_from__until__ZKF(__tmp__BJD,__tmp__DJD,(__INTEGER)(Self__KID->count__CB -  1));
  };
}

static void* get_environment_variable__AC(void *variable__CC)
// ({STRING_CONSTANT}) With resultNo recursive, No inlinable.
{
  void *result__EC;
  __STRING *new__0XQ;
  __CHARACTER *p__FC;
  result__EC=NULL;
  new__0XQ=create__ZB(((__STRING_CONSTANT *)variable__CC)->count__AD);
  copy__JID(new__0XQ,variable__CC);
  p__FC=((__CHARACTER *)(getenv((char*)(to_external__AFD(new__0XQ)))));
  if (((void *)p__FC != (void *)NULL)) {
    result__EC=clone__1V();
    from_external__TGD(result__EC,p__FC);
  };
  return(result__EC);
}

static void title__XC(void *str__ZC)
// ({STRING_CONSTANT}) VoidNo recursive, No inlinable.
{
  __INTEGER Self__I0,limit_up__J0;
  step_count__0C=(__INTEGER)(step_count__0C +  1);
  print__PB((&__string_99));
  print__CZ(step_count__0C);
  fputc((int)('/'),stdout);
  print__CZ( 10);
  print__PB((&__string_100));
  print__PB(str__ZC);
  fputc((int)('\n'),stdout);
  Self__I0= 1;
  limit_up__J0=(__INTEGER)(((__STRING_CONSTANT *)str__ZC)->count__AD +  11);
  while ((Self__I0 <= limit_up__J0)) {
    print__PB((&__string_101));
    Self__I0=(__INTEGER)(Self__I0 +  1);
  };
  fputc((int)('\n'),stdout);
}

static __STRING* create_from_string__R1(void *str__T1)
// ({NULLxSTRING_CONSTANTxSTRING}) With resultNo recursive, No inlinable.
{
  __INTEGER __tmp__W1;
  __STRING *result__V1;
  if (((struct ___OBJ *)str__T1)->__id==__STRING_CONSTANT__) {
    __tmp__W1=((__STRING_CONSTANT *)str__T1)->count__AD;
  } else {
    __tmp__W1=((__STRING *)str__T1)->count__CB;
  };
  result__V1=create__ZB(__tmp__W1);
  copy__JID(result__V1,str__T1);
  return(result__V1);
}

static __INTEGER first_substring_index__ORD(__STRING *Self__PRD,void *other__QRD)
// ({STRING},{NULLxSTRING_CONSTANT}) With resultNo recursive, No inlinable.
{
  __INTEGER i__LNE,result__NNE,s__MNE,__tmp__FAS,__tmp__GAS,__tmp__HAS;
  __INTEGER __tmp__JAS;
  __CHARACTER *__tmp__IAS,*__tmp__IDS;
  i__LNE= 0;
  result__NNE= 0;
  s__MNE= 1;
  __tmp__FAS=((__STRING_CONSTANT *)other__QRD)->count__AD;
  __tmp__GAS=Self__PRD->count__CB;
  __tmp__HAS=((__STRING_CONSTANT *)other__QRD)->count__AD;
  __tmp__IAS=Self__PRD->storage__DGD;
  __tmp__JAS=((__STRING_CONSTANT *)other__QRD)->count__AD;
  __tmp__IDS=((__STRING_CONSTANT *)other__QRD)->storage__K3B;
  while ((! ((result__NNE !=  0) || ((__INTEGER)((__INTEGER)(s__MNE + __tmp__FAS) -  1) > __tmp__GAS)))) {
    i__LNE= 1;
    while ((! ((i__LNE > __tmp__HAS) || (((__CHARACTER *)__tmp__IAS)[(__INTEGER)((__INTEGER)((__INTEGER)(s__MNE + i__LNE) -  1) -  1)] != ((__CHARACTER *)__tmp__IDS)[(__INTEGER)(i__LNE -  1)])))) {
      i__LNE=(__INTEGER)(i__LNE +  1);
    };
    if ((i__LNE > __tmp__JAS)) {
      result__NNE=s__MNE;
    } else {
      s__MNE=(__INTEGER)(s__MNE +  1);
    };
  };
  return(result__NNE);
}

static void append__XLD(__STRING *Self__YLD,void *other__ZLD)
// ({STRING},{NULLxSTRING_CONSTANTxSTRING}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__CMD,needed_capacity__1LD;
  __CHARACTER *__tmp__5MD,*__tmp__AND;
  if (((struct ___OBJ *)other__ZLD)->__id==__STRING_CONSTANT__) {
    __tmp__CMD=((__STRING_CONSTANT *)other__ZLD)->count__AD;
  } else {
    __tmp__CMD=((__STRING *)other__ZLD)->count__CB;
  };
  needed_capacity__1LD=(__INTEGER)(Self__YLD->count__CB + __tmp__CMD);
  if ((Self__YLD->capacity__GFD < needed_capacity__1LD)) {
    if ((Self__YLD->capacity__GFD ==  0)) {
      Self__YLD->capacity__GFD=needed_capacity__1LD;
      Self__YLD->storage__DGD=create__LMH(needed_capacity__1LD);
    } else {
      Self__YLD->storage__DGD=realloc__with__INH(Self__YLD->storage__DGD,Self__YLD->capacity__GFD,needed_capacity__1LD);
      Self__YLD->capacity__GFD=needed_capacity__1LD;
    };
  };
  __tmp__5MD=Self__YLD->storage__DGD;
  if (((struct ___OBJ *)other__ZLD)->__id==__STRING_CONSTANT__) {
    __tmp__AND=((__STRING_CONSTANT *)other__ZLD)->storage__K3B;
  } else {
    __tmp__AND=((__STRING *)other__ZLD)->storage__DGD;
  };
  copy__to__until__JVJ(__tmp__5MD,__tmp__AND,Self__YLD->count__CB,__tmp__CMD);
  Self__YLD->count__CB=needed_capacity__1LD;
}

static void put_string__WU(void *s__YU)
// ({STRING_CONSTANTxSTRING}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__LV,Self__LDB,limit_up__MDB;
  __CHARACTER *__tmp__JDS,*__tmp__KDS;
  __CHARACTER __tmp__SV;
  if (((struct ___OBJ *)s__YU)->__id==__STRING_CONSTANT__) {
  };
  if (((struct ___OBJ *)s__YU)->__id==__STRING_CONSTANT__) {
    __tmp__LV=((__STRING_CONSTANT *)s__YU)->count__AD;
  } else {
    __tmp__LV=((__STRING *)s__YU)->count__CB;
  };
  Self__LDB= 1;
  limit_up__MDB=__tmp__LV;
  __tmp__JDS=((__STRING_CONSTANT *)s__YU)->storage__K3B;
  __tmp__KDS=((__STRING *)s__YU)->storage__DGD;
  while ((Self__LDB <= limit_up__MDB)) {
    if (((struct ___OBJ *)s__YU)->__id==__STRING_CONSTANT__) {
      __tmp__SV=((__CHARACTER *)__tmp__JDS)[(__INTEGER)(Self__LDB -  1)];
    } else {
      __tmp__SV=((__CHARACTER *)__tmp__KDS)[(__INTEGER)(Self__LDB -  1)];
    };
    fputc((int)(__tmp__SV),stdout);
    Self__LDB=(__INTEGER)(Self__LDB +  1);
  };
}

static void update__idf__with__C2(void *file__E2,void *id__F2,void *new_text__G2)
// ({NULLxSTRING_CONSTANTxSTRING},{NULLxSTRING_CONSTANT},{NULLxSTRING_CONSTANTxSTRING}) VoidNo recursive, No inlinable.
{
  __INTEGER index__H2,result__OUB,__tmp__U2,__tmp__A3,Self__S3B;
  __INTEGER limit_up__T3B,__tmp__EVD,__tmp__FVD,__tmp__ZVD,i__WSG;
  __INTEGER j__DSD,__tmp__WSD;
  void *old_buffer__I2,*input__J2;
  __POINTER std_file__K2,stream__JVB;
  __STRING_CONSTANT *Self__H3B,*Self__RZQ,*Self__UZQ;
  __STRING *Self__4YQ,*Self__0UD,*Self__ASD,*new__SZQ,*__tmp__S4;
  __STRING *new__VZQ,*__tmp__U4;
  __CHARACTER *ptr__XUB,*__tmp__WVD,*__tmp__XVD,*Self__CSG,*other__DSG;
  __CHARACTER *__tmp__GTD,*__tmp__HTD;
  __BOOLEAN result__3UD,result__LVB;
  index__H2= 0;
  old_buffer__I2=NULL;
  input__J2=NULL;
  print__PB((&__string_102));
  if (((struct ___OBJ *)file__E2)->__id==__STRING_CONSTANT__) {
    print__PB(file__E2);
  } else {
    put_string__WU(((__STRING *)file__E2));
  };
  copy__JID(string_tmp__2,file__E2);
  std_file__K2=((__POINTER )(fopen((char*)(to_external__AFD(string_tmp__2)),"rb")));
  if ((std_file__K2 != (void *)NULL)) {
    fseek((FILE*)((std_file__K2)),0,SEEK_END);
    result__OUB=((__INTEGER )(ftell((FILE *)(std_file__K2))));
    fseek((FILE*)((std_file__K2)),0,SEEK_SET);
    if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
      __tmp__U2=((__STRING_CONSTANT *)new_text__G2)->count__AD;
    } else {
      __tmp__U2=((__STRING *)new_text__G2)->count__CB;
    };
    input__J2=create__ZB((__INTEGER)(result__OUB + __tmp__U2));
    ptr__XUB=to_external__AFD(input__J2);
    fread((void *)((ptr__XUB)),(size_t)(1), (size_t)((result__OUB)),(FILE*)((std_file__K2)));
    from_external__TGD(input__J2,ptr__XUB);
    fclose((FILE*)((std_file__K2)));
    index__H2=first_substring_index__ORD(input__J2,id__F2);
    if ((index__H2 !=  0)) {
      old_buffer__I2=create__ZB( 200);
      if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
        Self__H3B=((__STRING_CONSTANT *)new_text__G2);
        __tmp__A3=fast_occurrences__until__HHC(Self__H3B->storage__K3B,(__INTEGER)(Self__H3B->count__AD -  1));
      } else {
        Self__4YQ=((__STRING *)new_text__G2);
        __tmp__A3=fast_occurrences__until__HHC(Self__4YQ->storage__DGD,(__INTEGER)(Self__4YQ->count__CB -  1));
      };
      Self__S3B= 1;
      limit_up__T3B=__tmp__A3;
      while ((Self__S3B <= limit_up__T3B)) {
        while ((((__CHARACTER *)((__STRING *)input__J2)->storage__DGD)[(__INTEGER)(index__H2 -  1)] != '\n')) {
          add_last__GJF(old_buffer__I2,((__CHARACTER *)((__STRING *)input__J2)->storage__DGD)[(__INTEGER)(index__H2 -  1)]);
          remove__0SF(input__J2,index__H2);
        };
        add_last__GJF(old_buffer__I2,((__CHARACTER *)((__STRING *)input__J2)->storage__DGD)[(__INTEGER)(index__H2 -  1)]);
        remove__0SF(input__J2,index__H2);
        Self__S3B=(__INTEGER)(Self__S3B +  1);
      };
      Self__0UD=((__STRING *)old_buffer__I2);
      result__3UD=FALSE__;
      __tmp__EVD=Self__0UD->count__CB;
      if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
        __tmp__FVD=((__STRING_CONSTANT *)new_text__G2)->count__AD;
      } else {
        __tmp__FVD=((__STRING *)new_text__G2)->count__CB;
      };
      if ((__tmp__EVD == __tmp__FVD)) {
        if ((Self__0UD->count__CB ==  0)) {
          result__3UD=TRUE__;
        } else {
          __tmp__WVD=Self__0UD->storage__DGD;
          if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
            __tmp__XVD=((__STRING_CONSTANT *)new_text__G2)->storage__K3B;
          } else {
            __tmp__XVD=((__STRING *)new_text__G2)->storage__DGD;
          };
          __tmp__ZVD=Self__0UD->count__CB;
          Self__CSG=((__CHARACTER *)__tmp__WVD);
          other__DSG=__tmp__XVD;
          i__WSG=(__INTEGER)(__tmp__ZVD -  1);
          while (((i__WSG >=  0) && (Self__CSG[i__WSG] == ((__CHARACTER *)other__DSG)[i__WSG]))) {
            i__WSG=(__INTEGER)(i__WSG -  1);
          };
          result__3UD=(i__WSG <  0);
        };
      };
      if (result__3UD) {
        print__PB((&__string_103));
      } else {
        print__PB((&__string_104));
        put_string__WU(((__STRING *)old_buffer__I2));
        print__PB((&__string_105));
      };
    } else {
      print__PB((&__string_106));
      index__H2=(__INTEGER)(((__STRING *)input__J2)->count__CB +  1);
    };
    if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
      print__PB(new_text__G2);
    } else {
      put_string__WU(((__STRING *)new_text__G2));
    };
    Self__ASD=((__STRING *)input__J2);
    j__DSD=Self__ASD->count__CB;
    if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
      __tmp__WSD=((__STRING_CONSTANT *)new_text__G2)->count__AD;
    } else {
      __tmp__WSD=((__STRING *)new_text__G2)->count__CB;
    };
    resize__FHE(Self__ASD,(__INTEGER)(j__DSD + __tmp__WSD));
    if ((index__H2 <= j__DSD)) {
      move__to__by__BQF(Self__ASD->storage__DGD,(__INTEGER)(index__H2 -  1),(__INTEGER)(j__DSD -  1),__tmp__WSD);
    };
    __tmp__GTD=Self__ASD->storage__DGD;
    if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
      __tmp__HTD=((__STRING_CONSTANT *)new_text__G2)->storage__K3B;
    } else {
      __tmp__HTD=((__STRING *)new_text__G2)->storage__DGD;
    };
    copy__to__until__JVJ(__tmp__GTD,__tmp__HTD,(__INTEGER)(index__H2 -  1),__tmp__WSD);
  } else {
    print__PB((&__string_107));
    if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
      print__PB(new_text__G2);
    } else {
      put_string__WU(((__STRING *)new_text__G2));
    };
    if (((struct ___OBJ *)new_text__G2)->__id==__STRING_CONSTANT__) {
      Self__RZQ=((__STRING_CONSTANT *)new_text__G2);
      new__SZQ=create__ZB(Self__RZQ->count__AD);
      copy__JID(new__SZQ,Self__RZQ);
      __tmp__S4=new__SZQ;
    } else {
      __tmp__S4=create_from_string__R1(((__STRING *)new_text__G2));
    };
    input__J2=__tmp__S4;
    if (((struct ___OBJ *)file__E2)->__id==__STRING_CONSTANT__) {
      Self__UZQ=((__STRING_CONSTANT *)file__E2);
      new__VZQ=create__ZB(Self__UZQ->count__AD);
      copy__JID(new__VZQ,Self__UZQ);
      __tmp__U4=new__VZQ;
    } else {
      __tmp__U4=create_from_string__R1(((__STRING *)file__E2));
    };
    stream__JVB=((__POINTER )(fopen((char*)(to_external__AFD(__tmp__U4)),"w+b")));
    result__LVB=(stream__JVB != (void *)NULL);
    if (result__LVB) {
      fclose((FILE*)((stream__JVB)));
    };
    if ((! result__LVB)) {
      print__PB((&__string_108));
      print__PB((&__string_109));
      exit(( 1));
    };
  };
  copy__JID(string_tmp__2,file__E2);
  std_file__K2=((__POINTER )(fopen((char*)(to_external__AFD(string_tmp__2)),"wb")));
  if ((std_file__K2 == (void *)NULL)) {
    print__PB((&__string_108));
    print__PB((&__string_110));
    exit(( 1));
  };
  fwrite((void *)((to_external__AFD(input__J2))),(size_t)(1), (size_t)((((__STRING *)input__J2)->count__CB)),(FILE*)((std_file__K2)));
  fclose((FILE*)((std_file__K2)));
}

static __INTEGER execute_command__PAB(void *system_command_line__RAB)
// ({NULLxSTRING_CONSTANTxSTRING}) With resultNo recursive, No inlinable.
{
  __STRING_CONSTANT *Self__HY;
  __STRING *new__ZFB;
  __CHARACTER *__tmp__ZAB;
  if (((struct ___OBJ *)system_command_line__RAB)->__id==__STRING_CONSTANT__) {
    Self__HY=((__STRING_CONSTANT *)system_command_line__RAB);
    new__ZFB=create__ZB(Self__HY->count__AD);
    copy__JID(new__ZFB,Self__HY);
    __tmp__ZAB=to_external__AFD(new__ZFB);
  } else {
    __tmp__ZAB=to_external__AFD(system_command_line__RAB);
  };
  return(((__INTEGER )(system(((char*)((__tmp__ZAB)))))));
}

static void prepend__PKD(__STRING *Self__QKD,void *other__RKD)
// ({STRING},{STRING_CONSTANT}) VoidNo recursive, No inlinable.
{
  __INTEGER i__SKD,j__TKD;
  i__SKD=Self__QKD->count__CB;
  j__TKD=((__STRING_CONSTANT *)other__RKD)->count__AD;
  resize__FHE(Self__QKD,(__INTEGER)(i__SKD + j__TKD));
  if (((i__SKD >  0) && (j__TKD >  0))) {
    move__to__by__BQF(Self__QKD->storage__DGD, 0,(__INTEGER)(i__SKD -  1),j__TKD);
  };
  copy_from__until__ZKF(Self__QKD->storage__DGD,((__STRING_CONSTANT *)other__RKD)->storage__K3B,(__INTEGER)(j__TKD -  1));
}

static void replace_all__with__VPD(__STRING *Self__WPD)
// ({STRING}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__4PD,Self__KGK;
  __CHARACTER *__tmp__1PD,*Self__OWJ;
  __tmp__1PD=Self__WPD->storage__DGD;
  __tmp__4PD=(__INTEGER)(Self__WPD->count__CB -  1);
  Self__OWJ=((__CHARACTER *)__tmp__1PD);
  Self__KGK=__tmp__4PD;
  while ((Self__KGK >=  0)) {
    if (('\\' == Self__OWJ[Self__KGK])) {
      Self__OWJ[Self__KGK]='/';
    };
    Self__KGK=(__INTEGER)(Self__KGK -  1);
  };
}

static void compile_file__LS(void *n__NS)
// ({STRING_CONSTANT}) VoidNo recursive, No inlinable.
{
  copy__JID(string_tmp__2,(&__string_111));
  append__XLD(string_tmp__2,n__NS);
  append__XLD(string_tmp__2,(&__string_112));
  append__XLD(string_tmp__2,n__NS);
  print__PB((&__string_113));
  put_string__WU(((__STRING *)string_tmp__2));
  print__PB((&__string_114));
  if ((execute_command__PAB(string_tmp__2) !=  0)) {
    print__PB((&__string_115));
    print__PB(n__NS);
    print__PB((&__string_116));
  };
  fputc((int)('\n'),stdout);
}

static __STRING* clone__1V()
// () With resultNo recursive, No inlinable.
{
  __STRING *result__4V;
  __POINTER ptr__5V;
  __INTEGER typ_id__GW;
  __UINTEGER_32 sz__DW,a__ABS,new_size__Q0B,t__Z1B,a__EBS;
  result__4V=NULL;
  ptr__5V=((__POINTER )(NULL));
  typ_id__GW= 0;
  sz__DW=((__UINTEGER_32 )sizeof(__STRING));
  if ((sz__DW ==  0)) {
    result__4V=STRING__;
  } else {
    typ_id__GW=-1;
    clone_allocation_size__UW=(__UINTEGER_32)(clone_allocation_size__UW + sz__DW);
    if ((typ_id__GW == (__INTEGER)(-  1))) {
      a__ABS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
      new_size__Q0B=(__UINTEGER_32)((__UINTEGER_32)(sz__DW + a__ABS) & (__UINTEGER_32)(~ a__ABS));
      ptr__5V=micro_alloc__table__lab__VBC(new_size__Q0B,((__POINTER )(&(table_size[((__UINTEGER_32)(new_size__Q0B / ((__UINTEGER_32 )((__INTEGER )(sizeof(void *))))))-1]))),new_size__Q0B);
    } else {
      t__Z1B=((__UINTEGER_32 )typ_id__GW);
      a__EBS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
      ptr__5V=micro_alloc__table__lab__VBC((__UINTEGER_32)((__UINTEGER_32)(sz__DW + a__EBS) & (__UINTEGER_32)(~ a__EBS)),((__POINTER )(&(table_type[(t__Z1B)]))),(__UINTEGER_32)(t__Z1B |  1));
    };
    result__4V=((__STRING *)ptr__5V);
    *(result__4V) = *(STRING__);
  };
  return(result__4V);
}

static __CHARACTER* create__LMH(__INTEGER nb_elements__NMH)
// ({INTEGER}) With resultNo recursive, No inlinable.
{
  __INTEGER Self__RHK;
  __CHARACTER *Result__GSH;
  Result__GSH=((__CHARACTER *)alloc_dynamic__31H(((__UINTEGER_32 )nb_elements__NMH)));
  Self__RHK=(__INTEGER)(nb_elements__NMH -  1);
  while ((Self__RHK >=  0)) {
    Result__GSH[Self__RHK]='\0';
    Self__RHK=(__INTEGER)(Self__RHK -  1);
  };
  return(Result__GSH);
}

static void add_last__GJF(__STRING *Self__HJF,__CHARACTER ch__IJF)
// ({STRING},{CHARACTER}) VoidNo recursive, No inlinable.
{
  __INTEGER new_capacity__JJF;
  new_capacity__JJF= 0;
  if ((Self__HJF->capacity__GFD <= Self__HJF->count__CB)) {
    if ((Self__HJF->capacity__GFD ==  0)) {
      Self__HJF->capacity__GFD= 32;
      Self__HJF->storage__DGD=create__LMH( 32);
    } else {
      new_capacity__JJF=(__INTEGER)(Self__HJF->capacity__GFD <<  1);
      Self__HJF->storage__DGD=realloc__with__INH(Self__HJF->storage__DGD,Self__HJF->capacity__GFD,new_capacity__JJF);
      Self__HJF->capacity__GFD=new_capacity__JJF;
    };
  };
  ((__CHARACTER *)Self__HJF->storage__DGD)[Self__HJF->count__CB]=ch__IJF;
  Self__HJF->count__CB=(__INTEGER)(Self__HJF->count__CB +  1);
}

static void copy_from__until__ZKF(__CHARACTER *Self__0KF,__CHARACTER *model__1KF,__INTEGER upper__2KF)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{NULLxNATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER Self__43F;
  Self__43F=upper__2KF;
  while ((Self__43F >=  0)) {
    Self__0KF[Self__43F]=((__CHARACTER *)model__1KF)[Self__43F];
    Self__43F=(__INTEGER)(Self__43F -  1);
  };
}

static void print__CZ(__INTEGER Self__DZ)
// ({INTEGER}) VoidNo recursive, No inlinable.
{
  __BOOLEAN __tmp__KZ;
  if ((Self__DZ ==  0)) {
    fputc((int)('0'),stdout);
    __tmp__KZ=TRUE__;
  } else {
    __tmp__KZ=FALSE__;
  };
  if ((! __tmp__KZ)) {
    if ((Self__DZ <  0)) {
      fputc((int)('-'),stdout);
      print_positif__VEL((__INTEGER)(- Self__DZ));
    } else {
      print_positif__VEL(Self__DZ);
    };
  };
}

static __CHARACTER* realloc__with__INH(__CHARACTER *Self__JNH,__INTEGER old_nb_elts__KNH,__INTEGER new_nb_elts__LNH)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER},{INTEGER}) With resultNo recursive, No inlinable.
{
  __POINTER old_ptr__COH,result__HXH,p__0JI,last__1VI;
  __UINTEGER_32 __tmp__OOH,__tmp__QOH,a__QBS,old_size__3WH;
  __UINTEGER_32 old_size2__AXH,a__TBS,new_size__DXH,a__V5B,__tmp__YYH;
  __UINTEGER_32 sz__WLI,old_size__TLI,prev__HIJ,new_size__KIJ;
  __MEMORY *mem__GXH,*Self__NLI,*nxt__RLI,*result__SLI,*next__GIJ;
  __MEMORY *new_free__FIJ;
  __CHARACTER *new__BOH;
  old_ptr__COH=((__POINTER )Self__JNH);
  __tmp__OOH=((__UINTEGER_32 )old_nb_elts__KNH);
  __tmp__QOH=((__UINTEGER_32 )new_nb_elts__LNH);
  mem__GXH=NULL;
  result__HXH=((__POINTER )(NULL));
  a__QBS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
  old_size__3WH=(__UINTEGER_32)((__UINTEGER_32)(__tmp__OOH + a__QBS) & (__UINTEGER_32)(~ a__QBS));
  old_size2__AXH=(__UINTEGER_32)(old_size__3WH + ((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))));
  a__TBS=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
  new_size__DXH=(__UINTEGER_32)((__UINTEGER_32)(__tmp__QOH + a__TBS) & (__UINTEGER_32)(~ a__TBS));
  if ((old_size2__AXH <= ((__UINTEGER_32 )(MINIMUM_SIZE)))) {
    result__HXH=alloc_dynamic__31H(new_size__DXH);
    copy__to__size__SII(old_ptr__COH,result__HXH,old_size__3WH);
    p__0JI=(void *)((unsigned long)old_ptr__COH - (unsigned long)((__POINTER )((__INTEGER )(sizeof(void *)))));
    a__V5B=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
    last__1VI=((__POINTER *)((__POINTER )(&(table_size[((__UINTEGER_32)((__UINTEGER_32)((__UINTEGER_32)(old_size2__AXH + a__V5B) & (__UINTEGER_32)(~ a__V5B)) / ((__UINTEGER_32 )((__INTEGER )(sizeof(void *))))))-1]))))[ 0];
    ((__POINTER *)p__0JI)[ 0]=(void *)((unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)(void *)((unsigned long)(void *)((unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER *)last__1VI)[ 0]) - (unsigned long)((__POINTER ) 1)) & (unsigned long)(void *)((unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 3)) - (unsigned long)((__POINTER ) 1)))) - (unsigned long)((__POINTER ) 1));
    ((__POINTER *)last__1VI)[ 0]=p__0JI;
  } else {
    mem__GXH=((__MEMORY *)(void *)((unsigned long)old_ptr__COH - (unsigned long)((__POINTER ) 8)));
    __tmp__YYH=(__UINTEGER_32)(((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)old_ptr__COH - (unsigned long)begin_memory__SDC)))) >>  26);
    Self__NLI=((__MEMORY *)mem__GXH);
    nxt__RLI=NULL;
    result__SLI=NULL;
    sz__WLI= 0;
    old_size__TLI=(__UINTEGER_32)(Self__NLI->size_and_id__5W &  4294967292LU);
    if ((new_size__DXH > old_size__TLI)) {
      if ((! ((__UINTEGER_32)(Self__NLI->size_and_id__5W &  2) !=  0))) {
        nxt__RLI=((__MEMORY *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__NLI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__NLI->size_and_id__5W &  4294967292LU)))));
        sz__WLI=(__UINTEGER_32)((__UINTEGER_32)(new_size__DXH - old_size__TLI) -  8);
        if ((((__UINTEGER_32)(((__MEMORY *)nxt__RLI)->size_and_id__5W &  1) ==  0) && ((__UINTEGER_32)(((__MEMORY *)nxt__RLI)->size_and_id__5W &  4294967292LU) >= sz__WLI))) {
          to_busy__index__N4J(nxt__RLI,sz__WLI,__tmp__YYH);
          Self__NLI->size_and_id__5W=(__UINTEGER_32)((__UINTEGER_32)(Self__NLI->size_and_id__5W + (__UINTEGER_32)(nxt__RLI->size_and_id__5W &  4294967294LU)) +  8);
          if (((__UINTEGER_32)(Self__NLI->size_and_id__5W &  2) !=  0)) {
            last_block[(__tmp__YYH)] = (Self__NLI);
          } else {
            nxt__RLI=((__MEMORY *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__NLI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__NLI->size_and_id__5W &  4294967292LU)))));
            ((__MEMORY *)nxt__RLI)->previous_linear__4W=((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )Self__NLI) - (unsigned long)begin_memory__SDC))));
          };
          result__SLI=Self__NLI;
        };
      };
      if (((void *)result__SLI == (void *)NULL)) {
        result__SLI=search__VPI(new_size__DXH);
        copy__to__size__SII((void *)((unsigned long)((__POINTER )Self__NLI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))),(void *)((unsigned long)((__POINTER )((__MEMORY *)result__SLI)) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))),old_size__TLI);
        prev__HIJ=Self__NLI->previous_linear__4W;
        next__GIJ=((__MEMORY *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__NLI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__NLI->size_and_id__5W &  4294967292LU)))));
        new_free__FIJ=((__MEMORY *)(void *)((unsigned long)begin_memory__SDC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )prev__HIJ))));
        new_size__KIJ=(__UINTEGER_32)(Self__NLI->size_and_id__5W &  4294967294LU);
        if (((prev__HIJ ==  4294967295LU) || ((__UINTEGER_32)(new_free__FIJ->size_and_id__5W &  1) !=  0))) {
          new_free__FIJ=Self__NLI;
          add_link_free__ARJ(Self__NLI);
        } else {
          new_size__KIJ=(__UINTEGER_32)((__UINTEGER_32)(new_size__KIJ + new_free__FIJ->size_and_id__5W) +  8);
        };
        if (((! ((__UINTEGER_32)(Self__NLI->size_and_id__5W &  2) !=  0)) && ((__UINTEGER_32)(next__GIJ->size_and_id__5W &  1) ==  0))) {
          new_size__KIJ=(__UINTEGER_32)((__UINTEGER_32)(new_size__KIJ + next__GIJ->size_and_id__5W) +  8);
          delete_link_free__QNK(next__GIJ);
        };
        new_free__FIJ->size_and_id__5W=new_size__KIJ;
        if (((__UINTEGER_32)(new_free__FIJ->size_and_id__5W &  2) !=  0)) {
          last_block[(__tmp__YYH)] = (new_free__FIJ);
        } else {
          next__GIJ=((__MEMORY *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__NLI) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__NLI->size_and_id__5W &  4294967292LU)))));
          next__GIJ->previous_linear__4W=((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )new_free__FIJ) - (unsigned long)begin_memory__SDC))));
        };
      };
    } else {
      result__SLI=Self__NLI;
    };
    result__HXH=(void *)((unsigned long)((__POINTER )((__MEMORY *)result__SLI)) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8)));
  };
  new__BOH=((__CHARACTER *)result__HXH);
  clear__to__A2J(new__BOH,old_nb_elts__KNH,(__INTEGER)(new_nb_elts__LNH -  1));
  return(new__BOH);
}

static void copy__to__until__JVJ(__CHARACTER *Self__KVJ,__CHARACTER *src__LVJ,__INTEGER dest__MVJ,__INTEGER src_capacity__NVJ)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{NULLxNATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER i2__3VJ,i1__2VJ;
  i2__3VJ= 0;
  i1__2VJ=dest__MVJ;
  while ((i2__3VJ != src_capacity__NVJ)) {
    Self__KVJ[i1__2VJ]=((__CHARACTER *)src__LVJ)[i2__3VJ];
    i2__3VJ=(__INTEGER)(i2__3VJ +  1);
    i1__2VJ=(__INTEGER)(i1__2VJ +  1);
  };
}

static __INTEGER fast_occurrences__until__HHC(__CHARACTER *Self__IHC,__INTEGER upper__KHC)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER}) With resultNo recursive, No inlinable.
{
  __INTEGER count__UHC,Self__0PC;
  count__UHC= 0;
  Self__0PC=upper__KHC;
  while ((Self__0PC >=  0)) {
    if (('\n' == Self__IHC[Self__0PC])) {
      count__UHC=(__INTEGER)(count__UHC +  1);
    };
    Self__0PC=(__INTEGER)(Self__0PC -  1);
  };
  return(count__UHC);
}

static void remove__0SF(__STRING *Self__1SF,__INTEGER index__2SF)
// ({STRING},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER __tmp__WEG,__tmp__XEG,Self__FKH;
  __CHARACTER *__tmp__KCS,*__tmp__LCS;
  __tmp__WEG=(__INTEGER)(index__2SF +  1);
  __tmp__XEG=Self__1SF->count__CB;
  Self__FKH=__tmp__WEG;
  __tmp__KCS=Self__1SF->storage__DGD;
  __tmp__LCS=Self__1SF->storage__DGD;
  while ((Self__FKH <= __tmp__XEG)) {
    ((__CHARACTER *)__tmp__LCS)[(__INTEGER)((__INTEGER)(Self__FKH -  1) -  1)]=((__CHARACTER *)__tmp__KCS)[(__INTEGER)(Self__FKH -  1)];
    Self__FKH=(__INTEGER)(Self__FKH +  1);
  };
  Self__1SF->count__CB=(__INTEGER)(Self__1SF->count__CB -  1);
}

static void resize__FHE(__STRING *Self__GHE,__INTEGER new_count__HHE)
// ({STRING},{INTEGER}) VoidNo recursive, No inlinable.
{
  if ((! (new_count__HHE <= Self__GHE->count__CB))) {
    if ((Self__GHE->capacity__GFD < new_count__HHE)) {
      if ((Self__GHE->capacity__GFD ==  0)) {
        Self__GHE->storage__DGD=create__LMH(new_count__HHE);
      } else {
        Self__GHE->storage__DGD=realloc__with__INH(Self__GHE->storage__DGD,Self__GHE->capacity__GFD,new_count__HHE);
      };
      Self__GHE->capacity__GFD=new_count__HHE;
    } else {
      clear__to__A2J(Self__GHE->storage__DGD,Self__GHE->count__CB,(__INTEGER)(new_count__HHE -  1));
    };
  };
  Self__GHE->count__CB=new_count__HHE;
}

static void move__to__by__BQF(__CHARACTER *Self__CQF,__INTEGER lower__DQF,__INTEGER upper__EQF,__INTEGER offset__FQF)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER},{INTEGER},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER Self__WXK,Self__FYK;
  if ((offset__FQF !=  0)) {
    if ((offset__FQF <  0)) {
      Self__WXK=lower__DQF;
      while ((Self__WXK <= upper__EQF)) {
        Self__CQF[(__INTEGER)(Self__WXK + offset__FQF)]=Self__CQF[Self__WXK];
        Self__WXK=(__INTEGER)(Self__WXK +  1);
      };
    } else {
      Self__FYK=upper__EQF;
      while ((Self__FYK >= lower__DQF)) {
        Self__CQF[(__INTEGER)(Self__FYK + offset__FQF)]=Self__CQF[Self__FYK];
        Self__FYK=(__INTEGER)(Self__FYK -  1);
      };
    };
  };
}

static __POINTER micro_alloc__table__lab__VBC(__UINTEGER_32 new_size__XBC,__POINTER ptr_table__YBC,__UINTEGER_32 lab_type__ZBC)
// ({UINTEGER_32},{POINTER},{UINTEGER_32}) With resultNo recursive, No inlinable.
{
  __POINTER next__3BC,result__1BC;
  next__3BC=((__POINTER )(NULL));
  result__1BC=((__POINTER *)ptr_table__YBC)[ 0];
  if ((result__1BC == (void *)NULL)) {
    result__1BC=new_lab__RTC(lab_type__ZBC);
    next__3BC=(void *)((unsigned long)result__1BC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )new_size__XBC)));
    ((__POINTER *)next__3BC)[ 0]=NULL;
    ((__POINTER *)ptr_table__YBC)[ 0]=next__3BC;
  } else {
    next__3BC=((__POINTER *)result__1BC)[ 0];
    if ((next__3BC == (void *)NULL)) {
      if (((__UINTEGER_32)((__UINTEGER_32)(((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)result__1BC - (unsigned long)begin_memory__SDC)))) &  4095) + (__UINTEGER_32)(new_size__XBC <<  1)) <=  4096)) {
        next__3BC=(void *)((unsigned long)result__1BC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )new_size__XBC)));
      } else {
        next__3BC=new_lab__RTC(lab_type__ZBC);
      };
      ((__POINTER *)next__3BC)[ 0]=NULL;
      ((__POINTER *)ptr_table__YBC)[ 0]=next__3BC;
    } else {
      ((__POINTER *)result__1BC)[ 0]=(void *)((unsigned long)((__POINTER *)next__3BC)[ 0] & (unsigned long)((__POINTER )(__INTEGER)(~  3)));
      result__1BC=next__3BC;
    };
  };
  return(result__1BC);
}

static __POINTER alloc_dynamic__31H(__UINTEGER_32 sz__51H)
// ({UINTEGER_32}) With resultNo recursive, No inlinable.
{
  __POINTER result__H2H;
  __UINTEGER_32 a__A5R,new_size__B2H,new_size2__E2H,a__F5R;
  __UINTEGER_32 new_size__D5R;
  result__H2H=((__POINTER )(NULL));
  a__A5R=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
  new_size__B2H=(__UINTEGER_32)((__UINTEGER_32)(sz__51H + a__A5R) & (__UINTEGER_32)(~ a__A5R));
  new_size2__E2H=(__UINTEGER_32)(new_size__B2H + ((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))));
  if ((new_size2__E2H <= ((__UINTEGER_32 )(MINIMUM_SIZE)))) {
    a__F5R=(__UINTEGER_32)(((__UINTEGER_32 )((__INTEGER )(sizeof(void *)))) -  1);
    new_size__D5R=(__UINTEGER_32)((__UINTEGER_32)(new_size2__E2H + a__F5R) & (__UINTEGER_32)(~ a__F5R));
    result__H2H=micro_alloc__table__lab__VBC(new_size__D5R,((__POINTER )(&(table_size[((__UINTEGER_32)(new_size__D5R / ((__UINTEGER_32 )((__INTEGER )(sizeof(void *))))))-1]))),new_size__D5R);
    ((__POINTER *)result__H2H)[ 0]=((__POINTER ) 3);
    result__H2H=(void *)((unsigned long)result__H2H - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )((__INTEGER )(sizeof(void *))))));
  } else {
    result__H2H=(void *)((unsigned long)((__POINTER )((__MEMORY *)search__VPI(new_size__B2H))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8)));
  };
  return(result__H2H);
}

static void print_positif__VEL(__INTEGER Self__WEL)
// ({INTEGER}) VoidRecursive, No inlinable.
{
  __INTEGER val__5EL;
  __CHARACTER Result__R3L;
  Result__R3L=((__CHARACTER )(((__INTEGER_8)(((__INTEGER_8 )(__INTEGER)(Self__WEL %  10)) + ((__INTEGER_8 )'0')))));
  val__5EL=(__INTEGER)(Self__WEL /  10);
  if ((val__5EL !=  0)) {
    print_positif__VEL(val__5EL);
  };
  fputc((int)(Result__R3L),stdout);
}

static void copy__to__size__SII(__POINTER src__UII,__POINTER dst__VII,__UINTEGER_32 sz__WII)
// ({POINTER},{POINTER},{UINTEGER_32}) VoidNo recursive, No inlinable.
{
  __INTEGER siz__ZII,Self__OTI;
  __POINTER *na_src__XII,*na_dst__YII;
  siz__ZII=((__INTEGER )sz__WII);
  siz__ZII=(__INTEGER)(siz__ZII / ((__INTEGER )(sizeof(void *))));
  na_src__XII=((__POINTER *)src__UII);
  na_dst__YII=((__POINTER *)dst__VII);
  Self__OTI=(__INTEGER)(siz__ZII -  1);
  while ((Self__OTI >=  0)) {
    na_dst__YII[Self__OTI]=na_src__XII[Self__OTI];
    Self__OTI=(__INTEGER)(Self__OTI -  1);
  };
}

static void to_busy__index__N4J(__MEMORY *Self__O4J,__UINTEGER_32 sz__P4J,__UINTEGER_32 idx__Q4J)
// ({MEMORY},{UINTEGER_32},{UINTEGER_32}) VoidNo recursive, No inlinable.
{
  __MEMORY *new__X4J,*Self__2OR;
  __UINTEGER_32 siz__R4J,new_size__U4J;
  new__X4J=NULL;
  delete_link_free__QNK(Self__O4J);
  siz__R4J=Self__O4J->size_and_id__5W;
  new_size__U4J=(__UINTEGER_32)(siz__R4J - sz__P4J);
  if ((new_size__U4J > (__UINTEGER_32)((__UINTEGER_32)(((__UINTEGER_32 )(MINIMUM_SIZE)) +  2) +  8))) {
    siz__R4J=sz__P4J;
    new__X4J=((__MEMORY *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__O4J) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )sz__P4J))));
    ((__MEMORY *)new__X4J)->previous_linear__4W=((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )Self__O4J) - (unsigned long)begin_memory__SDC))));
    ((__MEMORY *)new__X4J)->size_and_id__5W=(__UINTEGER_32)(new_size__U4J -  8);
    add_link_free__ARJ(new__X4J);
    if (((__UINTEGER_32)(((__MEMORY *)new__X4J)->size_and_id__5W &  2) !=  0)) {
      last_block[(idx__Q4J)] = (new__X4J);
    } else {
      Self__2OR=((__MEMORY *)new__X4J);
      ((__MEMORY *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__2OR) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__2OR->size_and_id__5W &  4294967292LU)))))->previous_linear__4W=((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )((__MEMORY *)new__X4J)) - (unsigned long)begin_memory__SDC))));
    };
  };
  Self__O4J->size_and_id__5W=(__UINTEGER_32)(siz__R4J |  1);
}

static __MEMORY* search__VPI(__UINTEGER_32 new_size__XPI)
// ({UINTEGER_32}) With resultNo recursive, No inlinable.
{
  __MEMORY *result__ZPI;
  result__ZPI=first_free__YQI;
  while ((((void *)result__ZPI != (void *)NULL) && ((__UINTEGER_32)(((__MEMORY *)result__ZPI)->size_and_id__5W &  4294967292LU) < new_size__XPI))) {
    result__ZPI=result__ZPI->next_free__AX;
  };
  if (((void *)result__ZPI == (void *)NULL)) {
    result__ZPI=new_page__2FF();
  };
  to_busy__index__N4J(result__ZPI,new_size__XPI,(__UINTEGER_32)(((__UINTEGER_32 )((unsigned int)((void *)((unsigned long)((__POINTER )((__MEMORY *)result__ZPI)) - (unsigned long)begin_memory__SDC)))) >>  26));
  return(result__ZPI);
}

static void add_link_free__ARJ(__MEMORY *Self__BRJ)
// ({MEMORY}) VoidNo recursive, No inlinable.
{
  Self__BRJ->next_free__AX=first_free__YQI;
  Self__BRJ->previous_free__BX=NULL;
  if (((void *)first_free__YQI != (void *)NULL)) {
    ((__MEMORY *)first_free__YQI)->previous_free__BX=Self__BRJ;
  };
  first_free__YQI=Self__BRJ;
}

static void delete_link_free__QNK(__MEMORY *Self__RNK)
// ({MEMORY}) VoidNo recursive, No inlinable.
{
  __MEMORY *prev__SNK,*next__TNK;
  prev__SNK=Self__RNK->previous_free__BX;
  next__TNK=Self__RNK->next_free__AX;
  if (((void *)prev__SNK == (void *)NULL)) {
    first_free__YQI=next__TNK;
  } else {
    ((__MEMORY *)prev__SNK)->next_free__AX=next__TNK;
  };
  if (((void *)next__TNK != (void *)NULL)) {
    ((__MEMORY *)next__TNK)->previous_free__BX=prev__SNK;
  };
}

static void clear__to__A2J(__CHARACTER *Self__B2J,__INTEGER lower__C2J,__INTEGER upper__D2J)
// ({NATIVE_ARRAYoExpanded_CHARACTERo},{INTEGER},{INTEGER}) VoidNo recursive, No inlinable.
{
  __INTEGER Self__QJK;
  Self__QJK=lower__C2J;
  while ((Self__QJK <= upper__D2J)) {
    Self__B2J[Self__QJK]='\0';
    Self__QJK=(__INTEGER)(Self__QJK +  1);
  };
}

static __POINTER new_lab__RTC(__UINTEGER_32 t__TTC)
// ({UINTEGER_32}) With resultNo recursive, No inlinable.
{
  __UINTEGER_32 idx__VTC,pv__2TC;
  __MEMORY *blc__YTC,*prev__ZTC,*Self__2SR;
  __POINTER result__0TC;
  __BOOLEAN __tmp__2UC;
  idx__VTC= 0;
  blc__YTC=NULL;
  prev__ZTC=NULL;
  pv__2TC= 0;
  while_do__UYC:
  {
    if ((idx__VTC < nb_page__DUC)) {
      blc__YTC=((__MEMORY *)(last_block[(idx__VTC)]));
      __tmp__2UC=(((__UINTEGER_32)(((__MEMORY *)blc__YTC)->size_and_id__5W &  4294967292LU) <  4096) || ((__UINTEGER_32)(((__MEMORY *)blc__YTC)->size_and_id__5W &  1) ==  1));
    } else {
      __tmp__2UC=FALSE__;
    };
    if (__tmp__2UC) {
      idx__VTC=(__UINTEGER_32)(idx__VTC +  1);
      goto while_do__UYC;
    };
  };
  if ((idx__VTC >= nb_page__DUC)) {
    blc__YTC=new_page__2FF();
  };
  ((__MEMORY *)blc__YTC)->size_and_id__5W=(__UINTEGER_32)(blc__YTC->size_and_id__5W -  4096);
  Self__2SR=((__MEMORY *)blc__YTC);
  result__0TC=((__POINTER )((__MEMORY *)(void *)((unsigned long)(void *)((unsigned long)((__POINTER )Self__2SR) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER ) 8))) - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )(__UINTEGER_32)(Self__2SR->size_and_id__5W &  4294967292LU))))));
  if (((__UINTEGER_32)(((__MEMORY *)blc__YTC)->size_and_id__5W &  4294967292LU) < ((__UINTEGER_32 )(MINIMUM_SIZE)))) {
    delete_link_free__QNK(blc__YTC);
    pv__2TC=blc__YTC->previous_linear__4W;
    if ((pv__2TC !=  4294967295LU)) {
      prev__ZTC=((__MEMORY *)(void *)((unsigned long)begin_memory__SDC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )pv__2TC))));
      ((__MEMORY *)prev__ZTC)->size_and_id__5W=(__UINTEGER_32)((__UINTEGER_32)(prev__ZTC->size_and_id__5W + blc__YTC->size_and_id__5W) +  8);
      last_block[(idx__VTC)] = (prev__ZTC);
    };
  };
  ((__POINTER *)result__0TC)[ 0]=((__POINTER )t__TTC);
  return((void *)((unsigned long)result__0TC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )((__INTEGER )(sizeof(void *)))))));
}

static __MEMORY* new_page__2FF()
// () With resultNo recursive, No inlinable.
{
  __POINTER mem__KYG;
  __UINTEGER_32 cap__HYG,old_size__5FF;
  __MEMORY *block__FGF;
  if ((capacity_max__GGF ==  0)) {
    mem__KYG=((__POINTER )(NULL));
    cap__HYG= 33554432;
    do {
      cap__HYG=(__UINTEGER_32)(cap__HYG <<  1);
      mem__KYG=((__POINTER )(malloc((cap__HYG))));
      if ((mem__KYG != (void *)NULL)) {
        free((mem__KYG));
      };
    } while ((! ((mem__KYG == (void *)NULL) || (cap__HYG ==  2147483648LU))));
    if ((mem__KYG == (void *)NULL)) {
      cap__HYG=(__UINTEGER_32)(cap__HYG >>  1);
    };
    capacity_max__GGF=cap__HYG;
    begin_memory__SDC=((__POINTER )(malloc((cap__HYG))));
  };
  old_size__5FF=(__UINTEGER_32)(nb_page__DUC <<  26);
  nb_page__DUC=(__UINTEGER_32)(nb_page__DUC +  1);
  if (((__UINTEGER_32)(old_size__5FF +  67108864) > capacity_max__GGF)) {
    print__PB((&__string_117));
    exit(( 1));
  };
  block__FGF=((__MEMORY *)(void *)((unsigned long)begin_memory__SDC - (unsigned long)(void *)((unsigned long)((__POINTER ) 0) - (unsigned long)((__POINTER )old_size__5FF))));
  block__FGF->previous_linear__4W= 4294967295LU;
  block__FGF->size_and_id__5W= 67108858;
  add_link_free__ARJ(block__FGF);
  last_block[((__UINTEGER_32)(nb_page__DUC -  1))] = (block__FGF);
  return(block__FGF);
}

//==========================//
// DEBUG MANAGER            //
//==========================//

void print_string(char *str) 
{ 
  while (*str!=0) {
    print_char(*str); 
    str++; 
  };
}  

