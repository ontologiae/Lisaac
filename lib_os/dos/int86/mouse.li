/***************************************************************************
*                      Isaac Object Operating System                       *
*                                Hyper Tree                                *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
***************************************************************************/
section HEADER

  - name    := MOUSE;
  
  - category:=MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Sonntag Benoit (bsonntag@loria.fr)";
  - comment     :="Mouse for DOS.";
  
  - external := `union REGS __in_mouse;`;
  
section INHERIT

  * parent_input:INPUT;
  
  * parent_window:AREA;
    
section PUBLIC

  - set x,y:INTEGER with left_new,right_new:BOOLEAN <-
  ( + tmp:USMALLINT;
    + x_new, y_new:INTEGER;
    
    y_new := y.max y_minimum.min y_maximum;
    x_new := x.max x_minimum.min x_maximum;
          
    tmp:=(p_end+1)&003h;
    buffer_event.item p_end.make x_new,y_new button left_new,right_new;

    (((tmp+2)&3)!=p_beg).if {
      p_end:=tmp;
    };
    
    get_event;
    
    // Update status.
    x_current:=x_new;
    y_current:=y_new;
    right:=right_new;
    left :=left_new;    
  );
  
section PUBLIC
  
  + x_minimum:INTEGER;
  + x_maximum:INTEGER;
  
  + y_minimum:INTEGER;
  + y_maximum:INTEGER;
  
  + x_current:INTEGER;
  + y_current:INTEGER; 
  
  + right:BOOLEAN;
  + left:BOOLEAN;
  
section PRIVATE
  
  + buffer_event:MAP_FIXED_ARRAY[EVENT_MOUSE];
  - p_beg:USMALLINT;  // Pointer on the buffer (beginning)
  - p_end:USMALLINT;  // Pointer on the buffer (end)
    
section PUBLIC
  
  //
  // Creation / Initialisation.
  //
  
  - make <-
  (
    //
    // Mouse hardware configuration.
    //
    //display_on;
    
    x_maximum := VIDEO.x_max;
    y_maximum := VIDEO.y_max;

    //
    // Software configuration.
    //
    buffer_event := MAP_FIXED_ARRAY[EVENT_MOUSE].create 4;
    0.to 3 do { j:INTEGER;
      buffer_event.item j.set_prev (buffer_event.item ((j-1)&3));
    };
    
    mask := FIXED_ARRAY[USHORTINT].create 16;
    make (INTERFACE.screen) from x_current,y_current size 16,16;
  );
  
  - get_event <-
  ( + p:INTEGER;
    + evt:EVENT_MOUSE;
    
    p := p_beg;
    { p != p_end }.while_do {
      evt := buffer_event.item p;
      (list_client.lower).to (list_client.upper) do { j:INTEGER;
	list_client.item j.receive (buffer_event.item p);
      };      
      p := (p + 1) & 03h;
    };    
  );
    
  - acknowledge <-
  (
    p_beg := (p_beg+1) & 03h;
  );
  
  - display_on <- `__in_mouse.w.ax=0x01; int386(0x33,&__in_mouse,&__in_mouse)`;

  - display_off <- `__in_mouse.w.ax=0x02; int386(0x33,&__in_mouse,&__in_mouse)`;
  
  - get_new_event <-
  ( + b,x,y:INTEGER;
    + new_r,new_l,is_move:BOOLEAN;
    
    `__in_mouse.w.ax=0x03; int386(0x33,&__in_mouse,&__in_mouse)`;
    b:=`__in_mouse.w.bx`:INTEGER;
    x:=`__in_mouse.w.cx`:INTEGER / 2;
    y:=`__in_mouse.w.dx`:INTEGER;
    new_l := (b & 01b) != 0;
    new_r := (b & 10b) != 0;
    (
      (is_move := (x != x_current) || {y != y_current}) || {new_l != left} || {new_r != right}
    ).if {
      (is_move).if {
	set_position x,y;
      };
      set x,y with new_l,new_r;
    };
  );
  
  //
  // Display.
  //
  
  // BSBS: A refaire avec une bitmap en dehors contenant le dessin avec une couleur de mask!!
  // Plus simple, plus puissant, plus rapide ! 
  
  + mask:FIXED_ARRAY[USHORTINT];

  - pixel_hard x,y:INTEGER color col:UINTEGER <-
  ( + m:USHORTINT;
    ? {x<16};
    ? {y<16};

    m:=mask.item y;
    m:=m | (1<<x);
    mask.put m to y;

    parent_window.pixel_hard x,y color col;
  );
  
  - line_h_hard x0,y0:INTEGER until x1:INTEGER color col:UINTEGER <-
  ( + m:USHORTINT;
    ? {x0<16};
    ? {y0<16};
    ? {x1<16};
    
    m:=mask.item y0;
    x0.to x1 do { xx:INTEGER;
      m:=m | (1<<xx);
    };
    
    mask.put m to y0;
    parent_window.line_h_hard x0,y0 until x1 color col;
  );

  - slave_pixel_hard x,y:INTEGER color col:UINTEGER <- 
  ( + m:USHORTINT;
    
    m:=mask.item y;
    ((m & (1<<x))=0).if {
      parent_window.pixel_hard x,y color col;
    };
  );
  
  - slave_line_h_hard x1,y:INTEGER until x2:INTEGER color col:UINTEGER <- 
  ( + m:USHORTINT;
    
    m:=mask.item y;
    x1.to x2 do { xx:INTEGER;
      ((m & (1<<xx))=0).if {
	parent_window.pixel_hard xx,y color col;
      };
    };
  );  
  
  - slave_line_h_hard x1,y:INTEGER until x2:INTEGER image line:BMP_LINE offset ofs:INTEGER <-
  ( + m:USHORTINT;
    + col:UINTEGER;
    + ofs_img:INTEGER;
    ofs_img := ofs;
    m:=mask.item y;
    x1.to x2 do { xx:INTEGER;
      ((m & (1<<xx))=0).if {
	col := line.get_color ofs_img;	
	parent_window.pixel_hard xx,y color col;
      };     
      ofs_img := ofs_img + 1;
    };
  );
  
  - draw x0,y0:INTEGER to x1,y1:INTEGER <-
  (
    clipping x0,y0 to x1,y1;
    
    color white;
    poly_move_to 1,1;
    poly_line_to 9,9;
    poly_line_to 6,9;
    poly_line_to 8,14;
    poly_line_to 5,14;
    poly_line_to 5,9;
    poly_line_to 1,9;    
    poly_move_to 1,1;    
    poly_trace;
    
    color red;
    line_v 0,0  until 10;
    line_h 1,10 until 4;
    line_v 4,11 until 15;
    line_h 5,15 until 9;
    line 9,15 to 7,10;
    line_h 7,10 until 10;
    line 1,0 to 10,9;
  );
  
  - get_object x,y:INTEGER :AREA <-
  (
    NULL
  );
 
  
  
  