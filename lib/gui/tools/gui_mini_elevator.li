/***************************************************************************
*                      Isaac Object Operating System                       *
*                             Isaac Library                                *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  + name        := GUI_MINI_ELEVATOR;
  
  - comment     := "Mini elevator plateform.";
  
  - category    := MICRO;
  
  - bibliography:= "http://IsaacOS.com";
  
  - author      := "Benoit Sonntag (bsonntag@loria.fr)";
  
section INHERIT
  
  * parent_gui:GUI;
  
section PRIVATE
  
  - length_mini:INTEGER <-
  ( + result:INTEGER;
    (is_vertical).if {
      result := height-2;
    } else {
      result := width-2;
    };
    result
  );
  
  - cursor_begin:INTEGER <-  
  ( 
    ((length_mini.to_real_16_16 /# length) *# cursor).to_integer + 1
  );
  
  - cursor_size:INTEGER <-
  ( + len,page:INTEGER;    
    len := length_mini;
    page := ((len.to_real_16_16 /# length) *# len).to_integer;
    (page >= len).if {
      page := len-1;
    };
    page
  );
  
  + is_vertical:BOOLEAN;

  + area:AREA;
    
section PUBLIC  
  
  - cursor:INTEGER <-
  ( + result:INTEGER;
    
    (is_vertical).if {
      result := - area.get_y_window;
    } else {
      result := - area.get_x_window;
    };
    result
  );
  
  - length:INTEGER <-
  ( + result:INTEGER;
    
    (is_vertical).if {
      result := area.height;
    } else {
      result := area.width;
    };
    result
  );
  
    
  //
  // Creation.
  //
  
  - create_h_for a:AREA :SELF <-
  ( + result:SELF;
        
    result:=clone;
    result.make_h_for a;
    
    result
  );

  - create_v_for a:AREA :SELF <-
  ( + result:SELF;
        
    result:=clone;
    result.make_v_for a;
    
    result
  );
  
  - make_v_for a:AREA <-
  (    
    is_vertical := TRUE;
    area := a;
    make_in INTERFACE at (-60),0 size 10,(a.parent.height+2) action NULL;
  );

  - make_h_for a:AREA <-
  (    
    is_vertical := FALSE;
    area := a;
    make_in INTERFACE at 0,(-60) size (a.parent.width+2),10 action NULL;
  );
  
  - is_necessary:BOOLEAN <- ((cursor != 0) || {length > length_mini});
    
  - show <-
  ( + p:AREA;
    (is_necessary).if {
      p := area.parent;    
      (is_vertical).if {      
	set_position (p.x_window + p.width+0),(p.y_window-1);
      } else {
	set_position (p.x_window-1),(p.y_window + p.height+0);    
      };
    };
  );
  
  - hide <-
  (
    (is_vertical).if {
      set_position (-60),0;
    } else {
      set_position 0,(-60); 
    };
  );
  
  //
  // Action.
  // 
  
  - receive msg:EVENT <-
  // 0000 : Nothing.
  // 0001 : In.
  // 0010 : Up page.
  // 0100 : Down pages.
  // 1000 : Cursor move.
  ( + mouse:EVENT_MOUSE;
    + win:AREA;    
    + new_stat:INTEGER;
    + is_action:BOOLEAN;
    + py1,py2,old_cursor,new_cursor:INTEGER;
    + mouse_d,mouse_p:INTEGER;
    + is_refresh:BOOLEAN;
    
    mouse ?= msg;
    (mouse != NULL).if {
      win := INTERFACE.get_object (mouse.x_current),(mouse.y_current);
      (is_vertical).if {
	mouse_d := mouse.dy;
	mouse_p := mouse.y_current - y_window;
      } else {
	mouse_d := mouse.dx;
	mouse_p := mouse.x_current - x_window;
      };
      ((stat & 1110b) = 0).if {
	// No press.
	(win != self).if {
	  new_stat := 0;	  
	  hide;
	  INTERFACE.receive msg;	  
	} else {	  
	  (mouse.left).if {	     
	    py1 := cursor_begin;
	    py2 := py1 + cursor_size;
	    new_stat := (
	      ((mouse_p < py1).to_numeric.to_integer << 1) |
	      ((mouse_p > py2).to_numeric.to_integer << 2)
	    );	    
	    (new_stat = 0).if {
	      // Moving.
	      new_stat := 1000b;
	    } else {
	      is_action := TRUE;
	    };	  
	  };
	  new_stat := new_stat | 0001b;
	};
      } else {
	// Press.
	(mouse.left).if {
	  new_stat  := stat;
	  is_action := TRUE;
	} else {
	  (win != self).if {
	    new_stat := 0;
	    INTERFACE.receive msg;
	  };
	};
      };
      (stat != new_stat).if {
	stat := new_stat;
	is_refresh := TRUE;
      };
      (is_action).if {
	new_cursor := old_cursor := cursor;	
	(((stat & 0010b) != 0) && {old_cursor != 0}).if {	  
	  new_cursor := (old_cursor - length_mini).max 0;
	};
	(((stat & 0100b) != 0) && {old_cursor < (length - length_mini)}).if {
	  new_cursor := (old_cursor + length_mini).min (length - length_mini);
	};
	(((stat & 1000b) != 0) && {mouse_d != 0}).if {	  
	  new_cursor := old_cursor+((length.to_real_16_16 /# length_mini) *# mouse_d).to_integer;
	  new_cursor := new_cursor.min (length - length_mini).max 0;
	};
	(new_cursor != old_cursor).if {
	  (is_vertical).if {
	    area.move 0,(old_cursor - new_cursor);
	  } else {
	    area.move (old_cursor - new_cursor),0;
	  };
	  is_refresh := TRUE;
	};
      };
      (is_refresh).if {
	refresh;
      };      
    };
  );
  
  //
  // Display.
  //
  
  - draw x0,y0:INTEGER to x1,y1:INTEGER <-
  ( + py1,py2,x2:INTEGER;
    
    clipping x0,y0 to x1,y1;
    
    //
    // Bar
    //
    (is_vertical).if {
      // Vertical
      x2 := x_max;
      border_in 0,0 to x2,y_max;      
      py1 := cursor_begin;
      py2 := py1 + cursor_size;      
      x2 := x2 - 1;
      rectangle_out 1,py1 to x2,py2 color color_back;
      (py1 > 1).if {
	rectangle_fill 1,1 to x2,(py1-1) color color_back_light;
      };
      (py2 < (y_max-1)).if {
	rectangle_fill 1,(py2+1) to x2,(y_max-1) color color_back_light;
      };
    } else {
      // Horizontal
      x2 := y_max;
      border_in 0,0 to x_max,x2;      
      py1 := cursor_begin;
      py2 := py1 + cursor_size;      
      x2 := x2 - 1;
      rectangle_out py1,1 to py2,x2 color color_back;
      (py1 > 1).if {
	rectangle_fill 1,1 to (py1-1),x2 color color_back_light;
      };
      (py2 < (x_max-1)).if {
	rectangle_fill (py2+1),1 to (x_max-1),x2 color color_back_light;
      };      
    };    
  );
  
  




