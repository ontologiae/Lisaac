/***************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  * name        := DOUBLE;
  
  - comment     := "Float (C `double' mapping).";
  
  - category    := MICRO;
  
  - bibliography:= "http://IsaacOS.com";
  - author      := "Benoit Sonntag (bsonntag@loria.fr)";
  
  - type        := `double`;
  - default     := 0;
  
  - external := `#include <math.h>`; // BSBS (a virer:)
  
section INHERIT
  
  - parent_signed:SIGNED := SIGNED;
  
section PUBLIC
  
  - object_size:INTEGER := 8;
  
  //
  // Range.
  //
  
  
  //
  // Convertion format with test.
  //
  
  - to_ulongint:ULONGINT   <- 
  ( ? {in_range 0 to (ULONGINT.maximum)};
    floor.to_ulongint
  );
  
  - to_uinteger:UINTEGER   <- 
  ( ? {in_range 0 to (UINTEGER.maximum)};
    floor.to_uinteger
  );
  
  - to_ushortint:USHORTINT <- 
  ( ? {in_range 0 to (USHORTINT.maximum)};
    floor.to_ushortint
  );
  
  - to_usmallint:USMALLINT <- 
  ( ? {in_range 0 to (USMALLINT.maximum)};
    floor.to_usmallint
  );
  
  - to_longint:LONGINT     <- 
  ( ? {in_range (LONGINT.minimum) to (LONGINT.maximum)};
    floor
  );
  
  - to_integer:INTEGER     <- 
  ( 
    floor.to_integer
  );
  
  - to_shortint:SHORTINT   <- 
  ( ? {in_range (SHORTINT.minimum) to (SHORTINT.maximum)};
    floor.to_shortint
  );
  
  - to_smallint:SMALLINT   <- 
  ( ? {in_range (SMALLINT.minimum) to (SMALLINT.maximum)};
    floor.to_smallint
  );
    
  - floor:INTEGER <-
  // Greatest integral value no greater than Current.
  ( + result:INTEGER;
    
    result:=to_raw_integer;
    //? {self <= result.to_real_16_16};
    //? {(self - result.to_real_16_16) < 1};
    result
  );
  
  - ceiling:INTEGER <-
  // Smallest integral value no smaller than Current.
  ( + result:INTEGER;
    
    result:=`(int)ceil(@self)`:INTEGER;
    //? {self >= result.to_real_16_16};
    //? {(self - result.to_real_16_16) < 1};
    result
  );
  /*
  - rounded:INTEGER <-
  // Rounded integral value.
  (
    (to_raw_integer+32768) >> 16
  );
  */
  - truncated_to_integer:INTEGER <- floor;
  // Integer part (largest absolute value no greater than Current).
  
  //
  // binary operator :
  //
  
  //
  // Test binary operator :
  //
  
  //
  // Convertion
  //
  
  - append_in buffer:STRING <- 
  // Append in the `buffer' the equivalent of `to_string'. No new STRING
  // creation during the process.
  ( + val:INTEGER;
    //+ old_count,new_count:INTEGER;
    ? {buffer!=NULL};
    
    val := self.to_raw_integer;
    
    (val < 0).if {
      val := - val;
      buffer.extend '-';
    };
    val.append_in buffer;
    buffer.extend '.';
    buffer.extend 'x';
/*
    old_count:=buffer.count;
    //     1/65536 = 0.00390625 => 8 digit.
    (((val & 0FFFFh).to_ulongint * 100000000)>>16).to_integer.append_in buffer;
    new_count:=old_count+8;
    {buffer.count!=new_count}.while_do {
      buffer.insert '0' to old_count;
    };
*/
  );
  
  //  
  // A REFAIRE en mieux ...
  //
  
  - pi:SELF <- `3.14159265358979323846`:SELF;
  
  - atan:SELF <- `atan(@self)`:SELF;
  
  - sqrt:SELF <- `sqrt(@self)`:SELF;
  
  - log:SELF <- `log(@self)`:SELF;
  
  - sin:SELF <- `sin(@self)`:SELF;
  
  - cos:SELF <- `cos(@self)`:SELF;
  
  
  
  
  
  
  
  
