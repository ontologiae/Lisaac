Section Header
  
  + name := PAPER;

  - external := `
#include <jni.h>
#include <EGL/egl.h>
//#include <GLES/gl.h>
#include <GLES3/gl3.h>
#include <GLES3/gl3ext.h>

#include <string.h>
#include <pthread.h>

#include <android/log.h>
#include <android_native_app_glue.h>

#define LOG_TAG ("LIA")
#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__))
#define signal(x,y) 

int stop;

void delete_in(void *);
void draw_in(void *);
void init_gl(void *);
void init_pen(void *);
void *run_in(void *);
void mouse_action(void *,long,long,long,long);
int main(int,char **);

struct engine {
  struct android_app* app;
  void *pen;
  void *appli;
  int stat;

  EGLDisplay display;
  EGLSurface surface;
};

const EGLint attribs[] = {
  EGL_BLUE_SIZE,       8,
  EGL_GREEN_SIZE,      8,
  EGL_RED_SIZE,        8,
  EGL_ALPHA_SIZE,      8,
  EGL_DEPTH_SIZE,     16,
  EGL_STENCIL_SIZE,    8,
  EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
  EGL_NONE
};
const EGLint contextAttribs[] = {
  EGL_CONTEXT_CLIENT_VERSION, 2,
  EGL_NONE
};

void cmd_android(struct android_app* app, int32_t cmd)
{
  struct engine* e = (struct engine *)(app->userData);  
#define PRT(x) 
  switch (cmd) {
    case APP_CMD_INIT_WINDOW:   LOGI("--> Init win \n");
    e->stat = 0;
    break;
    case APP_CMD_SAVE_STATE:    PRT(LOGI("--> Save state \n")); break;
    case APP_CMD_INPUT_CHANGED: PRT(LOGI("--> Input changed \n")); break;
    case APP_CMD_TERM_WINDOW:   PRT(LOGI("--> Term win. \n")); break;
    case APP_CMD_RESUME:        PRT(LOGI("--> Resume \n")); break;
    case APP_CMD_START:         PRT(LOGI("--> Start \n")); /*e->stat &=~0b101;*/ break;
    case APP_CMD_PAUSE:         PRT(LOGI("--> Pause \n")); e->stat |= 0b100; break;
    case APP_CMD_STOP:          PRT(LOGI("--> Stop \n")); break;
    case APP_CMD_CONFIG_CHANGED:PRT(LOGI("--> Config changed \n")); /*e->stat = 0;*/ break;
    default:
    //LOGI("--> %d\n",cmd);
    break;
  }
}

static int32_t input_android(struct android_app* app,AInputEvent* event)
{ int32_t key;
  int idx,x,y,mouse_id;
  float cx,cy;
    
  if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_MOTION) {
    key = AMotionEvent_getAction(event);
    idx = (key & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >> 
    AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;    
    cx = 320.0/ANativeWindow_getWidth(app->window);
    //AMotionEvent_getXPrecision(event);
    cy = cx;
    //AMotionEvent_getYPrecision(event);
    switch (key & AMOTION_EVENT_ACTION_MASK) {
      case AMOTION_EVENT_ACTION_DOWN: 
        x = (int)((float)AMotionEvent_getRawX(event,0) / cx);
        y = (int)((float)AMotionEvent_getRawY(event,0) / cy);
        
        //LOGI("size = %f %f\n",AMotionEvent_getAxisValue(event,0,0),cy);
        mouse_action (app->userData,0,1,x,y);
        break;    
      case AMOTION_EVENT_ACTION_POINTER_DOWN:         
        x = (int)((float)AMotionEvent_getRawX(event,idx) / cx);
        y = (int)((float)AMotionEvent_getRawY(event,idx) / cy);
        mouse_id = AMotionEvent_getPointerId(event,idx);
        //LOGI("id ptr dwn = %d\n",mouse_id);
        if ((mouse_id>=0) && (mouse_id<10)) { 
          mouse_action (app->userData,mouse_id,1,x,y);        
        };
        break;
      case AMOTION_EVENT_ACTION_UP: 
        x = (int)((float)AMotionEvent_getRawX(event,0) / cx);
        y = (int)((float)AMotionEvent_getRawY(event,0) / cy);
        //LOGI("scr %f %f\n",AMotionEvent_getXPrecision(event),AMotionEvent_getYPrecision(event));
        mouse_id = AMotionEvent_getPointerId(event,0);
        //LOGI("id up = %d\n",mouse_id);        
        if ((mouse_id>=0) && (mouse_id<10)) { 
          mouse_action (app->userData,mouse_id,0,x,y);
        };
        break;    
      case AMOTION_EVENT_ACTION_POINTER_UP: 
        x = (int)((float)AMotionEvent_getRawX(event,idx) / cx);
        y = (int)((float)AMotionEvent_getRawY(event,idx) / cy);
        //LOGI("scr %d %d\n",x,y);
        mouse_id = AMotionEvent_getPointerId(event,idx);
        //LOGI("id ptr up = %d\n",mouse_id);        
        if ((mouse_id>=0) && (mouse_id<10)) { 
          mouse_action (app->userData,mouse_id,0,x,y);        
        };
        break;
      case AMOTION_EVENT_ACTION_MOVE:        
        for (idx=0;idx<AMotionEvent_getPointerCount(event);idx++) {
          mouse_id = AMotionEvent_getPointerId(event,idx);           
          x = (int)((float)AMotionEvent_getRawX(event,idx) / cx);
          y = (int)((float)AMotionEvent_getRawY(event,idx) / cy);          
          if ((mouse_id>=0) && (mouse_id<10)) { 
            mouse_action (app->userData,mouse_id,-1,x,y);                    
          };
        };  
        break;
      case AMOTION_EVENT_ACTION_OUTSIDE: 
      case AMOTION_EVENT_ACTION_CANCEL: 
        break;
    };
  }
  return 0;
}

void android_main(struct android_app* state) {
  struct engine e;
  pthread_t t;
  if (state->userData != NULL) return;
  state->userData = &e;
  state->onAppCmd = cmd_android;
  state->onInputEvent = input_android;
  e.app = state;  
  main(0,NULL);  
  e.pen = NULL;
  e.stat = 0b100;
  LOGI("Create Thread\n");
  pthread_create(&t,NULL,run_in,&e);          
  while (1) {
    int ident, events;
    struct android_poll_source* source;
    while ((ident=ALooper_pollAll(0, NULL, &events, (void**)&source)) >= 0) {
      if (source != NULL) {        
	source->process(state, source);
      }
      //  LOGI("++> %d\n",events);
      if (state->destroyRequested != 0) {
        e.stat |= 0b1000;        
        LOGI("Exit\n");
        pthread_join(t,NULL);
        
	return;
      }
    }
  }
}
`;
  
Section Inherit
  
  - parent_constant_pen:CONSTANT_PEN := CONSTANT_PEN;
  
Section Private
  
  - lisaac_app:PAPER;
  - back_r:REAL_32;
  - back_g:REAL_32;
  - back_b:REAL_32;
  - back_a:REAL_32;
  
Section Public
  
  - make (w,h:INTEGER) color c:COLOR title t:STRING_ALIAS <-
  (
    back_r := c.r;
    back_g := c.g;
    back_b := c.b;
    back_a := c.a;
  );
  
  - make (w,h:INTEGER) title t:STRING_ALIAS <-
  (
    back_r := back_g := 0.3;
    back_b := 0.32;
    back_a := 1.0;    
  );
  
  - run app:CONSTANT_PEN <- 
  ( 
    lisaac_app ?= app;
  );
  
  - draw p:PEN <- ( deferred; );
  
Section External
  
  - run_in e:POINTER :NULL <-
  ( + pen:PEN;
    + state:INTEGER;
    `struct engine* e=@e`;                
    "Run...\n".print;    
    {
      state := `e->stat`:INTEGER;
      ((state & 0101b) = 0).if {
        init_gl e;
      }.elseif {(state & 0110b) = 0} then {
        init_pen e;        
      }.elseif {state = 0011b} then {
        draw_in(e);
      };
    }.do_while {(state&01000b) = 0};
    "End draw.\n".print;
    pen := get_pen e;    
    pen.delete;
    `e->pen = NULL`;
    `e->stat = 0`;
    NULL
  );
  
  - init_gl e:POINTER <-
  ( + wt,ht:INTEGER;
    + w_scr,h_scr:INTEGER;
    
    "Init gl\n".print;
    
    `struct engine* e=@e`;
    `EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY)`;
    `eglInitialize(display, 0, 0)`;
    `EGLConfig config`;
    `EGLint numConfigs`;
    `eglChooseConfig(display, attribs, &config, 1, &numConfigs)`;
    `EGLint format`;

    `eglGetConfigAttrib(display, config, EGL_NATIVE_VISUAL_ID, &format)`;
    `ANativeWindow_setBuffersGeometry(e->app->window, 0, 0, format)`;
  
    `EGLSurface surface = eglCreateWindowSurface(display, config, e->app->window, NULL)`;
    `EGLContext context = eglCreateContext(display, config, EGL_NO_CONTEXT, contextAttribs)`;
   // `setContentView(&surface)`;
    `eglMakeCurrent(display, surface, surface, context)`;
    `e->display = display`;
    `e->surface = surface`;
    
    `EGLint w, h`;
    `eglQuerySurface(display, surface, EGL_WIDTH,  &w)`;
    `eglQuerySurface(display, surface, EGL_HEIGHT, &h)`;
    `glViewport(0, 0, w, h)`;    
    `eglSwapInterval(display, 0)`;
    
    /*
    `
    EGLint r,g,b,a,i,m,s;
    eglGetConfigAttrib(display, config, EGL_RED_SIZE,   &r);
    eglGetConfigAttrib(display, config, EGL_GREEN_SIZE, &g);
    eglGetConfigAttrib(display, config, EGL_BLUE_SIZE,  &b);
    eglGetConfigAttrib(display, config, EGL_ALPHA_SIZE, &a);
    eglGetConfigAttrib(display, config, EGL_MIN_SWAP_INTERVAL,&i);
    eglGetConfigAttrib(display, config, EGL_MAX_SWAP_INTERVAL,&m);
    eglGetConfigAttrib(display, config, EGL_STENCIL_SIZE,&s);
    LOGI("%d %d %d %d %d %d s=%d\n",r,g,b,a,i,m,s);
    `;
    */
   
    wt := `w`:INTEGER;
    ht := `h`:INTEGER;    
    //`ANativeWindow nativeWindow = ANativeWindow_fromSurface(env, surface)`;
    w_scr := `ANativeWindow_getWidth(e->app->window)`:INTEGER;
    h_scr := `ANativeWindow_getHeight(e->app->window)`:INTEGER;
    /*
    // look up motion range for this device
        _look_up_motion_range((int) AInputEvent_getDeviceId(event),
            (int)AInputEvent_getSource(event), &ev.motionMinX, &ev.motionMaxX,
&ev.motionMinY, &ev.motionMaxY);*/

    "Surface: ".print; wt.print;    'x'.print; ht.print;    '\n'.print;    
    "Window : ".print; w_scr.print; 'x'.print; h_scr.print; '\n'.print;    
    `e->stat |= 0b001`;
  );
  
  - init_pen e:POINTER <-
  ( + pen:PEN;
    `struct engine* e=@e`;
    pen := get_pen e;    
    "Init Pen\n".print;
    PEN_GL.init (antialias | stencil_strokes | debug);
    pen := PEN.create; 
    `e->pen=@pen`;
    `e->stat |= 0b010`;
  );
    
  - draw_in e:POINTER <-
  ( + wt,ht:INTEGER;
    + pen:PEN;
    + rl,gl,bl,al:REAL_32;
    
    `struct engine* e=@e`;    
    `int w,h`;
    `eglQuerySurface(e->display, e->surface, EGL_WIDTH,  &w)`;
    `eglQuerySurface(e->display, e->surface, EGL_HEIGHT, &h)`;
    wt := `w`:INTEGER;
    ht := `h`:INTEGER;    
    pen := `e->pen`:PEN;
    
    pen.set_size (wt,ht);
    
    // Update and render
    `glViewport(0, 0, w, h)`;
    (rl,gl,bl,al) := (back_r,back_g,back_b,back_a);
    `glClearColor(@rl,@gl,@bl,@al)`;
    `glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)`;
    
    PEN_GL.gl_enable (`GL_BLEND`:INTEGER);
    PEN_GL.gl_blend_func (`GL_SRC_ALPHA`:INTEGER,`GL_ONE_MINUS_SRC_ALPHA`:INTEGER);
    PEN_GL.gl_enable (`GL_CULL_FACE`:INTEGER);
    PEN_GL.gl_disable (`GL_DEPTH_TEST`:INTEGER);
    
    pen.begin_frame (wt,ht) ratio 1.0;
    
    lisaac_app.draw pen;
    //TEST2D.draw pen;
    
    pen.restore;
    pen.end_frame;    
    `glEnable(GL_DEPTH_TEST)`;
    `eglSwapBuffers(e->display, e->surface)`;
    COLOR.stack.clear;        
  );
  
  - mouse_action (e:POINTER,n,s,x,y:INTEGER) <-
  ( + pen:PEN;    
    + ofs:INTEGER;
    pen := get_pen e;
    (pen != NULL).if {
      ofs := n*3;
      (s != -1).if {
        pen.mouse.put s to (ofs+0);
      };
      pen.mouse.put x to (ofs+1);
      pen.mouse.put y to (ofs+2);    
    };
  );
  
Section Private
  
  - get_pen e:POINTER :PEN <-
  ( + pen:PEN;
    + ptr:POINTER;
    `{ struct engine* e=@e`;    
    ptr := `e->pen`:POINTER;
    `}`;
    (ptr.is_null).if_false {
      pen := CONVERT(POINTER,PEN).on ptr;  
    };
    pen
  );
      