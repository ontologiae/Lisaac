Section Header

  + name      := SLIM_ARRAY E; // BSBS: A mettre en Expanded.

  - comment   := "The main prototype";

Section Insert

  - parent_object:OBJECT := OBJECT;

Section Private

  // Champs internes :
  // Capacité et compteur d'éléments présents
  + capacity:INTEGER;
  + counter:INTEGER;

  // Utilisé comme first et tableau
  + array:NATIVE_ARRAY E;

  // MHMH :
  // Une capacité à 0 signifie que l'on utilise array comme stockage.

Section Public

  //
  // Informations :
  //

  // Borne inférieure :
  // MHMH : Version originale... en fonction ?? - lower:INTEGER <- 0;
  - lower:INTEGER := 0;

  // Borne supérieure :
  - upper:INTEGER <- (counter - 1);

  // Nombre d'éléments :
  - count:INTEGER <- (counter);

  // Test de vacuité :
  - is_empty:BOOLEAN <- ( counter = 0 );


  //
  // Création/Initialisation :
  //
  
  - create_with_capacity n:INTEGER :SELF <-
  ( + result:SELF;
    result := clone;
    result.make_with_capacity n;
    result
  );
  
  - make_with_capacity n:INTEGER <-
  (
    // Réinitialisation :
    capacity := 0;
    counter := 0;
    array := NULL;

    // Allocation si nécessaire :
    (n > 1).if
    {
      array := NATIVE_ARRAY E .create n;
      capacity := n;
    };
  );

  //
  // Accès en lecture :
  //

  - first:E <-
  (
    + return:E;

    (capacity = 0).if
    { return := CONVERT(NATIVE_ARRAY E, E).on array; }
    else
    { return := array.item 0; };

    return
  );

  - last:E <-
  (
    + return:E;

    (capacity = 0).if
    { return := CONVERT(NATIVE_ARRAY E, E).on array; }
    else
    { return := array.item upper; };

    return
  );

  - item i:INTEGER:E <-
  (
    + return:E;

    (capacity = 0).if
    { return := CONVERT(NATIVE_ARRAY E, E).on array; }
    else
    { return := array.item i;};

    return
  );

  //
  // Accès en lecture :
  //

  - put e:E to i:INTEGER <-
  (
    (capacity = 0).if
    { array := CONVERT(E, NATIVE_ARRAY E).on e; }
    else
    { array.put e to i;};
  );

  - add_last e:E <-
  (
    (capacity = 0).if
    {
      (counter = 0).if
      {
        array := CONVERT(E, NATIVE_ARRAY E).on e;
        counter := counter + 1;
      }
      else
      {
        + tmp:E;
        // Sauvegarde élément courant :
        tmp := CONVERT(NATIVE_ARRAY E, E).on array;
        // Création tableau :
        array := NATIVE_ARRAY E .create 4;
        capacity := 4;
        counter := 2;
        // Restauration éléments :
        put tmp to 0;
        put e to 1;
      };
    }
    else
    {
      // Allocation de place supplémentaire si besoin :
      (counter = capacity).if
      {
        + new_cap:INTEGER;
        new_cap := capacity*2;
        array := array.realloc capacity with new_cap;
        capacity := new_cap;
      };
      counter := counter+1;
      put e to upper;
    };
  );








  // MHMH : remplacé par utilisation de list
  // + first:E;

  /*
  - last:E <-
  ( + result:E;
    (list != NULL).if {
      result := list.last;
    } else {
      result := first;
    };
    result
  );
  */


  /*
  - upper:INTEGER <-
  ( + result:INTEGER;
    (first = NULL).if {
      result := -1;
    }.elseif {list != NULL} then {
      result := list.count;
    };
    result
  );
  */

  /*
  - count:INTEGER <- upper + 1;
  */

  /*
  - is_empty:BOOLEAN <- first = NULL;
  */

  /*
  - item i:INTEGER :E <-
  ( + result:E;

    (i = 0).if {
      result := first;
    } else {
      result := list.item (i-1);
    };
    result
  );
  */

  /*
  - put e:E to i:INTEGER <-
  (
    (i = 0).if {
      first := e;
    } else {
      list.put e to (i-1);
    };
  );
  */

  /*
  - add_last e:E <-
  (
    (first = NULL).if {
      first := e;
    } else {
      (list = NULL).if {
        list := ARRAY E .create_with_capacity 4;
      };
      list.add_last e;
    };
  );
*/
