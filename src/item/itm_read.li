Section Header

  + name    := ITM_READ;

  - comment := "For local access variable or send message without argument";

  // BSBS: Optim: Penser à faire un ITM_READ_ARG3 pour tous les `if then else'

Section Inherit

  + parent_itm_code:Expanded ITM_CODE;

Section Public

  - is_affect:POSITION; // Nothing (it's good with 0).

  //
  // Data
  //

  + name:STRING_ALIAS;

  //
  // Constructor
  //

  - create p:POSITION name n:STRING_ALIAS :SELF <-
  ( + result:SELF;
    result := clone;
    result.make p name n;
    result
  );

  - make p:POSITION name n:STRING_ALIAS <-
  (
    position := p;
    name := n;
  );

  //
  // Runnable
  //

  - to_run_expr:EXPR <-
  ( + result:EXPR;
    + loc:LOCAL;

    loc := lookup name;
    (loc != NULL).if {
      //
      // Local Access.
      //
      (loc.style = '-').if {
	loc.set_ensure_count 1;
	name := loc.intern_name;
	result := to_run_with NULL args NULL;
      } else {
	result := loc.read position;
      };
    } else {
      //
      // Slot Access without argument.
      //
      result := to_run_with NULL args NULL;
    };
    result
  );

  //
  // Display.
  //

  - append_in buffer:STRING_BUFFER <-
  (
    buffer.append name;
    buffer.append "()";
  );

Section ITM_READ, SLOT_DATA

  - to_run_with first_itm:ITM_CODE args larg:ARRAY ITM_CODE :EXPR <-
  ( + rec:EXPR;
    + itm_list:ITM_LIST;
    + itm_read:ITM_READ;
    + is_resend,implicit_self:BOOLEAN;

    (first_itm = NULL).if {
      // Implicit Self.
      rec := lookup "Self".read position;
      implicit_self := TRUE;
    } else {
      rec := first_itm.to_run_expr;
      // Resend detect.
      itm_list ?= first_itm;
      (itm_list != NULL).if {
        (itm_list.code.is_empty).if {
          syntax_error (itm_list.position,"Instruction list is empty.");
        };
	itm_read ?= itm_list.code.first;
      } else {
	itm_read ?= first_itm;
      };
      is_resend := (
	(itm_read != NULL) &&
	{position.prototype.search_parent (itm_read.name)}
      );
    };
    to_run_with_self (rec,implicit_self,is_resend) args larg
  );

  - to_run_with_self (r:EXPR,implicit_self,is_resend:BOOLEAN) args larg:ARRAY ITM_CODE :EXPR <-
  ( + args,args2:ARRAY EXPR;
    + rec_type:TYPE;
    + slot_msg:SLOT;
    + rec,e:EXPR;        
    + base:NODE;
        
    args := ALIAS_ARRAY EXPR.new;
    rec := r.first;
    rec_type := rec.static_type.raw;
    (is_resend).if { e := lookup "Self".read position; } 
    else           { e := rec.my_copy; };    
    args.add_last (r.my_copy_with_first e);        
    (larg != NULL).if {
      (larg.lower).to (larg.upper) do { j:INTEGER;
	args.add_last (larg.item j.to_run_expr);
      };
    };      
    //
    ((rec_type.is_block) && {name = "value"}).if { 
      // { ... }.value      
      (args.last.static_type.is_list).if {
        1.to 2 do { i:INTEGER;
          base := NODE.new_block position receiver rec with args;
          list_current.add_last base;
          rec := rec.my_copy;
          args2 := ALIAS_ARRAY EXPR .new;
          (args.lower).to (args.upper) do { j:INTEGER;
            args2.add_last (args.item j.my_copy);
          };
          args := ALIAS_ARRAY EXPR .copy args2;
        };
        base := NODE.new_block position receiver rec with args;
      } else {
        base := NODE.new_block position receiver rec with args;
      };
    } else {            
      slot_msg := rec_type.get_slot name for larg in args;      
      (args.count = 1).if {
        rec.remove; // BSBS: Nid à emmerde !!!
        base := NODE.new_read position slot slot_msg
        receiver rec self (args.first) intern implicit_self;
        ALIAS_ARRAY EXPR.free args;
      } else {                
        args := ALIAS_ARRAY EXPR .copy args;
        base := NODE.new_read position slot slot_msg
        receiver rec with args intern implicit_self;
      };
      // Verification
      //verify (rec,rec_type) slot slot_msg with (larg,args)      
    };    
    list_current.add_last base;

    (larg != NULL).if { ALIAS_ARRAY ITM_CODE .free larg; };

    ? {base.result_expr != NULL};
    base.result_expr
  );

Section Private
/*
  - add_arg e:EXPR to idx:INTEGER in args:ARRAY EXPR <-
  ( + em:EXPR_MULTIPLE;
    + count:INTEGER;

    em ?= e;
    (em != NULL).if {
      count := em.cardinality;
      args.append_collection (em.expr_list);
    } else {
      count := 1;
      args.add_last e;
    };    
    );  
  */  
    
  - verify (rec:EXPR,rec_type:TYPE) slot slot_msg:SLOT with (larg:ARRAY ITM_CODE,args:ARRAY EXPR) <-
  ( //+ itm_arg:ITM_ARGUMENT;
    
    (verify).if {        
      ((args.count = 1) && {is_all_warning} && {name = "deferred"}).if {
        string_tmp.copy "Deferred in `";
        profil_slot.slot.pretty_name_in string_tmp;
        string_tmp.append "' for ";
        rec.static_type.append_name_in string_tmp;
        warning_error (position,string_tmp);
      };        
      (slot_msg = NULL).if {                
        string_tmp.copy "Slot `";
        string_tmp.append name;
        string_tmp.append "' not found in `";
        rec_type.append_name_in string_tmp;
        string_tmp.append "'.";
        semantic_error (position,string_tmp);
      };      
      (
        ((larg  = NULL) && {slot_msg.argument_list.count != 1}) ||
        {(larg != NULL) && {larg.count+1 != slot_msg.argument_list.count}} 
      ).if {          
        POSITION.put_error semantic text "Incorrect number argument.";
        slot_msg.position.put_position;
        position.put_position;
        POSITION.send_error;
      };
      last_position := slot_msg.position;
      (
        (profil_slot != NULL) &&
        {! slot_msg.id_section.access rec_type with (profil_slot.type_self.raw)}
      ).if {
        string_tmp.copy "Type ";
        profil_slot.type_self.append_name_in string_tmp;
        string_tmp.append " does not have access to this slot.";
        POSITION.put_error warning text string_tmp;
        slot_msg.position.put_position;
        position.put_position;
        POSITION.send_error;
      };              
      /*
      0.to (slot_msg.argument_list.upper) do { i:INTEGER;
        itm_arg := slot_msg.argument_list.item i;        
        ((itm_arg.count != args.item (i-1).cardinality) && {! itm_arg.item 0.is_list}).if {
          string_tmp.copy "Incorrect vector size for #";
          i.append_in string_tmp;
          string_tmp.append " argument of `";
          string_tmp.append name;
          string_tmp.append "' slot. (slot #";
          itm_arg.count.append_in string_tmp;
          string_tmp.append ", call #";
          args.item (i-1).cardinality.append_in string_tmp;
          string_tmp.add_last ')';
          POSITION.put_error semantic text string_tmp;
          itm_arg.position.put_position;
          args.item i.position.put_position;
          POSITION.send_error;
        };
      };*/
    };
  );