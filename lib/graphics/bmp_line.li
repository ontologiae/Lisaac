/***************************************************************************
*                      Isaac Object Operating System                       *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  + name        := BMP_LINE;
  
  - comment     := "Generic bitmap line";
  
  - category    := MICRO;
  
  - bibliography:= "http://IsaacOS.com";
  - author      := "Benoit Sonntag (bsonntag@loria.fr), Jerome Boutet (boutet@loria.fr)";

section INHERIT
  
  - parent_arrayed:ARRAYED := ARRAYED;
  
section PUBLIC
  
  - lower:INTEGER := 0;
  
  + upper:INTEGER;
  
  + capacity:INTEGER;
  
  - count:INTEGER <- (upper + 1);
  
  //
  // Creation.
  //
  
  - create n:INTEGER :SELF <-
  ( + result:SELF;
    ? {n>0};
    
    result:=clone;
    result.make n;
    
    ? {result.count    = n};
    ? {result.capacity = n};
    result
  );

  - create_with_capacity n:INTEGER :SELF <- 
  // Warning : Not storage copy.
  ( + result:SELF;
    
    result:=clone;
    result.make_with_capacity n;
    
    ? {result.count    = 0};
    ? {result.capacity = n};
    result
  );
  
  - create n:INTEGER at offset:UINTEGER :SELF <- 
  // Warning : Not storage copy.
  ( + result:SELF;
    
    result:=clone;
    result.make n at offset;
    
    ? {result.count    = n};
    ? {result.capacity = n};
    result
  );
  
  //
  // Modification
  //
  
  - clear <-
  (
    upper := -1;
  );
   
  //
  // Put.
  //
  
  - put col:UINTEGER to n:INTEGER <-
  ( ? {n.in_range 0 to upper};    
    item n.color col;    
  );
  
  - put col:UINTEGER from idx_begin:INTEGER to idx_end:INTEGER <-   
  (  
    deferred;
  );
  
  - put bmp:BMP_LINE offset ofs:INTEGER from idx_begin:INTEGER to idx_end:INTEGER <-
  (
    deferred;
  );
  
  //
  // Get.
  //
  
  - get_color n:INTEGER :UINTEGER <-
  ( ? {n.in_range 0 to upper};    
    item n.rgbcolor
  );
  
  - item n:INTEGER :PIXEL <-
  ( + result:PIXEL;
    
    deferred;
    
    result
  );

  - item_8  n:INTEGER :PIXEL_8  <- item n.to_pixel_8;
  
  - item_15 n:INTEGER :PIXEL_15 <- item n.to_pixel_15;

  - item_16 n:INTEGER :PIXEL_16 <- item n.to_pixel_16;

  - item_24 n:INTEGER :PIXEL_24 <- item n.to_pixel_24;

  - item_32 n:INTEGER :PIXEL_32 <- item n.to_pixel_32;
  
  - item_ascii n:INTEGER :PIXEL_ASCII <- item n.to_pixel_ascii; // JBJB For text mode
  //
  // Arrayed consideration.
  //
  
  - get_storage:NATIVE_ARRAY[USMALLINT] <- ( deferred; NULL);
  
  - element_sizeof:INTEGER <- pixel_geometry.object_size;

  - valid_stream s:NUMERIC :BOOLEAN <- (s % element_sizeof)=0;
  
  + ofs_buf:INTEGER;
  
  - add_last_buffer buf:FIXED_ARRAY[USMALLINT] from beg:NUMERIC to end:NUMERIC <-
  ( + pos:INTEGER;
    
    // BSBS: Peu faire mieux directement avec les storages...
    pos := count * element_sizeof + ofs_buf;
    beg.to end do { j:UINTEGER;
      get_storage.put (buf.item j) to pos;
      ofs_buf := (ofs_buf + 1) % element_sizeof;
      (ofs_buf=0).if {
	? {count < capacity};
	upper := upper + 1;	
      };
      pos := pos + 1;
    };
  );



