/****************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  + name        := ARRAY3[E];
  - comment     :=" General prurpose, resizable, three dimensional array..";
  
  - category    := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
section INHERIT
  
  - parent_collection3:COLLECTION3[E] := COLLECTION3[E];
  
section PUBLIC
  
  + lower1:INTEGER;
  + lower2:INTEGER;
  + lower3:INTEGER;
  + upper1:INTEGER;
  + upper2:INTEGER;
  + upper3:INTEGER;
  
  + count1:INTEGER;
  + count2:INTEGER;
  + count3:INTEGER;
  + count:INTEGER;
  
  // ARRAY 2
  + storage:NATIVE_ARRAY[E];
  //To store elements line by line.
  
  + capacity:INTEGER;
  //Number of elements in `storage'.
  
  
  //Creation / modification:
  
  - create line_min, column_min, depth_min:NUMERIC to line_max, column_max, depth_max:NUMERIC :SELF <-
  (
    + result:SELF;
    result := clone;
    result.make line_min, column_min, depth_min to line_max, column_max, depth_max;
    result
  );
  
  
  - make line_min, column_min, depth_min:NUMERIC to line_max, column_max, depth_max:NUMERIC <-
  //Reset all bounds `line_minimum' / `line_maximum' / `column_minimum'
  //`column_maximum' / `depth_min' and `depth_max' using arguments as
  //new values. All elements are set to the default value of type E.
  (
    ? { line_min <= line_max };
    ? { column_min <= column_max };
    ? { depth_min <= depth_max };
    
    lower1 := line_min;
    upper1 := line_max;
    lower2 := column_min;
    upper2 := column_max;
    lower3 := depth_min;
    upper3 := depth_max;
    count1 := upper1 - lower1 + 1;
    count2 := upper2 - lower2 + 1;
    count3 := upper3 - lower3 + 1;
    count := count1 * count2 * count3;
    ( capacity >= count ).if {
      storage.clear_all (count - 1);
    } else {
      capacity := count;
      storage := NATIVE_ARRAY[E].calloc count;
    };
    
    ? { line_minimum = line_min };
    ? { line_maximum = line_max };
    ? { column_minimum = column_min };
    ? { column_maximum = column_max };
    ? { depth_minimum = depth_min };
    ? { depth_maximum = depth_max };
  );
  
  
  - from_collection3 model:COLLECTION3[E] <-
  (
    make (model.line_minimum),
    (model.column_minimum),
    (model.depth_minimum) to
    (model.line_maximum),
    (model.column_maximum),
    (model.depth_maximum);
    
    line_minimum.to line_maximum do { i:INTEGER;      
      column_minimum.to column_maximum do { j:INTEGER;	 
	depth_minimum.to depth_maximum do { k:INTEGER;
	  put (model.item i,j,k) to i,j,k;
	}; // end do
      }; // end do
    }; // end do
    
    // ensure then
    ? { lower1 = model.lower1 };
    ? { lower2 = model.lower2 };
    ? { lower3 = model.lower3 };
  );
  
  
  - from_collection contents:COLLECTION[E],line_min, line_max, column_min, column_max, depth_min, depth_max:NUMERIC <-
  // Reset all bounds using `line_min', `line_max', `column_min',
  // `column_max', `depth_min', and `depth_max'.
  // Copy all elements of `contents', line by line into Current.
  (
    ? { line_min <= line_max };
    ? { column_min <= column_max };
    ? { depth_min <= depth_max };
    ? { contents.count = (line_max - line_min + 1) * (column_max - column_min + 1) * (depth_max - depth_min + 1) };
    
    make line_min,column_min,depth_min to line_max,column_max,depth_max;
    
    0.to (count - 1) do { i:INTEGER;
      storage.put (contents.item (contents.lower + i)) to i;
    }; // end do
    
    ? { line_minimum = line_min };
    ? { line_maximum = line_max };
    ? { column_minimum = column_min };
    ? { column_maximum = column_max };
    ? { depth_minimum = depth_min };
    ? { depth_maximum = depth_max };
    ? { count = contents.count };
  );
  
  
  - from_model model:COLLECTION[COLLECTION[COLLECTION[E]]] <-
  //The `model' is used to fill line by line the COLLECTION3.
  //Assume all sub-collections of have the same indexing.
  (
    make (model.lower),
    (model.first.lower),
    (model.first.first.lower) to
    (model.upper),    
    (model.first.upper),    
    (model.first.first.upper);
    
    (model.lower).to (model.upper) do { line:INTEGER;
      (model.first.lower).to (model.first.upper) do { column:INTEGER;
	(model.first.first.lower).to (model.first.first.upper) do { depth:INTEGER;
	  put (model.item (line).item (column).item depth) to line,column,depth;
	}; // end do
      };// end do
    };// end do
    
    ? { line_minimum = model.lower };
    ? { line_maximum = model.upper };
    ? { column_minimum = model.first.lower };
    ? { column_maximum = model.first.upper };
    ? { depth_minimum = model.first.first.lower };
    ? { depth_maximum = model.first.first.upper }
  );
  
  
  //Resizing:
  
  - resize line_min, column_min, depth_min:NUMERIC to line_max, column_max, depth_max:NUMERIC <-
  //Resize bounds of the Current array
  (
    + tmp:SELF;
    
    ? { line_max >= line_min };
    ? { column_max >= column_min };
    ? { depth_max >= depth_min };
    
    tmp := SELF.clone;
    tmp.make line_min, column_min, depth_min to line_max, column_max, depth_max;
    //It may be possible to avoid this creation when :
    //   new `capacity' <= old `capacity'
    
    lower1.to line_maximum do { l:INTEGER;
      lower2.to column_maximum do { c:INTEGER;
	lower3.to depth_maximum do { d:INTEGER;
	  ( tmp.valid_index l,c,d) .if {
	    tmp.put (item l,c,d) to l,c,d;
	  }; // end if
	}; // end do
      }; // end do
    }; // end do
    
    standard_copy tmp;
    
    ? { line_minimum = line_min };
    ? { line_maximum = line_max };
    ? { column_minimum = column_min };
    ? { column_maximum = column_max };
    ? { depth_minimum = depth_min };
    ? { depth_maximum = depth_max };
  );
  
  
  //Implementation of others feature from COLLECTION3:
  
  - item line, column, depth:NUMERIC :E <-
  (
    storage.item ((line - lower1) * count2 * count3 + (column - lower2) * count3 + depth - lower3)
  );
  
  
  - put element:E to line, column, depth:NUMERIC <-
  (
    storage.put element to ((line - lower1) * count2 * count3 + (column - lower2) * count3 + depth - lower3);
  );
  
  
  - force x:E to line, column, depth:NUMERIC <-
  (
    ( ! valid_index line,column,depth).if {
      resize (line.min lower1),(column.min lower2),(depth.min lower3) to
      (line.max upper1),(column.max upper2), (depth.max upper3);
    };
    put x to line,column,depth;
  );
  
  
  - set_all_with element:E <-
  (
    storage.set_all_with element with (count - 1);
  );
  
  
  - replace_all old_value:E with new_value:E <-
  (
    storage.replace_all old_value with new_value until (count - 1);
  );
  
  
  - fast_replace_all old_value:E with new_value:E <-
  (
    storage.fast_replace_all old_value with new_value until (count - 1);
  );
  
  
  - sub_collection line_min, column_min, depth_min:NUMERIC to line_max, column_max, depth_max:NUMERIC :SELF <-         
  (
    + n:INTEGER;
    + result:SELF;
    
    result := SELF.clone;
    result.make line_min,column_min,depth_min to line_max,column_max,depth_max;
    
    n := 0;
    line_min.to line_max do { i:INTEGER;
      column_min.to column_max do { j:INTEGER;
	depth_min.to depth_max do { k:INTEGER;
	  result.storage.put (item i,j,k) to n;
	  n := n + 1;
	}; // end do
      };// end do
    };// end do
    
    ? { result.lower1 = line_min };
    ? { result.lower2 = column_min };
    ? { result.lower3 = depth_min };
    ? { result.upper1 = line_max };
    ? { result.upper2 = column_max };
    ? { result.upper3 = depth_max };
    
    result
  );
  
  
  // Looking and comparison:
  
  - occurrences elt:E :NUMERIC <-
  (
    storage.occurrences elt until (count - 1)
  );
  
  
  - fast_occurrences elt:E :NUMERIC <-
  (
    storage.fast_occurrences elt until (count - 1)
  );
  
  
  - has x:E :BOOLEAN <-
  //Search if a element x is in the array using `equal'.
  //See also `fast_has' to choose the apropriate one.
  (
    storage.index_of x until (count - 1) <= count - 1
  );
  
  
  - fast_has x:E :BOOLEAN <-
  // Search if a element x is in the array using `='.
  (
    result := storage.fast_index_of x until (count - 1) <= count -1
  );
  
  
  - all_default :BOOLEAN <-
  (
    storage.all_default (count - 1)
  );
  
  
  - swap line1, column1, depth1:NUMERIC with line2, column2, depth2:NUMERIC <-
  (
    + tmp:E;
    + index1, index2:INTEGER;
    index1 := (line1 - lower1) * count2 * count3 + (column1 - lower2) * count3 + depth1 - lower3;
    index2 := (line2 - lower1) * count2 * count3 + (column2 - lower2) * count3 + depth2 - lower3;
    tmp := storage.item index1;
    storage.put(storage.item index2) to index1;
    storage.put tmp to index2;
  );
  
  
  - copy other:SELF <-
  (
    lower1 := other.lower1;
    upper1 := other.upper1;
    lower2 := other.lower2;
    upper2 := other.upper2;
    lower3 := other.lower3;
    upper3 := other.upper3;
    count := other.count;
    count1 := other.count1;
    count2 := other.count2;
    count3 := other.count3;
    ( capacity < count ).if {
      capacity := count;
      storage := storage.calloc count;
    };
    storage.copy_from (other.storage) until (count - 1);
  );
  
  
  - '=='  right 60 other:SELF :BOOLEAN <-
  (
    + result:BOOLEAN;
    result := FALSE;
    
    ( other = self ).if {
      result := true;
    }.elseif { lower1 != other.lower1 } then {
    }.elseif { lower2 != other.lower2 } then {
    }.elseif { lower3 != other.lower3 } then {
    }.elseif { upper1 != other.upper1 } then {
    }.elseif { upper2 != other.upper2 } then {
    }.elseif { upper3 != other.upper3 } then {
    } else {
      result := storage.memcmp (other.storage) until count;
    };
    
    result
  );
  
  
  - same_as other:COLLECTION3[E] :BOOLEAN <-
  (
    other.same_as_array3 self
  );
  
  
  //  COLLECTION3
  
  - same_as_array3 other:ARRAY3[E] :BOOLEAN <-
  (
    standard_same_as other
  );
  
  
  - same_as_fixed_array3 other:FIXED_ARRAY3[E] :BOOLEAN <-
  (
    standard_same_as other
  );
  
  
  - invariant :BOOLEAN <-
  (
    ( count1 = upper1 - lower1 + 1) && 
    { count2 = upper2 - lower2 + 1 } &&
    { count3 = upper3 - lower3 + 1 } &&
    { capacity >= count }
  );
  
