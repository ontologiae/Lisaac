/****************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  + name        := SET[E];
  - comment     :="Definition of a mathematical set of hashable objects.    \
                  \All common operations on mathematical sets are available.";
  
  - category    := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
section INHERIT
  
  - parent_object:OBJECT := OBJECT;
  
section PUBLIC
  
  - default_size:INTEGER := 53;
  // Minimum size for storage in number of items.
  
  // SET
  
  + buckets:NATIVE_ARRAY[SET_NODE[E]];
  // The `buckets' storage area is the primary hash table of `capacity'
  // elements. To search some element, the first access is done in
  // `buckets' using the remainder of the division of the key `hash_code' by
  // `capacity'. In order to try to avoid clashes, `capacity' is always a
  // prime number (selected using HASH_TABLE_SIZE).
  
  // Internal cache handling:
  
  + cache_user:INTEGER;
  // The last user's external index in range [1 .. `count'] (see `item'
  // and `valid_index' for example) may be saved in `cache_user' otherwise
  // -1 to indicate that the cache is not active. When the cache is
  // active, the corresponding index in `buckets' is save in
  // `cache_buckets' and the corresponding node in `cache_node'.
  
  + cache_node:SET_NODE[E];
  // Meaningful only when `cache_user' is not -1.
  
  + cache_buckets:INTEGER;
  // Meaningful only when `cache_user' is not -1.
  
  + count:INTEGER;
  // Cardinality of the set (i.e. actual `count' of stored elements).
  
  + capacity:INTEGER;
  // Of the `buckets' storage area.
  

  // NONE
  
  - create:SELF <-
  (
    + result:SELF;
    result := clone;
    result.make;
    result
  );
  
  - make <-
  // Create an empty set. Internal storage `capacity' of the set is
  // initialized using the `Default_size' value. Then, tuning of needed
  // storage size is done automatically according to usage. If you
  // are really sure that your set is always really bigger than
  // `Default_size', you may use `with_capacity' to save some execution time.
  (
    with_capacity default_size;
    ? { is_empty};
    ? { capacity = default_size };
  );
  
  - create_with_capacity sz:NUMERIC :SELF <-
  (
    + result:SELF;
    result := clone;
    result.with_capacity sz;
    result
  );
  
  - with_capacity medium_size:NUMERIC <-
  // Create an empty set using `medium_size' as an appropriate value
  // to help initialization of `capacity'. Thus, this feature may be used
  // in place of `make' to save some execution time if one is sure that
  // storage size will rapidly become really bigger than `Default_size' (if
  // not sure, simply use `make'). Anyway, the initial `medium_size' value
  // is just an indication and never a limit for the possible
  // `capacity'. Keep in mind that the `capacity' tuning is done
  // automatically according to usage.
  (
    + new_capacity:INTEGER;
    ? { medium_size > 0};
    
    new_capacity := HASH_TABLE_SIZE.prime_number_ceiling medium_size;
    buckets := NATIVE_ARRAY[SET_NODE[E]].calloc new_capacity;
    capacity := new_capacity;
    cache_user := -1;
    count := 0;
    
    ? { is_empty };
    ? { capacity >= medium_size };
  );
  
  
  // Counting:
  
  - is_empty:BOOLEAN <-
  // Is the set empty?
  (
    count = 0
  );
  
  
  // Adding and removing:
  - fast_add e:E <-
  // Add a new item to the set:the mathematical definition of
  // adding in a set is followed.
  ( + h, idx:INTEGER;
    + node:SET_NODE[E];
    + old_has:BOOLEAN;
    + old_count:INTEGER;
    //? { e != NULL };
    old_has := fast_has e;
    old_count := count;
    
    cache_user := -1;
    h := e.hash_code;
    idx := h % capacity;
    node := buckets.item idx;
    
    { (node = NULL) || {node.item = e}}.until_do {
      node := node.next;
    };
    (node = NULL).if {
      (capacity = count).if {
	increase_capacity;
	idx := h % capacity;
      };
      node := SET_NODE[E].create e next (buckets.item idx);
      buckets.put node to idx;
      count := count + 1;
    };
    
    ? { fast_has e};
    ? {! old_has ->> {count = old_count + 1}};
    ? {  old_has ->> {count = old_count}};
  );  
  
  - add e:E <-
  // Add a new item to the set:the mathematical definition of
  // adding in a set is followed.
  ( + h, idx:INTEGER;
    + node:SET_NODE[E];
    + old_has:BOOLEAN;
    + old_count:INTEGER;
    //? { e != NULL }; // BSBS: A voir avec SET[INTEGER] 
    old_has := has e;
    old_count := count;
    
    cache_user := -1;
    h := e.hash_code;
    idx := h % capacity;
    node := buckets.item idx;
    
    { (node = NULL) || {node.item == e}}.until_do {
      node := node.next;
    };
    (node = NULL).if {
      ( capacity = count).if {
	increase_capacity;
	idx := h % capacity;
      };
      node := SET_NODE[E].create e next (buckets.item idx);
      buckets.put node to idx;
      count := count + 1;
    };
    
    ? { has e};
    ? {!old_has ->> {count = old_count + 1}};
    ? { old_has ->> {count = old_count}};
  );
  
  - force e:E <-  
  // Add a new item to the set: the mathematical definition of
  // adding in a set is followed.
  ( + h, idx: INTEGER;
    + node:SET_NODE[E];
    ? {! fast_has e};
    h := e.hash_code;
    cache_user := -1;
    (capacity = count).if {
      increase_capacity;
    };
    idx := h % capacity;
    node := SET_NODE[E].create e next (buckets.item idx);
    buckets.put node to idx;
    count := count + 1;
    ? {fast_has e};
  );
	 
  - remove e:E <-
  // Remove item `e' from the set:the mathematical definition of
  // removing from a set is followed.
  (
    + h, idx:INTEGER;
    + node, previous_node:SET_NODE[E];
    + old_has:BOOLEAN;
    + old_count:INTEGER;
    
    old_has := has e;
    old_count := count;
    
    cache_user := -1;
    h := e.hash_code;
    idx := h % capacity;
    node := buckets.item idx;
    ( node != NULL).if {
      ( node.item == e).if {
	count := count - 1;
	node := node.next;
	buckets.put node to idx;
      } else {
	previous_node := node;
	node := node.next;
	{ (node = NULL) || {node.item == e}}.until_do {
	  previous_node := node;
	  node := node.next;
	};
	( node != NULL).if {
	  count := count - 1;
	  previous_node.set_next (node.next);
	};
      };
    };
    
    ? {! has e};
    ? {!old_has ->> {count = old_count}};
    ? {old_has ->> {count = old_count - 1}};
  );
  
  - fast_remove e:E <-
  // Remove item `e' from the set:the mathematical definition of
  // removing from a set is followed.
  (
    + h, idx:INTEGER;
    + node, previous_node:SET_NODE[E];
    + old_has:BOOLEAN;
    + old_count:INTEGER;
    
    old_has := fast_has e;
    old_count := count;
    
    cache_user := -1;
    h := e.hash_code;
    idx := h % capacity;
    node := buckets.item idx;
    ( node != NULL).if {
      ( node.item = e).if {
	count := count - 1;
	node := node.next;
	buckets.put node to idx;
      } else {
	previous_node := node;
	node := node.next;
	{ (node = NULL) || {node.item = e}}.until_do {
	  previous_node := node;
	  node := node.next;
	};
	( node != NULL).if {
	  count := count - 1;
	  previous_node.set_next (node.next);
	};
      };
    };
    
    ? {! fast_has e};
    ? {(! old_has) ->> {count = old_count}};
    ? {old_has ->> {count = old_count - 1}};
  );
  
  - clear <-
  // Empty the current set.
  (
    buckets.set_all_with NULL until (capacity - 1);
    cache_user := -1;
    count := 0;
    ? { is_empty};
  );
  
  
  // Looking and searching:
  
  - has e:E :BOOLEAN <-
  // Is element `e' in the set?
  ( + idx:INTEGER;
    + node:SET_NODE[E];
    + result:BOOLEAN;
    //? { e != NULL }; // A voir avec SET[INTEGER]

    idx := e.hash_code % capacity;
    node := buckets.item idx;
    { (node = NULL) || {node.item == e}}.until_do {
      node := node.next;
    };
    result := (node != NULL);
    
    ? {result ->> {! is_empty}};
    
    result
  );
  
  - fast_has e:E :BOOLEAN <-
  // Is element `e' in the set?
  ( + idx:INTEGER;
    + node:SET_NODE[E];
    + result:BOOLEAN;
    //? { e != NULL }; BSBS : A voir avec un SET[INTEGER]
    idx := e.hash_code % capacity;
    node := buckets.item idx;
    { (node = NULL) || {node.item = e}}.until_do {
      node := node.next;
    };
    result := (node != NULL);
    
    ? {result ->> {! is_empty}};
    
    result
  );
  
  - search e:E :E <-
  // Is element `e' in the set?
  ( + idx:INTEGER;
    + node:SET_NODE[E];
    + result:E;
    ? { e != NULL };
    idx := e.hash_code % capacity;
    node := buckets.item idx;
    { (node = NULL) || {node.item == e}}.until_do {
      node := node.next;
    };
    (node !=NULL).if {
      result := node.item;
    };
    result
  );

  - fast_search e:E :E <-
  // Is element `e' in the set?
  ( + idx:INTEGER;
    + node:SET_NODE[E];
    + result:E;
    ? { e != NULL };
    idx := e.hash_code % capacity;
    node := buckets.item idx;
    { (node = NULL) || {node.item = e}}.until_do {
      node := node.next;
    };
    (node !=NULL).if {
      result := node.item;
    };
    result
  );
  
  // To provide iterating facilities:
  
  - lower:INTEGER := 1;
  
  - upper:INTEGER <-
  (
    count
  );
  
  - first:E <-
  (
    item lower
  );
  
  - last:E <-
  (
    item count
  );

  - valid_index index:NUMERIC :BOOLEAN <-
  (
    (1 <= index) && {index <= count}
  );
  
  
  - item index:NUMERIC :E <-
  // Return the item indexed by `index'.
  (
    + result:E;
    ? { valid_index index};
    
    set_cache_user index;
    result := cache_node.item;

//    ? { fast_has result};
    
    result
  );
  
  - get_new_iterator:ITERATOR[E] <-
  (
    ITERATOR_ON_SET[E].create self
  );
  
  
  - fast_index_of elt:E :INTEGER <-
  ( + result:INTEGER;
    
    result := upper;
    {(result<lower) || {item result = elt}}.until_do {
      result := result - 1;
    };
    result
  );

  // Mathematical operations:
  
  - union other:SELF <-
  // Make the union of the `self' set with `other'.
  ( + e:E;
    + old_count:INTEGER;
    
    ? {old_count := count; 
       other != NULL};
    
    lower.to (other.count) do { i:INTEGER;
      e := other.item i;
      add e;
    };
    ? { count <= (old_count + other.count)};
  );

  - fast_union other:SELF <-
  // Make the union of the `self' set with `other'.
  ( + old_count:INTEGER;
    + e:E;
    ? {old_count := count; 
       other != NULL};
    
    lower.to (other.count) do { i:INTEGER;
      e := other.item i;
      fast_add e;
    };
    ? { count <= (old_count + other.count)};
  );
  
  
  - '+' left 1 other:SELF :SELF <-
  // Return the union of the `self' set with `other'.
  (
    + result:SELF;
    
    ? { other != NULL};
    
    result := twin ;
    result.union other ;
    
    ? { result.count <= count + other.count};
    ? { (self.is_subset_of result) && (other.is_subset_of result)};
    
    result
  );
  
  
  - intersection other:SELF <-
  // Make the intersection of the `self' set with `other'.
  (
    + i,c:INTEGER;
    + node1, node2:SET_NODE[E];
    + old_count:INTEGER;
    
    ? { other != NULL};
    
    old_count := count;
    
    cache_user := -1;
    i := capacity - 1;
    c := count;
    {c = 0}.until_do {
      node1 := buckets.item i;
      { (node1 = NULL) || {other.has (node1.item)}}.until_do {
	node1 := node1.next;
	c := c - 1;
	buckets.put node1 to i;
	count := count - 1;
      };
      (node1 != NULL).if {
	node2 := node1.next;
	c := c - 1;
	{ node2 = NULL}.until_do {
	  (! other.has (node2.item)).if {
	    node1.set_next (node2.next);
	    count := count - 1;
	  } else { 
	    node1 := node2;
	  };
	  
	  node2 := node2.next;
	  c := c - 1;
	};
      };
      i := i - 1;
    };
    ? {	count <= other.count.min(old_count)};
  );
  
  - is_disjoint other:SELF :BOOLEAN <-
  ( + j:INTEGER;
    + result:BOOLEAN;
     
    (other.count<count).if {
      result := other.is_disjoint self;
    } else {
      j:=upper;
      {(j<lower) || {other.has (item j)}}.until_do {
	j := j-1;
      };
      result := (j=0);
    };
    result
  ); 

  - fast_is_disjoint other:SELF :BOOLEAN <-
  ( + j:INTEGER;
    + result:BOOLEAN;
     
    (other.count<count).if {
      result := other.fast_is_disjoint self;
    } else {
      j:=upper;
      {(j<lower) || {other.fast_has (item j)}}.until_do {
	j := j-1;
      };
      result := (j=0);
    };
    result
  );
 
  - '^' other:SELF :SELF <-
  // Return the intersection of the `self' set with `other'.
  (
    + result:SELF;
    ? {other != NULL};
    
    result := twin;
    result.intersection(other) ;
    
    ? { result.count <= other.count.min count};
    ? { (result.is_subset_of self) && { result.is_subset_of other}};
  );
  
  - minus other:SELF <-
  // Make the set `self' - `other'.
  (
    + old_count:INTEGER;
    
    ? { other != NULL};
    
    old_count:=count;
    
    lower.to (other.count) do { i:INTEGER;
      remove (other.item i);
    };
    
    ? { count <= old count};
  );
  
  
  - '-' other:SELF :SELF <-
  // Return  the set `self' - `other'.
  (
    + result:SELF;
    
    ? { other != NULL};
    
    result := twin ;
    result.minus other;
    
    ? { result.count <= count};
    ? { result.is_subset_of(self)};
    
    result
  );
  
  // Comparison:
  
  - is_subset_of other:SELF :BOOLEAN <-
  // Is the `self' set a subset of `other'?
  (
    + i:INTEGER;
    + result:BOOLEAN;
    
    ? { other != NULL};
    
    result := FALSE;
    (self = other).if {
      result := TRUE;
    }.elseif { count <= other.count} then {
      result := TRUE;
      i := 1;
      {! result || {i > count}}.until_do {
	result := other.has (item i);
	i := i + 1;
      };
    };
    ? { result ->> {count <= other.count}};
    
    result
  );
  
  
  - is_disjoint_from other:SELF :BOOLEAN <-
  // Is the `self' set disjoint from `other' ?
  (
    + result:BOOLEAN;
    + i:INTEGER;
    
    ? { other != NULL};
    
    result := FALSE;
    
    ( self != other).if {
      result := TRUE;
      i := 1;
      ( count <= other.count).if {
	{! result || {i > count}}.until_do {
	  result := ! other.has (item i);
	  i := i + 1;
	};
      } else {
	{! result || {i > other.count}}.until_do {
	  result := ! has (other.item i);
	  i := i + 1;
	};
      };
    };
    ? { result = (self ^ other).is_empty };
    
    result
  );
  
  
  - '=='  right 60 other:SELF :BOOLEAN <-
  // Is the `self' set equal to `other'?
  (
    + i:INTEGER;
    + result:BOOLEAN;
    
    result := FALSE;
    ( self = other ).if {
      result := TRUE;
    }.elseif { count = other.count} then {
      result := TRUE;
      i := 1;
      { ! result || {i > count}}.until_do {
	result := other.fast_has (item i);
	i := i + 1;
      };
    };
    //ensure then
    //? { result = ((is_subset_of other) & (other.is_subset_of self))};
    
    result
  );
  
  
  - copy other:SELF <-
  // Copy 'other' into the current set
  (
    // Note:this is a naive implementation because we should
    // recycle already allocated nodes of `self'.
    ( capacity = 0 ).if {
      with_capacity (other.count + 1);
    } else {
      clear;
    };
    
    lower.to (other.count) do { i:INTEGER;
      add (other.item i);
    };
  );

  - fast_copy other:SELF <-
  // Copy 'other' into the current set
  (
    // Note:this is a naive implementation because we should
    // recycle already allocated nodes of `self'.
    ( capacity = 0 ).if {
      with_capacity (other.count + 1);
    } else {
      clear;
    };
    
    lower.to (other.count) do { i:INTEGER;
      fast_add (other.item i);
    };
  );
  
  
  // NONE
  
  - increase_capacity <-
  // There is no more free slots:the set must grow.
  (
    + i,idx, new_capacity,old_capacity,old_count:INTEGER;
    + old_buckets:NATIVE_ARRAY[SET_NODE[E]];
    + node1, node2:SET_NODE[E];
    
    ? { capacity = count};
    old_capacity := capacity;
    old_count := count;
    new_capacity := HASH_TABLE_SIZE.prime_number_ceiling (capacity + 1);
    old_buckets := buckets;
    buckets := buckets.calloc new_capacity;
    i := capacity - 1;
    capacity := new_capacity;
    { i< 0 }.until_do {
      node1 := old_buckets.item i;
      { node1 = NULL}.until_do {
	node2 := node1.next;
	idx := node1.item.hash_code % capacity;
	node1.set_next (buckets.item idx);
	buckets.put node1 to idx;
	node1 := node2;
      };
      i := i - 1;
    };
    cache_user := -1;
    
    ? { capacity > old_capacity };
    ? { count = old_count};
  );
  
  
  - set_cache_user index:NUMERIC <-
  (
    ? { valid_index index};
    
    ( index = cache_user + 1).if {
      cache_user := index;
      cache_node := cache_node.next;
      { cache_node != NULL}.until_do {
	cache_buckets := cache_buckets + 1;
	cache_node := buckets.item cache_buckets;
      };
    }.elseif { index = cache_user} then {
    }.elseif { index = 1} then {
      cache_user := 1;
      cache_buckets := 0;
      cache_node := buckets.item cache_buckets;
      { cache_node != NULL}.until_do {
	cache_buckets := cache_buckets + 1;
	cache_node := buckets.item cache_buckets;
      };
    } else {
      set_cache_user 1;
      { cache_user = index}.until_do {
	set_cache_user (cache_user + 1);
      };
    };
    
    ? { cache_user = index};
    ? { cache_buckets.in_range 0 to (capacity - 1)};
    ? { cache_node != NULL};
  );
  
  
  - invariant:BOOLEAN <-
  (
    ( capacity > 0) &&
    { capacity >= count} &&
    { cache_user.in_range (-1) to count} &&
    { (cache_user > 0) ->> {cache_node != NULL}} &&
    { (cache_user > 0) ->> {cache_buckets.in_range 0 to (capacity - 1)}}
  );
  
