Section Header

  + name    := EXPR;

  - comment := "Parent for all expression";

Section Inherit

  + parent_instr:Expanded INSTR;

Section Public

  - cardinality:INTEGER <- 1;
  
  - first:EXPR <- Self;
  
  - my_copy_with_first e:EXPR :EXPR <- e;
  
  //
  // Comparison.
  //

  - Self:SELF '~=' Right 60 other:EXPR :BOOLEAN <- FALSE;

  - Self:SELF '!~=' Right 60 other:EXPR :BOOLEAN <- ! (Self ~= other);

  //
  // Type.
  //

  - static_type:TYPE_FULL <-
  (
    deferred;
    NULL
  );

  - get_type t:TYPES_TMP <- deferred;

  //
  // Flag.
  //

  - is_constant:BOOLEAN <- FALSE;

  //
  // Check type.
  //

  - check_type t:TYPE_FULL with p:POSITION :EXPR <-
  ( + result:EXPR;
    + local:VARIABLE;
    + instr:INSTR;
    + rec:EXPR;
    + slot_name:STRING_ALIAS;
    + slot_msg:ITM_SLOT;
    + node:NODE;
    + args:ARRAY EXPR;
    + ts:ITM_TYPE_SIMPLE;

    ? {static_type != NULL};
    ? {t != NULL};

    (t.affect_with static_type).if {
      result := Self;
    } else {
      ? {list_current != NULL};
      (static_type.is_export_to t).if {
	// Auto-export.
	local := static_type.get_temporary position;
	instr := local.write position value Self;
	list_current.add_last instr;
	//
	slot_name := TYPE.last_cast_name.to_string_alias;
	slot_msg  := static_type.get_itm_slot slot_name;
	(slot_msg = NULL).if {
	  string_tmp.clear;
	  static_type.append_name_in string_tmp;
	  string_tmp.append " -> ";
	  t.append_name_in string_tmp;
	  string_tmp.append ". Slot `";
	  string_tmp.append slot_name;
	  string_tmp.append "' not found in `";
	  static_type.append_name_in string_tmp;
	  string_tmp.append "'.";
	  POSITION.put_error semantic text string_tmp;
	  p.put_position;
	  static_type.prototype.position.put_position;
	  POSITION.send_error;
	  //semantic_error p,string_tmp;
	};
	(slot_msg.argument_count != 1).if {
	  semantic_error (slot_msg.position,
          "No argument for this slot.");
	};
        ts ?= slot_msg.result_type;
	((ts = NULL) || {! (ts.to_run_for (t.raw) == t)}).if {
          string_tmp.copy "Type result `";
          slot_msg.result_type.append_in string_tmp;
	  string_tmp.append 
          "' is incorrect (Used for auto-conversion to `";
	  t.append_name_in string_tmp;
	  string_tmp.append "').";
	  POSITION.put_error semantic text string_tmp;
	  slot_msg.position.put_position;
	  position.put_position;
	  POSITION.send_error;
	};
	//
	rec  := local.read position;
	node := NODE.new_read position slot slot_msg
        receiver rec self rec intern FALSE;
	list_current.add_last node;
	//
	result := node.result_expr;
      }.elseif {t.is_import_to static_type} then {
        // Auto-import.
	local := static_type.get_temporary position;
	instr := local.write position value Self;
	list_current.add_last instr;
	//
	slot_name := TYPE.last_cast_name.to_string_alias;
	slot_msg  := t.get_itm_slot slot_name;
	(slot_msg = NULL).if {
	  string_tmp.clear;
	  t.append_name_in string_tmp;
	  string_tmp.append " <- ";
	  static_type.append_name_in string_tmp;
	  string_tmp.append ". Slot `";
	  string_tmp.append slot_name;
	  string_tmp.append "' not found in `";
	  t.append_name_in string_tmp;
	  string_tmp.append "'.";
	  POSITION.put_error semantic text string_tmp;
	  p.put_position;
	  t.prototype.position.put_position;
	  POSITION.send_error;
	  //semantic_error p,string_tmp;
	};
	(slot_msg.argument_count != 2).if {
	  semantic_error (slot_msg.position,"Incorrect argument for this slot.");
	};
        ts ?= slot_msg.result_type;
	((ts = NULL) || {! (ts == ITM_TYPE_PARAMETER.type_self)}).if {
	  string_tmp.copy "Type result `";
          slot_msg.result_type.append_in string_tmp;
	  string_tmp.append "' is incorrect (Used for auto-conversion to `";
	  t.append_name_in string_tmp;
	  string_tmp.append "').";
	  POSITION.put_error semantic text string_tmp;
	  slot_msg.position.put_position;
	  position.put_position;
	  POSITION.send_error;
	};
	//
	args := ARRAY EXPR .create_with_capacity 2;
	args.add_last (PROTOTYPE_CST.create position type t);
	args.add_last (local.read position);
	node := NODE.new_read position slot slot_msg
        receiver (args.first.my_copy) with args intern FALSE;
	list_current.add_last node;
	//
	result := node.result_expr;
      } else {
        // Type Error
	string_tmp.copy "Type `";
	t.append_name_in string_tmp;
	string_tmp.append "' is invalid with `";
	static_type.append_name_in string_tmp;
	string_tmp.append "'.";
	POSITION.put_error semantic text string_tmp;
	p.put_position;
        position.put_position;
        POSITION.send_error;
      };
    };
    result
  );
  
  //
  // Contract Slot in/out, Section in/out, Prototype in/out
  //
  
  - to_run_contract msg:STRING_ALIAS <-
  (
    "EXPR 179: ".print; 
    type_name.print;
    list_current.add_last Self;    
  );
  
  //
  // Execute.
  //

  - execute:INSTR <-
  (
    execute_unlink
  );

  - execute_link:EXPR <-
  (
    deferred;
    NULL
  );
  //[ ? {Result != NULL}; ];

  - execute_unlink:INSTR <-
  (
    deferred;
    NULL
  );


