Section Header

  + name    := STRING;

  - export  := STRING_BUFFER;

  - comment := "Generic prototype for STRING_BUFFER and STRING_ALIAS";

Section Inherit

  - parent_hashable:HASHABLE := HASHABLE;

  - parent_comparable:COMPARABLE := COMPARABLE;

Section STRING

  + storage:NATIVE_ARRAY(CHARACTER);
  // Collection containing characters

Section Public

  - count:INTEGER <- upper + 1;

  - lower:INTEGER; // Always 0

  + upper:INTEGER := -1;

  - capacity:INTEGER <- count;
  // size

  //
  // Access.
  //

  - item index:INTEGER :CHARACTER <-
  // Character at position `index'.
  // * Require: index is valid
  [
    -? {valid_index index};
  ]
  (
    storage.item index
  );

  //
  // Switch case :
  //

  - when val:STRING then block:{} :STRING <-
  // When `Self' equal `val', execute `block'
  (
    (Self ~= val).if block;
    Self
  );

  - when value1:STRING or value2:STRING then block:{} :STRING <-
  // When `Self' equal `value1' or `value2', execute `block'
  (
    ((Self ~= value1) || {Self ~= value2}).if block;
    Self
  );

  - case val:STRING then block:{} :STRING <-
  // * See: `when_then'
  ( + result :STRING;

    ((Self != STRING) && {Self ~= val}).if {
      block.value;
      result := STRING;
    } else {
      result := Self;
    };
    result
  );

  - case_if test:{BOOLEAN} then block:{} :STRING <-
  // If `test' is true then `block'
  ( + result :STRING;

    ((Self != STRING) && test).if {
      block.value;
      result := STRING;
    } else {
      result := Self;
    };
    result
  );

  - case_else block:{} <-
  // otherwise, execute `block'
  (
    (Self != STRING).if block;
  );

  //
  // Testing.
  //

  - valid_index index:INTEGER :BOOLEAN <-
  // True when `index' is valid (i.e., inside actual bounds).
  ( index.in_range lower to upper );

  - is_empty : BOOLEAN <- count = 0;


  - hash_code: INTEGER <- hash_code_intern;
  // Return a hashcode
  
  - Self:SELF '<' other:SELF :BOOLEAN <- Self ~< other;

  - Self:SELF '~>' other:STRING :BOOLEAN <- other ~< Self;

  - Self:SELF '~<' other:STRING :BOOLEAN <-
  // Is Current less than `other' ?
  ( + i: INTEGER;
    + result: BOOLEAN;

    {(i > upper) || {i > other.upper} || {item i != other.item i}}.until_do {
      i := i + 1;
    };
    (i > upper).if {
      result := other.upper >= i;
    } else {
      (i <= other.upper).if {
        result := item i < other.item i;
      };
    };
    result
  );

  - Self:SELF '!<' other:STRING :BOOLEAN <-
  // Is Current less than `other' ? But, the `upper' to `lower' comparaison
  ( + i1,i2: INTEGER;
    + result:BOOLEAN;

    i1 := upper;
    i2 := other.upper;
    {(i1 < lower) || {i2 < other.lower} || {item i1 != other.item i2}}.until_do {
      i1 := i1 - 1;
      i2 := i2 - 1;
    };
    (i1 < lower).if {
      result := i2 >= other.lower;
    } else {
      (i2 >= other.lower).if {
        result := item i1 < other.item i2;
      };
    };
    result
  );

  - compare other:STRING :INTEGER <-
  // Compare alphabetically `Self' to `other'
  ( + i: INTEGER;
    + result:INTEGER;
   
    {(i > upper) || {i > other.upper} || {item i != other.item i}}.until_do {
      i := i + 1;
    };
    (i > upper).if {
      (i > other.upper).if {
        result := 0;
      } else {
        result := -1;
      };
    } else {
      (i > other.upper).if {
        result := 1;
      } else {
        (item i < other.item i).if {
          result := -1;
        } else {
          result := 1;
        };
      };
    };

    result
  );

  - same_as other:STRING :BOOLEAN <-
  // Case insensitive `=='.
  ( + s1, s2:NATIVE_ARRAY(CHARACTER);
    + i:INTEGER;
    + result:BOOLEAN;
    ? {other != NULL};

    i := upper;
    (i = other.upper).if {
      (storage.fast_memcmp (other.storage) until (i+1)).if {
        result:=TRUE;
      } else {        
        s1 := storage;
        s2 := other.storage;
        result:=TRUE;
        {(i!=0) && {result}}.while_do {
          result:=s1.item i.same_as (s2.item i);
          i:=i-1;
        };
      };
    };
    result
  );

  - Self:SELF '==' Left 40 other:E :BOOLEAN <-
  // Has Current the same text as `other' ?
  ( + same:STRING;
    same ?= other;
    (same != NULL) && {Self ~= same}
  );

  - Self:SELF '~=' Left 40 other:STRING :BOOLEAN <-
  // Has Current the same text as `other' ?
  ( + result:BOOLEAN;
    ? {other != NULL};
    (upper = other.upper).if {
      (upper = -1).if {
        result := TRUE;
      } else {
        result:=storage.fast_memcmp (other.storage) until count;
      };
    };
    result
  );

  - item_code i:INTEGER :INTEGER <-
  // Code of character at position `i'.
  (
    ? { valid_index i};
    storage.item i.code
  );

  - index_of ch:CHARACTER since start_index:INTEGER :INTEGER <-
  // Index of first occurrence of `c' at or after `start_index',
  // result = upper + 1, if none.
  ( + result:INTEGER;
    ? { start_index.in_range 0 to count};

    result := start_index;

    {(result > upper) || {ch = item result}}.until_do {
      result := result + 1;
    };

    result
  );

  - last_index_of ch:CHARACTER since start_index:INTEGER :INTEGER <-
  // Index of first occurrence of `c' at or before `start_index',
  // -1 if none.
  ( + result:INTEGER;
    ? {start_index.in_range (-1) to upper};

    result := start_index;

    {(result < lower) || {ch = item result}}.until_do {
      result := result - 1;
    };

    ? {(result != -1) ->> {item result = ch}};
    result
  );

  - fast_index_of ch:CHARACTER :INTEGER <-
  // Gives the index of the first occurrence `ch' or
  // upper+1 if none.
  (+ result:INTEGER;
    result := storage.fast_index_of (ch,0) until upper;
    ? {(result != upper + 1) ->> {item result = ch}};
    result
  );

  - index_of ch:CHARACTER :INTEGER <-
  // Gives the index of the first occurrence of 'ch' or
  // 0 if none.
  (
    fast_index_of ch
  );

  - first_index_of c:CHARACTER :INTEGER <-
  // Index of first occurrence of `c' at index 1 or after index 1.
  (
    fast_index_of c
  );

  - fast_last_index_of ch:CHARACTER :INTEGER <-
  // Gives the index of the last occurrence `ch' or
  // 0 if none.
  (+ result:INTEGER;
    result := storage.fast_reverse_index_of ch from upper;

    ? {(result != -1) ->> {item result = ch}};
    result
  );

  - last_index_of c:CHARACTER :INTEGER <-
  // Index of last occurrence of `c' at index upper or before index upper.
  (
    fast_last_index_of c
  );

  - first_difference_index other:STRING :INTEGER <-
  // First difference index with `other'.
  // if `other' is equal `Self', return `upper' + 1
  [ -? {other != NULL}; ]
  ( + result:INTEGER;

    (Self = other).if {
      result := upper + 1;
    } else {
      result := lower;
      {
        (result <= upper) &&
        {result <= other.upper} &&
        {item result = other.item result}
      }.while_do {
        result := result + 1;
      };
    };
    result
  );

  - has ch:CHARACTER :BOOLEAN <- storage.fast_has ch until upper;
  // True if `ch' is in the STRING_BUFFER.

  - has_substring other:STRING :BOOLEAN <-
  // True if `other' is in the STRING_BUFFER.
  ( first_substring_index other != -1 );

  - occurrences c:CHARACTER :INTEGER <-
  // Number of times character `c' appears in the string.
  (
    storage.fast_occurrences c until upper
  );

  - has_suffix s:STRING :BOOLEAN <-
  // True if suffix of `Current' is `s'.
  (
    + result:BOOLEAN;
    + i1,i2:INTEGER;

    ? { s != NULL };

    (s.upper <= upper).if {
      i1 := upper - s.upper;
      i2 := 0;
      { (i1 > upper) || { i2 > s.upper} || { item i1 != s.item i2}}.until_do {
        i1 := i1 + 1;
        i2 := i2 + 1;
      };
      result := i1 > upper;
    };

    result
  );

  - has_prefix p:STRING :BOOLEAN <-
  // True if prefix of `Current' is `p'.
  [ ? { p != NULL }; ]
  (
    + result:BOOLEAN;
    + i:INTEGER;

    ( p.upper <= upper).if {
      i := p.upper;
      { (i = -1) || { item i != p.item i}}.until_do {
        i := i - 1;
      };
      result := i = -1;
    };

    result
  );

  // Testing and Conversion:

  - is_boolean:BOOLEAN <-
  // does self represent a BOOLEAN?
  // valid BOOLEANS are "TRUE" and "FALSE".
  (
    (Self == "TRUE") || { Self == "FALSE"}
  );

  - to_boolean:BOOLEAN <-
  // Boolean value;
  // "true" yields true, "false" yields false (what a surprise).
  (
    ?{ is_boolean };
    Self == "TRUE"
  );

  - is_bit:BOOLEAN <-
  // True when the contents is a sequence of bits (i.e., mixed
  // characters `0' and characters `1').
  ( + i:INTEGER;
    + result:BOOLEAN;
    i := upper;
    result := TRUE;
    { (! result) || { i = -1}}.until_do {
      result := item i.is_bit;
      i := i - 1;
    };
    ? {result = (count = occurrences '0' + occurrences '1')};
    result
  );

  - is_integer:BOOLEAN <-
  // Does self represent an INTEGER?
  // `Result' is true if and only if the following two conditions hold:
  //
  // 1. In the following BNF grammar, the value of self can be
  // produced by "Integer_literal", if leading and trailing
  // separators are ignored:
  //
  // Integer_literal = ['+'|'-'] Digit { Digit }
  // Digit           = '0' .. "9"
  //
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type INTEGER.
  ( + result:BOOLEAN;
    + cc: CHARACTER;
    + i:INTEGER;
    
    (is_empty).if_false {      
      cc := item 0;
      ((cc = '-') || {cc = '+'}).if {
        i := 1;
      };
      (i <= upper).if {
        {(i <= upper) && {item i.is_digit}}.while_do {
          i := i + 1;
        };
        result := i > upper;
      };
    };
    result
  );
  
  - is_integer_64:BOOLEAN <-
  // Does self represent an INTEGER_64?
  // `Result' is true if and only if the following two conditions hold:
  //
  // 1. In the following BNF grammar, the value of self can be
  // produced by "Integer_literal", if leading and trailing
  // separators are ignored:
  //
  // Integer_literal = [Sign] Integer
  // Sign            = "+" | "-"
  // Integer         = Digit | Digit Integer
  // Digit           = "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
  //
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type INTEGER_64.
  (
    + i, state: INTEGER;
    + value:INTEGER_64;
    + negative: BOOLEAN;
    + result:BOOLEAN;
    + cc: CHARACTER;

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.
    // state 4: error.

    i := 0;
    { (state = 4) || {i > upper}}.until_do {
      cc := item i;
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1;
        }.elseif {cc = '-'} then {
          negative := TRUE;
          state := 1;
        }.elseif {cc.is_digit} then {
          value := cc.decimal_value;
          state := 2;
        } else {
          state := 4;
        };
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value := cc.decimal_value;
          negative.if {
            value := - value;
          };
          state := 2;
        } else {
          state := 4;
        };
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          negative.if {
            value := value * 10 - cc.decimal_value;
          } else {
            value := value * 10 + cc.decimal_value;
          };
          // over/underflow check here
          ((negative && {value > 0}) || { ! negative && {value < 0}}).if {
            state := 4;
          };
        }.elseif {cc.is_separator} then {
          state := 3;
        } else {
          state := 4;
        };
      }.elseif { state = 3 } then {
        cc.is_separator.if {
        } else {
          state := 4;
        };
      };
      i := i + 1;
    };
    ( (state != 0) && { state != 4}).if {
      result := TRUE;
    };

    result
  );
    
  - to_integer:INTEGER <-
  // self must look like an INTEGER.
  (
    + i, state:INTEGER;
    + cc: CHARACTER;
    + negative: BOOLEAN;
    + result:INTEGER;

    ? { is_integer };
    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.

    i := 0;

    { i > upper}.until_do {
      cc := item i;

      (state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1;
        }.elseif {cc = '-'} then {
          negative := TRUE;
          state := 1;
        } else { // cc.is_digit
          result := cc.decimal_value;
          state := 2;
        };
      }.elseif { state = 1 } then {
        // cc.is_digit
        result := cc.decimal_value;
        negative.if {
          result := - result;
        };
        state := 2;
      }.elseif { state = 2} then {
        cc.is_digit.if {
          negative.if {
            result := 10 * result - cc.decimal_value;
          } else {
            result := 10 * result + cc.decimal_value;
          };
        } else { // cc.is_separator
          state := 3;
        };
      }.elseif { state = 3 } then {
        // cc.is_separator
        i := upper; // terminate the loop
      };

      i := i + 1;
    };

    result
  );

  - to_integer_64:INTEGER_64 <-
  // self must look like an INTEGER.
  (
    + i, state:INTEGER;
    + cc: CHARACTER;
    + negative: BOOLEAN;
    + result:INTEGER_64;

    ? { is_integer_64 };
    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number.
    // state 3: after the number.

    i := 0;
    {i > upper}.until_do {
      cc := item i;

      (state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1;
        }.elseif {cc = '-'} then {
          negative := TRUE;
          state := 1;
        } else { // cc.is_digit
          result := cc.decimal_value;
          state := 2;
        };
      }.elseif { state = 1 } then {
        // cc.is_digit
        result := cc.decimal_value;
        negative.if {
          result := - result;
        };
        state := 2;
      }.elseif { state = 2} then {
        cc.is_digit.if {
          negative.if {
            result := result * 10 - cc.decimal_value;
          } else {
            result := result * 10 + cc.decimal_value;
          };
        } else { // cc.is_separator
          state := 3;
        };
      }.elseif { state = 3 } then {
        // cc.is_separator
        i := upper; // terminate the loop
      };
      i := i + 1;
    };

    result
  );
  
  - is_hexadecimal :BOOLEAN <-
  ( + j:INTEGER;
    + result:BOOLEAN;
    (is_empty).if_false {
      j := lower;
      {(j > upper) || {! item j.is_hexadecimal_digit}}.until_do {
        j:=j+1;
      };
      result := j > upper;
    };
    result
  );

  - to_hexadecimal :INTEGER_64 <-
  ( + result:INTEGER_64;
    ? {is_hexadecimal};
    lower.to upper do { j:INTEGER;
      result := (result << 4) | item j.hexadecimal_value;
    };
    result
  );

  - is_octal :BOOLEAN <-
  ( + result:BOOLEAN;
    + j:INTEGER;
    (is_empty).if_false {
      j := lower;
      {(j > upper) || {! item j.is_octal_digit}}.until_do {
        j:=j+1;
      };
      result:= j > upper;
    };
    result
  );

  - to_octal:INTEGER_64 <-
  ( + result:INTEGER_64;
    ? {is_octal};

    lower.to upper do { j:INTEGER;
      result := (result << 3) | item j.octal_value;
    };
    result
  );

  - is_binary :BOOLEAN <-
  ( + result:BOOLEAN;
    + j:INTEGER;

    (is_empty).if_false {
      j := lower;
      { (j > upper) || {! item j.is_binary_digit} }.until_do {
        j := j + 1;
      };

      result := j > upper;
    };

    result
  );

  - to_binary :INTEGER_64 <-
  ( + result:INTEGER_64;
    ? {is_bit};

    lower.to upper do { j:INTEGER;
      result := result << 1;
      (item j = '1').if {
        result := result | 1;
      };
    };
    result
  );

  - is_real_16_16:BOOLEAN <-
  // Does self represent an REAl_16_16 ?
  // `Result' is true if and only if the following two conditions hold:
  //
  // 1. In the following BNF grammar, the value of self can be
  // produced by "real_literal", if leading and trailing
  // separators are ignored:
  //
  // Real_literal = [Sign] Integer [Point Integer]
  // Sign            = "+" | "-"
  // Point           = "."
  // Integer         = Digit | Digit Integer
  // Digit           = "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
  //
  // 2. The numerical value represented by self is within the
  // range that can be represented by an instance of type REAL_16_16.
  (
    + i, state, value_int: INTEGER;
    + value:REAL_16_16;
    + negative: BOOLEAN;
    + result:BOOLEAN;
    + cc: CHARACTER;
    + d:INTEGER;

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number before the point
    // state 3: in the number after the point
    // state 4: after the number.
    // state 5: error.

    i := 0;
    d := 1;

    { (state = 5) || {i > upper}}.until_do {
      cc := item i;
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1;
        }.elseif {cc = '-'} then {
          negative := TRUE;
          state := 1;
        }.elseif {cc.is_digit} then {
          value_int := cc.decimal_value;
          state := 2;
        } else {
          state := 5;
        };
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value_int := cc.decimal_value;
          state := 2;
        } else {
          state := 5;
        };
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          value_int := 10 * value_int + cc.decimal_value;
          (value_int < 0).if {
            state := 5;
          };
        }.elseif { cc = '.' } then {
          state := 3;
          value := value_int.to_real_16_16;
        }.elseif {cc.is_separator} then {
          state := 4;
        } else {
          state := 5;
        };
      }.elseif { state = 3 } then {
        cc.is_digit.if {
          d := d * 10;
          value := value + (cc.decimal_value.to_real_16_16) /# d;
        }.elseif {cc.is_separator} then {
          state := 4;
        } else {
          state := 5;
        };
      }.elseif { state = 4 } then {
        cc.is_separator.if {
        } else {
          state := 5;
        };
      };

      i := i + 1;
    };
    negative.if {
      value := - value;
    };
    ( (state != 0) && { state != 5}).if {
      result := TRUE;
    };

    result
  );

  - to_real_16_16:REAL_16_16 <-
  (
    + i, state, value_int: INTEGER;
    + value:REAL_16_16;
    + negative: BOOLEAN;
    + cc: CHARACTER;
    + d:INTEGER;

    // state 0: nothing read.
    // state 1: "+" or "-" read.
    // state 2: in the number before the point
    // state 3: in the number after the point
    // state 4: after the number.

    i := 0;
    d := 1;

    {i > upper}.until_do {
      cc := item i;
      ( state = 0).if {
        cc.is_separator.if {
        }.elseif {cc = '+'} then {
          state := 1;
        }.elseif {cc = '-'} then {
          negative := TRUE;
          state := 1;
        }.elseif {cc.is_digit} then {
          value_int := cc.decimal_value;
          state := 2;
        };
      }.elseif { state = 1} then {
        cc.is_digit.if {
          value_int := cc.decimal_value;
          state := 2;
        };
      }.elseif { state = 2 } then {
        cc.is_digit.if {
          value_int := value_int * 10 + cc.decimal_value;
        }.elseif { cc = '.' } then {
          state := 3;
          value := value_int.to_real_16_16;
        } else {  // cc is separator
          value := value_int.to_real_16_16;
          state := 4;
        };
      }.elseif { state = 3 } then {
        cc.is_digit.if {
          d := d * 10;
          value := value + (cc.decimal_value.to_real_16_16) /# d;
        } else { // cc is separator
          state := 4;
        };
      }.elseif { state = 4 } then {
        // cc is separator
        i := count;  // terminate the loop
      };

      i := i + 1;
    };

    (state = 2).if {
      value := value_int.to_real_16_16;
    };

    negative.if {
      value := - value;
    };

    value
  );

  //
  // Modification:
  //

  - Self:SELF '+' other:STRING :STRING_BUFFER <-
  // Create a new STRING_BUFFER which is the concatenation of
  // `self' and `other'.
  [
    -? {other != NULL};
  ]
  ( + result:STRING_BUFFER;
    result:=STRING_BUFFER.create (count + other.count);
    result.append Self;
    result.append other;
    result
  )
  [
    +? {Result.count = Old count + other.count};
  ];

  - as_lower:STRING_BUFFER <-
  // New object with all letters in lower case.
  (
    + result:STRING_BUFFER;
    result := STRING_BUFFER.create capacity;
    result.copy Self;
    result.to_lower;
    result
  );

  - as_upper:STRING_BUFFER <-
  // New object with all letters in upper case.
  (
    + result:STRING_BUFFER;
    result := STRING_BUFFER.create capacity;
    result.copy Self;
    result.to_upper;
    result
  );

  // Other features:

  - first:CHARACTER <-
  // Access to the very `first' character.
  (
    + result:CHARACTER;
    //? {! is_empty};

    result := storage.item 0;

    //? { result == item lower};
    result
  );

  - last:CHARACTER <-
  // Access to the very `last' character.
  (
    + result:CHARACTER;
    ? {! is_empty};

    result := storage.item upper;

    ? { result = item upper};
    result
  );

  - substring start_index:INTEGER to end_index:INTEGER :STRING_BUFFER <-
  // New string consisting of items [`start_index'.. `end_index'].
  [
    -? { start_index >= 1 };
    -? { end_index <= count };
    -? { start_index <= end_index + 1 };
  ]
  ( + c:INTEGER;
    + result:STRING_BUFFER;

    c := end_index - start_index + 1;
    result := STRING_BUFFER.create c;
    result.set_upper (c-1);
    result.storage.slice_copy storage to 0 from start_index to end_index;

    result
  )
  [
    +? { Result.count = end_index - start_index + 1 };
  ];

  - substring_begin start:INTEGER to_begin end:INTEGER :STRING_BUFFER <-
  (
    substring start to end
  );

  - substring_begin start:INTEGER to_end end:INTEGER :STRING_BUFFER <-
  (
    substring start to (upper-end-1)
  );

  - substring_end start:INTEGER to_end end:INTEGER :STRING_BUFFER <-
  (
    substring (upper-start-1) to (upper-end-1)
  );
  
  - max_match from:INTEGER on other:STRING 
  from start_other:INTEGER :(INTEGER,INTEGER) <-
  ( + result,i:INTEGER;
    result := from;
    i := start_other;
    {(result <= upper) && {i <= other.upper} && 
    {item result = other.item i}}.while_do {
      result := result + 1;
      i := i + 1;
    };
    result, i
  );
  
  - substring_index (other:STRING,start_index:INTEGER) :INTEGER <-
  // Position of the first occurrence of `other' at or after 0
  // or -1 if none.
  ( + i,s,result:INTEGER;

    ? {! other.is_empty };
    ? { (start_index >=0) && { start_index <= upper + 1 }};
    result := -1;
    s := start_index;
    {(result != -1) || {(s + other.upper) > upper}}.until_do {
      i := 0;
      {(i > other.upper) || {item (s + i) != other.item i}}.until_do {
        i := i + 1;
      };

      (i > other.upper).if {
        result := s;
      } else {
        s := s + 1;
      };
    };
    result
  );

  - first_substring_index other:STRING :INTEGER <-
  // Position of the first occurrence of `other' at or after 0
  // or -1 if none.
  (
    ? {! other.is_empty };

    substring_index (other,0)
  );

  //
  // Splitting a STRING_BUFFER:
  //
  
  /*
  - partition sep:STRING from start_index:INTEGER :(STRING_BUFFER, STRING_BUFFER, STRING_BUFFER) <-
  [
    -? {sep != NULL};
    -? {valid_index start_index};
  ]
  ( + i, j:INTEGER;
    + head, sep, tail :STRING_BUFFER;
    i := substring_index (sep, start_index);
    (i = 0).if {
      // Not found
      head := to_string_buffer;
    } else {
      // Found
      j := i + sep.count;
      (i > lower).if {
        head := substring lower to (i-1);
      };
      sep  := substring i to j;
      (j < upper).if {
        tail := substring (j+1) to upper;
      };
    };
    head, sep, tail
  );

  - partition sep:STRING :(STRING_BUFFER, STRING_BUFFER, STRING_BUFFER) <-
  (
    partition sep from lower
  );
*/
  - split_str sep:STRING :ARRAY(STRING_BUFFER) <-
  [
    -? {sep != NULL};
  ]
  ( + result:ARRAY(STRING_BUFFER);
    ( count > 0 ).if {
      split_buffer.clear;
      split_str sep in split_buffer;
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper);
        result.copy split_buffer;
      };
    };

    result
  )
  [
    +? { (Result != NULL) ->> { ! Result.is_empty }};
  ];

  - split_str sep:STRING in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split_str' but result is appended in `words'.
  [
    -? {words != NULL};
    -? {sep != NULL};
  ]
  ( + i, j:INTEGER;
    // i    first character of the next word
    // j-1  last character of the next word
    // j    first character of the next separator

    i := 0;
    { j := substring_index(sep, i); j != -1 }.while_do {
      words.add_last (substring i to (j-1));
      i := j + sep.count;
    };
    words.add_last (substring i to upper);
  );

  - split:ARRAY(STRING_BUFFER) <-
  // Split the string into an array of words. Uses `is_separator' of
  // CHARACTER to find words. Gives Void or a non empty array.
  (
    + result:ARRAY(STRING_BUFFER);
    (upper >= 0 ).if {
      split_buffer.clear;
      split_in split_buffer;
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper);
        result.copy split_buffer;
      };
    };
    ? { (result != NULL) ->> { ! result.is_empty }};

    result
  );

  - split_in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split' but result is appended in `words'.
  (
    + state,old_count: INTEGER;
    // state = 0: waiting next word.
    // state = 1: inside a new word.
    + c: CHARACTER;

    ? { words != NULL};
    old_count := words.count;
    (upper >= 0).if {
      lower.to upper do { i:INTEGER;
        c := item i;
        (state = 0).if {
          (! c.is_separator).if {
            string_buffer.clear;
            string_buffer.append_character c;
            state := 1;
          };
        } else {
          (! c.is_separator).if {
            string_buffer.append_character c;
          } else {
            words.add_last (string_buffer.twin);
            state := 0;
          };
        };
      };
      ( state = 1).if {
        words.add_last (string_buffer.twin);
      };
    };

    ? { (words.count) >= old_count };
  );
  
  - is_upper:BOOLEAN <-
  // True, if all characters `is_upper' or '_' or digit.
  ( + i:INTEGER;
    + c:CHARACTER;
    i := lower;
    {(i <= upper) && {
      (c := item i; c.is_upper) || {c = '_'} || {c.is_digit}}
    }.while_do { 
      i := i + 1;
    };
    i > upper
  );    
  
  - split_at sep:CHARACTER :ARRAY(STRING_BUFFER) <-
  // Split the string at characters `c' into an array of words.
  (
    + result:ARRAY(STRING_BUFFER);
    ( count > 0 ).if {
      split_buffer.clear;
      split_at sep in split_buffer;
      (! split_buffer.is_empty).if {
        result := ARRAY(STRING_BUFFER).create (split_buffer.lower) to (split_buffer.upper);
        result.copy split_buffer;
      };
    };

    result
  )
  [
    +? { (Result != NULL) ->> { ! Result.is_empty }};
  ];

  - split_at sep:CHARACTER in words:COLLECTION(STRING_BUFFER) <-
  // Same jobs as `split' but result is appended in `words'.
  (
    + state,old_count: INTEGER;
    // state = 0: waiting next word.
    // state = 1: inside a new word.
    + c: CHARACTER;

    ? { words != NULL};
    old_count := words.count;
    (count > 0).if {
      0.to upper do { i:INTEGER;
        c := item i;
        (state = 0).if {
          (c != sep).if {
            string_buffer.clear;
            string_buffer.append_character c;
            state := 1;
          };
        } else {
          (c != sep).if {
            string_buffer.append_character c;
          } else {
            words.add_last (string_buffer.twin);
            state := 0;
          };
        };
      };
      ( state = 1).if {
        words.add_last (string_buffer.twin);
      };
    };

    ? { (words.count) >= old_count };
  );

  /*
  - get_new_iterator:ITERATOR(CHARACTER) <-
  (
    ITERATOR_ON_STRING(CHARACTER).create Self
  );
  */

  - same_string other:STRING :BOOLEAN <-
  // Do self and other have the same character sequence?
  // Useful in proper descendants of STRING_BUFFER.
  (
    ? { other != NULL };
    Self == other.to_string_buffer
  );

  - to_string_buffer:STRING_BUFFER <-
  // New STRING_BUFFER having the same character sequence as self.
  // Useful in proper descendants of STRING_BUFFER.
  (
    STRING_BUFFER.create_from_string Self
  );
  
  - to_string_alias:STRING_ALIAS <-
  (
    deferred;
    NULL
  );

  - to_string :STRING <- Self;

  - string_buffer:STRING_BUFFER := STRING_BUFFER.create 256; // Private, temporary once buffer.

  - split_buffer:ARRAY(STRING_BUFFER) := ARRAY(STRING_BUFFER).create_with_capacity 4 lower 1;

  //
  // Display.
  //

  - print <-
  (    
    //print_runtime_stack; die_with_code 1; // to track the first print...
    IO.put_string Self;
  );

  -  printline <-
  (
    IO.put_string Self;
    IO.put_string "\n";
  );

  - fast_print <-
  (
    SYSTEM_IO.print_string Self;
  );

  - println <-
  (
    print;
    '\n'.print;
  );

  //
  // The guru section
  //

  - to_external:NATIVE_ARRAY(CHARACTER) <-
  // Gives C access to the internal `storage' (may be dangerous).
  // To be compatible with C, a null character is added at the end
  // of the internal `storage'. This extra null character is not
  // part of the Lisaac STRING_BUFFER.
  (
    deferred;
    NULL
  );
  
Section STRING
  /*
  - hash_code_intern: INTEGER <-
  // Return a hashcode
  ( + result,up:INTEGER;
    
    result := 7;
    up := upper.min 32;
    0.to up do { i:INTEGER;
      result := result * 31 + item i.code;
    };
    result & 07FFF_FFFFh
  );
  */
  - hash_code_intern: INTEGER <-
  // Return a hashcode
  ( + result,up:INTEGER;
    
    up := upper.min 32;
    0.to up do { i:INTEGER;
      result := (result << 2) + item i.code;
    };
    result & 07FFF_FFFFh
  );
