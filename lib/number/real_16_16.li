/***************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  * name        := REAL_16_16; // Aucun Auto-Cast pour l'instant...(peu etre
  // REAL ...)
  
  - comment     := "signed 16.16 fixed float.";
  
  - category    := MICRO;
  
  - bibliography:= "http://IsaacOS.com";
  - author      := "Benoit Sonntag (bsonntag@loria.fr)";
  
  - type        := `signed long`;
  - default     := 0;
  
  - external := `#include <math.h>`; // BSBS (a virer:)
  
section INHERIT
  
  - parent_signed:SIGNED := SIGNED;
  
section PUBLIC
  
  - object_size:INTEGER := 4;
  
  //
  // Range.
  //
  
  - minimum:LONGINT <- SHORTINT.minimum; 

  - maximum:ULONGINT <- SHORTINT.maximum; 
  
  //
  // Convertion format with test.
  //
  
  - to_ulongint:ULONGINT   <- 
  ( ? {in_range 0 to (ULONGINT.maximum)};
    floor.to_ulongint
  );
  
  - to_uinteger:UINTEGER   <- 
  ( //? {in_range 0 to (UINTEGER.maximum)};
    floor.to_uinteger
  );
  
  - to_ushortint:USHORTINT <- 
  ( ? {in_range 0 to (USHORTINT.maximum)};
    floor.to_ushortint
  );
  
  - to_usmallint:USMALLINT <- 
  ( ? {in_range 0 to (USMALLINT.maximum)};
    floor.to_usmallint
  );
  
  - to_longint:LONGINT     <- 
  ( ? {in_range (LONGINT.minimum) to (LONGINT.maximum)};
    floor
  );
  
  - to_integer:INTEGER     <- 
  ( 
    floor.to_integer
  );
  
  - to_shortint:SHORTINT   <- 
  ( ? {in_range (SHORTINT.minimum) to (SHORTINT.maximum)};
    floor.to_shortint
  );
  
  - to_smallint:SMALLINT   <- 
  ( ? {in_range (SMALLINT.minimum) to (SMALLINT.maximum)};
    floor.to_smallint
  );
  
  - to_ureal_26_6:UREAL_26_6 <-
  ( ? { in_range O to (UREAL_26_6.maximum)};
    (to_raw_integer >> 10).to_raw_ureal_26_6    
  );
  
  - to_ureal_24_8:REAL_24_8 <-
  ( ? {in_range (REAL_24_8.minimum) to (REAL_24_8.maximum)};
    (to_raw_integer >> 8).to_raw_ureal_24_8    
  );
  
  - to_real_16_16:REAL_16_16 <- self;
  
  - floor:INTEGER <-
  // Greatest integral value no greater than Current.
  ( + result:INTEGER;
    
    result:=to_raw_integer >> 16;
    //? {self <= result.to_real_16_16};
    //? {(self - result.to_real_16_16) < 1};
    result
  );
  
  - ceiling:INTEGER <-
  // Smallest integral value no smaller than Current.
  ( + result:INTEGER;
    
    result:=(to_raw_integer+65535) >> 16;
    ? {self >= result.to_real_16_16};
    ? {(self - result.to_real_16_16) < 1};
    result
  );
  
  - rounded:INTEGER <-
  // Rounded integral value.
  (
    (to_raw_integer+32768) >> 16
  );
  
  - truncated_to_integer:INTEGER <- floor;
  // Integer part (largest absolute value no greater than Current).
  
  //
  // binary operator :
  //
  
  - '-'  left 80  other:SELF :SELF <- 
  (
    (to_raw_integer - other.to_raw_integer).to_raw_real_16_16
  );

  - '*#' left 100 other:INTEGER :SELF <- 
  (    
    (to_raw_integer * other).to_raw_real_16_16
  );
  
  - '*'  left 100 other:SELF :SELF <- 
  (
    ((to_raw_longint * other.to_raw_longint)>>16).to_raw_real_16_16
  );
  
  - '/#' left 100 other:INTEGER :SELF <- 
  (
    (to_raw_integer / other).to_raw_real_16_16
  );
  
  - '/'  left 100 other:SELF :SELF <- 
  (
    ((to_raw_longint << 16)/ other.to_raw_longint).to_raw_real_16_16
  );
  
  - '&'  left 100 other:SELF :SELF <-
  (
    (to_raw_integer & other.to_raw_integer).to_raw_real_16_16
  );
  
  - '>>' left 100 other:NUMERIC :REAL_24_8 <- (to_raw_integer >> other).to_real_16_16;  
  
  - '<<' left 100 other:NUMERIC :REAL_24_8 <- (to_raw_integer << other).to_real_16_16;
  
  //
  // Test binary operator :
  //
  
  - '>'   right 60 other:SELF :BOOLEAN <- 
  (
    to_raw_integer > other.to_raw_integer
  );
  
  //
  // prefix : Unary operator
  //
  
  - '~' :SELF <- 
  (
    (~ to_raw_integer).to_raw_real_16_16
  );
  
  //
  // Convertion
  //
  
  - append_in buffer:STRING <- 
  // Append in the `buffer' the equivalent of `to_string'. No new STRING
  // creation during the process.
  ( + val:INTEGER;
    + old_count,new_count:INTEGER;
    ? {buffer!=NULL};
    
    val := self.to_raw_integer;
    
    (val < 0).if {
      val := - val;
      buffer.extend '-';
    };
    (val >> 16).append_in buffer;
    buffer.extend '.';

    old_count:=buffer.count;
    //     1/65536 = 0.00390625 => 8 digit.
    (((val & 0FFFFh).to_ulongint * 100000000)>>16).to_integer.append_in buffer;
    new_count:=old_count+8;
    {buffer.count!=new_count}.while_do {
      buffer.insert '0' to old_count;
    };

  );
  
  //  
  // A REFAIRE en mieux ...
  //
  
  - pi:SELF <- `(int)(PI*65536.)`:SELF;
  
  - atan:SELF <- `(int)(atan(((double)@self)/65536.)*65536.)`:SELF;
  
  - sqrt:SELF <- `(int)(sqrt(((double)@self)/65536.)*65536.)`:SELF;
  
  - log:SELF <- `(int)(log(((double)@self)/65536.)*65536.)`:SELF;
  
  - sin:SELF <- `(int)(sin(((double)@self)/65536.)*65536.)`:SELF;
  
  - cos:SELF <- `(int)(cos(((double)@self)/65536.)*65536.)`:SELF;
  
  
  
  
  
  
  
  
