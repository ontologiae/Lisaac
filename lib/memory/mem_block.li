/***************************************************************************
*                      Isaac Object Operating System                       *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/
section HEADER
  
  + name        := MEM_BLOCK;
  
  - comment     := "Memory block (used by MEMORY)";
  
  - category    := MICRO;
  
  - bibliography:= "http://IsaacOS.com";

  - author      := "Benoit Sonntag (bsonntag@loria.fr), Jerome Boutet (boutet@loria.fr)";
  
section INHERIT  
  
  - parent_object:OBJECT := OBJECT;
  
section MAPPING
  
  // Physical size on 31 bits, 1 bit for free (0: free, 1:not free)
  + size_and_flags:UINTEGER;   
  
  + prev:MEM_BLOCK;       // Previous block
  
  + prev_same:MEM_BLOCK;  // Previous block of the same type
  
  + next_same:MEM_BLOCK;  // Next block of the same type
  
  // 16 bytes ---------------------------------> for small blocks
  
  + small_size:USHORTINT;  // size used in the small block
      
  + first_free:USHORTINT;  // offset of the first free index in a small block 
  
section PRIVATE

  - memory:NATIVE_ARRAY[USHORTINT] <- NATIVE_ARRAY[USHORTINT].force_conversion get_adress;
    
section PUBLIC
  
  //
  // Check Runtime Memory Block System.
  //
  
  - is_cyclic_list:BOOLEAN <-
  ( + cur:MEM_BLOCK;
    cur := next_same;
    {(cur != NULL) && {cur != self}}.while_do {
      cur := cur.next_same;
    };
    cur = self
  );
  
  - check_block <-
  ( + is_small:BOOLEAN;
    + ptr:UINTEGER;
    + cur:MEM_BLOCK;
    is_small := is_cyclic_list;
    
    //
    // General test.
    //
    
    // Test adress block.
    ? {get_adress.in_range (MEMORY.begin_memory) to (MEMORY.end_memory)}; // Bound test.
    ? {(get_adress & 0Fh) = 0};                                           // Alignment test.
    // Size Test.
    ? {(size & 0Fh) = 0};       // Alignment test.
    ? {size > 128};             // Minimum size.
    ? {size < MEMORY.capacity}; // Maximum size.
    
    (! is_small).if {
      //
      // Big Block.
      //
      
      // Check linked list same.
      cur := next_same;
      {cur != NULL}.while_do {
	? {cur.prev_same.next_same = cur};
	? {cur.is_free = is_free};
	cur := cur.next_same;
      };
      cur := prev_same;
      {cur != NULL}.while_do {
	? {cur.next_same.prev_same = cur};
	? {cur.is_free = is_free};
	cur := cur.prev_same;
      };
    } else {
      //
      // Small Block.
      //
      ? {! is_free};                                // Not free.
      ? {size >= 4096};                             // Size Small Block.
      ? {size <= (4096+128)};
      ? {small_size >= 4};                          // small_size minimum.
      ? {small_size <= (4096+128)};                       // small_size maximum.
      ? {small_size.is_even};                       // small_size is even.
      ? {(small_size = 4)  ->> {first_free = 0}};   // Small Block free implies first_free = 0.
      // Check linked list first free.
      ptr := first_free;    
      {ptr != 0}.while_do {
	? {ptr > 1};
	? {ptr < (2048+64)};
	ptr := memory.item ptr;
      };
      // Check cyclic linked list. 
      cur := prev_same;
      {cur != self}.while_do {
	? {cur.next_same.prev_same = cur};
	cur := cur.prev_same;
	? {cur != NULL};
      };
    };
    
  );
  
  
  //
  // Big block
  //
  
  - get_adress:UINTEGER <- UINTEGER.force_conversion self + object_size;
  
  - size:UINTEGER <- (size_and_flags & 0FFFFFFFEh);
  
  - object_size:UINTEGER := 16;
  
  - is_free:BOOLEAN <- ! (( size_and_flags & 1).to_boolean);
  
  - in_range p:UINTEGER :BOOLEAN <-
  ( + limit_up, limit_low:UINTEGER;
    
    limit_low:=get_adress;
    limit_up :=limit_low+size;
    p.in_range limit_low to limit_up
  );
      
  - make siz:NUMERIC <-
  ( ? {(siz&0Fh)=0};
      
    size_and_flags:=siz;
    prev:=prev_same:=next_same:=NULL;
  );

  - set_prev block:MEM_BLOCK      <- ( prev      := block; );
  
  - set_prev_same block:MEM_BLOCK <- ( prev_same := block; );
  
  - set_next_same block:MEM_BLOCK <- ( next_same := block; );
  
  - set_size sz:UINTEGER <- 
  ( ? {(sz&1)=0};
    size_and_flags := sz | (size_and_flags&1);
  );
  
  - to_busy <-
  ( ? {is_free};
    size_and_flags := size_and_flags | 1;
  );
  
  - to_free <-
  ( ? {! is_free};
    size_and_flags := size_and_flags & 0FFFFFFFEh;
  );
    
  
  //
  // Small Block
  //
    
  - to_small <-
  (
    small_size:= 4;    
    first_free:= 0;
    prev_same := next_same := self;
  );
        
  - is_small_busy sz:NUMERIC :BOOLEAN <- ((size-small_size) < sz);
  
  - is_small_free:BOOLEAN <- (small_size=4);
  
  - allocation sz:NUMERIC :USHORTINT <-
  // The result is an offset in byte
  ( + result:USHORTINT;
    ? {! is_small_busy sz};
    ? {sz.is_even};

    (first_free = 0).if {
      // No linked list for free block
      result := small_size;
    } else {
      // Linked list
      result := first_free << 1;
      first_free := memory.item first_free;
    };
    small_size := small_size + sz;   

    result
  );
    
  - free o:NUMERIC size sz:NUMERIC <-
  // o: offset in the memory block, in byte
  ( + idx:USHORTINT;
    
    idx := o >> 1;
    memory.put first_free to idx;
    first_free := idx;
    small_size := small_size - sz;
  );
  
  //
  // Debug Print Object.
  //
  
  - sub_print p:MEM_BLOCK <-
  (
    (p=NULL).if {
      "NULL".print;
    } else {
      ((p.get_adress-16) & 0FFFFh).to_hexadecimal.print;
    };
  );
  
  - big_print <-
  ( 
    "[P:".print;
    sub_print prev;
    (is_free).if {
      "|PS:".print;
      sub_print prev_same;
    };
    "|".print;
    sub_print self;
    (is_free).if {
      "-Free-|NS:".print;
      sub_print next_same;
    } else {
      "-Busy-".print;
    };    
    "|N:".print;
    ((get_adress+size)&0FFFFh).to_hexadecimal.print;
    "] ".print;
  );
  
  - small_print <-
  ( + cur:USHORTINT;
    
    "[PS:".print;
    sub_print prev_same;
    "|S:".print;
    small_size.print;
    "|NS:".print;
    sub_print next_same;
    
    "|L:".print;
    cur:=first_free;
    {cur!=0}.while_do {
      cur.print;
      ','.print;
      cur:=memory.item cur;
    };
    "0] ".print;
  );







