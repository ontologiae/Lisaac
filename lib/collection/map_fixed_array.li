/****************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/
section HEADER
  
  + name     := MAP_FIXED_ARRAY[E];
  
  - category := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
  - comment     :="Resizable, fixed lower bound array.\
                  \Unlike ARRAY, the `lower' bound of a FIXED_ARRAY is frozen \
                  \to 0. Thus, some memory is saved and looping toward `lower' \
                  \bound (which is 0) run a little bit faster.";
  
section INHERIT
  
  - parent_arrayed:ARRAYED := ARRAYED;
  
section PUBLIC

  - lower:INTEGER := 0;
  
  + upper:INTEGER;
  
  + capacity:INTEGER;
  
  + storage:MAP_NATIVE_ARRAY[E];
  
  // Creation and modification:
  
  - create new_count:NUMERIC :SELF <-
  (
    + result:SELF;
    result := clone;
    result.make new_count;
    result
  );
  
  - create_with_capacity new_count:NUMERIC :SELF <-
  (
    + result:SELF;
    result := clone;
    result.with_capacity new_count;
    result
  );
  
  - create_with_capacity new_count:NUMERIC at offset:UINTEGER :SELF <-
  (
    + result:SELF;
    result := clone;
    result.with_capacity new_count at offset;
    result
  );
  
  - make new_count:NUMERIC <-
  // Make array with range [0 .. `new_count' - 1].
  // When `new_count' = 0 the array is empty.
  (
    storage := MAP_NATIVE_ARRAY[E].calloc new_count;
    
    upper := new_count - 1;
    capacity := new_count;
    
    ? { count = new_count };
  ); // end make
  
  - with_capacity needed_capacity:NUMERIC <-
  // Create an empty array with at least `needed_capacity'.
  (
    ? { needed_capacity >= 0 };
    ? { storage = NULL};
    storage := MAP_NATIVE_ARRAY[E].calloc needed_capacity;

    upper := -1;
    capacity := needed_capacity;
    
    ? { capacity = needed_capacity };    
  ); // end with_capacity

  - with_capacity needed_capacity:NUMERIC at offset:NUMERIC <-
  // Create an empty array with at least `needed_capacity'. at offset (storage adress)
  (
    ? { needed_capacity >= 0 };
    ? { storage = NULL};
    storage := MAP_NATIVE_ARRAY[E].force_conversion offset;

    upper := -1;
    capacity := needed_capacity;
    
    ? { capacity = needed_capacity };    
  ); // end with_capacity .. at ..
    
  //
  // Modification
  //
  
  - set_capacity new_capacity:NUMERIC <-
  // Resize capacity the array, but not count.
  ( + old_capacity:INTEGER;
    
    ? {new_capacity >= 0};
    
    old_capacity := capacity;
    (new_capacity > capacity).if {
      ( capacity = 0).if {
	storage := MAP_NATIVE_ARRAY[E].calloc new_capacity;
      } else {
	storage := storage.realloc capacity with new_capacity;	
      }; // end if
      capacity := new_capacity;	
    }; // end if        
    
    ? { capacity >= old_capacity };    
  ); // end resize
  
  - shift_right other:INTEGER <-
  // Shift right the beginning of the table
  (
    ? {other < capacity};
    capacity := capacity - other;
    upper := upper - other;
    storage := storage + other;    
  );
  
  - clear <-
  (
    upper := -1;
  );
  
  - is_empty :BOOLEAN <-
  ( + result:BOOLEAN;
    result := upper < 0;
    ? { result = (count = 0)};
    result
  ); // end is_empty
  
  
  - item i:NUMERIC :E <- // Infix "@"
  (
    ? { valid_index i};
    storage.item i
  ); // end item
  
  
  - count :INTEGER <-
  ( + result:INTEGER;
    result := upper + 1;
    ? {result = upper - lower + 1};
    result
  ); // end count
    
  - valid_index index:NUMERIC :BOOLEAN <- 
  // True when `index' is valid (ie. inside actual
  // bounds of the collection).
  ( + result:BOOLEAN;
    result := (lower <= index.to_integer) && {upper >= index.to_integer};
    ? { result = (lower <= index.to_integer) && {upper >= index.to_integer}};
    result
  );
  
  - '=='  right 60 other:SELF :BOOLEAN <-
  ( + result:BOOLEAN;
    
    ( self = other).if {
      result := TRUE;
    }.elseif { upper = other.upper } then {
      result := storage.fast_memcmp (other.storage) until (upper + 1) ;
    }; // end if
    ? { result ->> {(lower = other.lower) & (upper = other.upper)}};
    result
  ); // end ==
  
  
  
  - is_equal_map other:SELF :BOOLEAN <- 
  ( + result:BOOLEAN;
    
    ( self = other).if {
      result := TRUE;
    }.elseif { upper = other.upper } then {
      result := storage.memcmp (other.storage) until (upper + 1);
    }; // end if
    ? { result ->> {(lower = other.lower) & (upper = other.upper)}};
    result
  ); // end is_equal_map
  
  - element_sizeof:INTEGER <- E.object_size;
/*    
  - valid_stream s:NUMERIC :BOOLEAN <-
  ( + result:BOOLEAN;
    
    ? {(s % element_sizeof.to_uinteger)=0};
    ? {E.object_size!=0};
    
    result := (s % element_sizeof.to_uinteger)=0;
    result := result && {E.object_size!=0};
    result
  );
  */  
  
  
  + ofs_buf:INTEGER;
    
  - add_last_buffer buf:FIXED_ARRAY[USMALLINT] from beg:NUMERIC to end:NUMERIC <-
  ( + tab:NATIVE_ARRAY[USMALLINT];
    + pos_beg,size,new_capacity:INTEGER;
    
    //? {! E.is_clonable};
    
    pos_beg := count * element_sizeof + ofs_buf;
    size    := end - beg + 1;
    
    new_capacity := (pos_beg + end - beg + element_sizeof) / element_sizeof;
    (capacity < new_capacity).if {
      "cap map:".print;
      capacity.print;
      "new:".print;
      new_capacity.print;
      "Crash !\n".print;
      crash;
    };
    
    tab := NATIVE_ARRAY[USMALLINT].force_conversion storage;
    tab.copy (buf.storage + beg) to pos_beg until size;
    ofs_buf := (pos_beg + size) % element_sizeof;
    upper   := (pos_beg + size - 1) / element_sizeof;
  );
  
  - add_last_buffer_bug buf:FIXED_ARRAY[USMALLINT] from beg:NUMERIC to end:NUMERIC <-
  ( + pos,ofs:INTEGER;
    + tab:NATIVE_ARRAY[USMALLINT];
    
    ? {! E.is_clonable};
    ? {((end - beg + 1) % element_sizeof) = 0};
    
    // BSBS: Peu faire mieux directement avec les storages...
    beg.to end do { j:INTEGER;
      (ofs=0).if {
	? {count < capacity};
	upper := upper + 1;	
      };
      tab := NATIVE_ARRAY[USMALLINT].force_conversion storage;
      pos := upper * element_sizeof + ofs;
      tab.put (buf.item j) to pos;
      ofs := (ofs + 1) % element_sizeof;
    };
  );
  
