/***************************************************************************
*                      Isaac Object Operating System                       *
*                             Isaac Library                                *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
***************************************************************************/

section HEADER

  - name    := TIMER;
  
  - category:=MICRO;
  
  - bibliography:="http://IsaacOS.com";

  - author      := "Benoit Sonntag (bsonntag@loria.fr), Jerome Boutet (boutet@loria.fr)";

  - comment     :="Unix - Timer management.";

  - version :="1.0";  

  - date    :="2003/04";
  
  - external := 
`
#include <signal.h>
#define __BEGIN_INTERRUPT__
#define __END_INTERRUPT__
XEvent timer_ev;
`;
  
section INHERIT  
  
  * parent_input:INPUT;
  
section PRIVATE
  
  - timer_count:UINTEGER;
  
  + buffer_event:MAP_FIXED_ARRAY[EVENT_TIMER];
  
  - p_beg:USMALLINT;  // Pointer on the buffer (beginning)
  
  - p_end:USMALLINT;  // Pointer on the buffer (end)
    
section INTERRUPT  
  
  - timer_interrupt <-  
  ( + tmp:USMALLINT;     
    
    timer_count := timer_count + 1;
    
    tmp:=(p_end+1)&003h;
    buffer_event.item p_end.make timer_count; 
    (((tmp+2)&3)!=p_beg).if {
      p_end:=tmp;
    };
    // ((timer_count % 20)=0).if {
    //   CLOCK.rtc;
    // };
    
    (`is_sleep`:INTEGER = 1).if {
      `timer_ev.type           = ClientMessage`;
      `timer_ev.xclient.format = 32`;
      (`XSendEvent(display,window,0,ClientMessage,&timer_ev)`:INTEGER != 0).if {
	`XFlush(display)`;
      };
    };
    `ualarm(50000,0)`;    
  );
  
section PUBLIC

  - make <-
  ( + hdle:POINTER;
    //
    // Software configuration.
    //
    buffer_event := MAP_FIXED_ARRAY[EVENT_TIMER].create 4;
    0.to 3 do { j:INTEGER;
      buffer_event.item j.set_prev (buffer_event.item ((j-1)&3));
    };
        
    hdle := timer_interrupt;
    `signal(SIGALRM,@hdle)`;
    `ualarm(500000,0)`;
  );

  - acknowledge <-
  (
    p_beg := (p_beg+1) & 03h;
  );

  - get_event <-
  ( + p:INTEGER;
    + evt:EVENT_TIMER;
    
    p := p_beg;
    { p != p_end }.while_do {
      evt := buffer_event.item p;
      (list_client.lower).to (list_client.upper) do { j:INTEGER;
	list_client.item j.receive (buffer_event.item p);
      };      
      p := (p + 1) & 03h;
    };    
  );


/* 
//Other solution :
void catcher( int sig ) {

    time_count ++;
}

int main( int argc, char *argv[] ) {

  int old_time;

    struct itimerval value;

    signal(SIGALRM,catcher);

    value.it_interval.tv_sec = 1;   
    value.it_interval.tv_usec = 0;  
    value.it_value.tv_sec = 1;      
    value.it_value.tv_usec = 0;     

    setitimer(ITIMER_REAL, &value, NULL); 

    while (1) {
      if (old_time != time_count) {
	printf("Time %ld\n",time_count);
	old_time = time_count;
      };
    };

    return(0);
}
*/