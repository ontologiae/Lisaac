<?xml version="1.0" encoding="UTF-8"?>
<!--kate: encoding: utf-8; indent-mode: xml; space-indent off; indent-width 4;
   kate: tab-width 4; remove-trailing-space on; -->
<!--**********************************************************************
*   Copyright (C) 2007 by Anthony Pajot   								  *
*   anthony.pajot@etu.enseeiht.fr   									  *
*                                                                         *
*   This program is free software; you can redistribute it and/or modify  *
*   it under the terms of the GNU General Public License as published by  *
*   the Free Software Foundation; either version 2 of the License, or     *
*   (at your option) any later version.                                   *
*                                                                         *
*   This program is distributed in the hope that it will be useful,       *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
*   GNU General Public License for more details.                          *
*                                                                         *
*   You should have received a copy of the GNU General Public License     *
*   along with this program; if not, write to the                         *
*   Free Software Foundation, Inc.,                                       *
*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***********************************************************************-->


<!DOCTYPE language SYSTEM "language.dtd"
		[
		<!-- toutes les regexps associés aux terminaux -->
		<!ENTITY section		"(Private|Public|Directory|Header|Mapping|Interrupt|Inherit|Insert|External)">
		<!ENTITY lower_case 	"[a-z]">
		<!ENTITY upper_case 	"[A-Z]">
		<!ENTITY octal_digit	"[0-7]">
		<!ENTITY decimal_digit 	"[0-9]">
		<!ENTITY hexa_digit		"[0-9a-fA-F]">
		<!ENTITY binary_digit	"[0-1]">
		<!ENTITY normal_char	"[^&apos;\\&quot;]">
		<!ENTITY integer_number	"&decimal_digit;(_|&decimal_digit;)*">
		<!ENTITY number			"((&octal_digit;(_|&octal_digit;)*o)|&integer_number;(d?)|(&hexa_digit;(_|&hexa_digit;)*h)|(&binary_digit;(_|&binary_digit;)*b))">
   		<!ENTITY integer		"&number;(KB|MB|GB)?">
		<!ENTITY integer_or_real "(&integer;|(&integer_number;[.]&integer_number;(E([+-])?&integer_number;)?))">
		<!ENTITY characters		"\&apos;(&normal_char;|&escape_char;|&quot;)*\&apos;">
		<!ENTITY characters_start	"\&apos;">
		<!ENTITY string			"\&quot;(&normal_char;|&escape_char;|&apos;|)*\&quot;">
		<!ENTITY string_start	"\&quot;">
		<!ENTITY numeric_escape	"\\&integer_or_real;\\">
		<!ENTITY op_char_list	"!@#$^&amp;&lt;&gt;|*+=~/?\\:\-&#37;">
		<!ENTITY op_char 		"[&op_char_list;]">
		<!ENTITY escape_char	"([\\][tbnfrva0?\\ ]|&numeric_escape;|\\|)">
		<!ENTITY identifier 	"(&lower_case;(&lower_case;|&decimal_digit;|_)*)">
		<!ENTITY not_identifier	"([^a-z0-9_])">
		<!ENTITY ws				"([\s])">
		<!ENTITY ws_opt			"&ws;*">
		<!--oom = one or more-->
		<!ENTITY ws_oom			"&ws;+">
		<!--ici, :=, <- et ?= seront aussi pris. donc dans les contextes ayant ca,
						  il faudra mettre la regle d'affectation avant -->
		<!ENTITY operator 		"&op_char;+">
		<!ENTITY affect 		"(:=|&lt;-|[?]=)">
		<!ENTITY cap_idf_item	"&upper_case;(&upper_case;|&decimal_digit;|_)*">
		<!ENTITY cap_identifier	"&cap_idf_item;(\.&cap_idf_item;)*(\.(\.&cap_idf_item;)+)?">
		<!ENTITY external		"\`(&normal_char;|&escape_char;)*\`">
		<!ENTITY external_start	"\`">
		<!ENTITY priority		"(Left|Right)">
		<!ENTITY style			"[+-]">

        <!ENTITY type			"(Expanded|Separate|Strict)">
        <!ENTITY result			"Result(_&decimal_digit;(&decimal_digit;)*)?">


		<!--le début de non terminaux, parce que c'est long sinon -->
        <!ENTITY start_loc_arg	"([(]&ws_opt;&start_local;|&identifier;&ws_opt;:[^=])" >
		<!ENTITY start_local	"&identifier;&ws_opt;([,]&ws_opt;&identifier;&ws_opt;)*(:[^=])" >
        <!ENTITY start_type		"(&type;|&cap_identifier;)" >
		<!ENTITY start_type_list	"&start_type;" >
		<!ENTITY start_send_msg	"&identifier;" >
		<!ENTITY start_expr_primary "(Self|&cap_identifier;|&result;|&integer_or_real;|&characters_start;|&string_start;|[({]|&external_start;)">
		<!ENTITY start_expr_base	"(&start_expr_primary;|Old|&start_send_msg;)">
		<!ENTITY start_expr_message	"&start_expr_base;">
		<!ENTITY start_expr_prefix	"(&operator;|&start_expr_base;)" >
		<!ENTITY start_expr			"&start_expr_prefix;">
		<!ENTITY start_group		"(&start_def_local;|&start_expr;)"> <!--les groupes vides sont pris en compte
																				indirectements-->
		<!ENTITY start_def_local	"&style;&ws_opt;&start_local;">
		<!ENTITY start_argument		"(&identifier;|&start_expr_primary;)">
		<!ENTITY start_contract		"\[">
		<!ENTITY start_slot			"&style;">

		<!--ce qui peut suivre certains non terminaux-->
		<!ENTITY following_type_slot	"(:|&affect;|;)" >
		<!ENTITY following_local	"([)]|;)" >
		<!ENTITY following_type_list	"([)]|&start_slot;|Section|&start_contract;|&identifier;|\]|;|-|&lt;|,&ws_opt;[(])" > <!--les 3 derniers viennent de la gestion des fleches d'autocast et des exports/imports de vecteurs (-> TEST, (...))-->
		<!ENTITY following_loc_arg	"(&identifier;|&following_type_slot;|;)" >
		<!ENTITY following_group	"([)]|[}])" >
		<!ENTITY following_expr		"(&start_contract;|;|,|&following_group;)" >
		<!ENTITY following_expr_prefix	"(&affect;|&operator;|&following_expr;)" >
		<!ENTITY following_expr_message	"(&following_expr_prefix;)" >
		<!ENTITY following_expr_base	"([.]|&following_expr_message;)" >
		<!ENTITY following_send_msg		"(&following_expr_base;|[.]|&following_expr_message;)" >
		<!ENTITY following_expr_primary	"(&identifier;|&following_send_msg;|[.]|&following_expr_message;)" >
		<!ENTITY following_prototype		"(&following_loc_arg;|&following_local;|,|[(]|&following_expr_primary;|&following_type_list;)" >
		<!ENTITY following_def_local		"(&start_expr;|&following_group;|[.][.][.]||\])" >
		<!ENTITY following_type		"(&following_prototype;)" >

		<!--d'autres regexps utiles de temps à autres-->
		<!ENTITY bad_operator	"(&affect;|:)[^&op_char_list;]">
		<!ENTITY approx_type	"(&cap_identifier;|\[|\]|&ws_oom;|,|Separate|Expanded)">

		<!--quelques couleurs ou options d'attributs communes-->
		<!ENTITY punctuation_style 	"dsNormal">
		<!ENTITY punctuation_color 	"black">
		<!ENTITY punctuation_bold  	"1">

		<!ENTITY import_related_item_color  	"darkorange">
		<!ENTITY export_related_item_color  	"orange">

]>


<!-- ~/.kde/share/apps/katepart/syntax/lisaac.xml -->
<!-- http://kate.kde.org/doc/hlhowto.php -->
<!-- http://wiki.kde.org/tiki-index.php?page=Configuring+Kate+with+variables -->
<!-- http://www.kate-editor.org/article/writing_a_kate_highlighting_xml_file -->
<!-- Created By Anthony Pajot <Anthony.Pajot@etu.enseeiht.fr> -->
<!-- thanks to Mildred for his additions -->	
<language name="Lisaac v0.2" version="2.02" kateversion="2.3" section="Sources" extensions="*.li" mimetype="text/x-li" casesensitive="true" author="Anthony Pajot ( anthony.pajot@etu.enseeiht.fr )" license="GPL v2">
    <highlighting>
        <contexts>
		   <!--#################################################################
			PROGRAM -> {'Section'(section|TYPE_LIST){SLOT}}[CONTRACT';']
		    ___
			PROGRAM -> lambda {$}
			PROGRAM -> 'Section' PROGRAM_SECTION_DEC PROGRAM_SLOT PROGRAM {'Section'}
            PROGRAM -> CONTRACT ';' {'['}
			PROGRAM_SECTION_DEC -> Section {Section}
			PROGRAM_SECTION_DEC -> TYPE_LIST {START_TYPE}
			PROGRAM_SLOT -> lambda {'Section', $}
			PROGRAM_SLOT -> SLOT PROGRAM_SLOT {style}
			################################################################# -->
		   <context name="program_r1" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="Section" context="program_section_declaration" attribute="section_declaration"
				beginRegion="Section" />

				<!--pour program_slot -> lambda, on ne s'en occupe pas car on reste ici -->
				<RegExpr String="&style;" lookAhead="true" context="program_slot_r2" />

                <RegExpr String="&start_contract;" lookAhead="true" context="program_contract" />				
			</context>

			<context name="program_contract" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_contract;" lookAhead="true" context="contract" />
				<DetectChar char=";" context="#stay" attribute="semi_colon_ending_program_contract" /> <!--on devrait être à la fin de toute facon.-->
			</context>

			<context name="program_section_declaration" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="Header" context="program_header_section" attribute="header_section_name" />
				<RegExpr String="(Inherit|Insert)" context="program_inherit_section" attribute="inherit_section_name" />

				<RegExpr String="&section;" context="#pop" attribute="section_name" />

				<RegExpr String="&start_type;" lookAhead="true" context="program_section_type_list" />
			</context>

			<context name="program_section_type_list" fallthrough="true" fallthroughContext="error">
            	<IncludeRules context="comments_and_spaces" />

				<RegExpr String="(&style;|Section)" lookAhead="true" context="#pop#pop" /> <!--program_r1-->
                <RegExpr String="&start_type;" lookAhead="true" context="header_type_list" />
                
            </context>

			<context name="program_slot_r2" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <RegExpr String="&style;" lookAhead="true" context="slot" />
				<RegExpr String="(Section|&start_contract;)" lookAhead="true" context="#pop" endRegion="Section" /> <!--slot_program_r1-->
            </context>

			<context name="program_header_section" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <RegExpr String="&style;&ws_opt;name[^a-z0-9_]" lookAhead="true" context="program_name_slot" />

                <RegExpr String="&style;" lookAhead="true" context="slot" />
				<!--pour program_slot -> lambda, on ne s'en occupe pas car on reste ici -->

                <RegExpr String="(&start_contract;|Section)" lookAhead="true" context="#pop#pop" /> <!--remontée au 1er niveau -->
            </context>

   			<context name="program_name_slot" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <RegExpr String="&style;" context="#stay" attribute="slot_style" />
				<RegExpr String="name" context="program_name_slot_dec" attribute="prototype_name_slot" />
                <DetectChar char=";" context="#pop" attribute="semi_colon_ending_slot" />
			</context>

   			<context name="program_name_slot_dec" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<Detect2Chars char=":" char1="=" context="type" attribute="slot_affectation" />

                <DetectChar char=";" lookAhead="true" context="#pop" />

                <Detect2Chars char="-" char1="&gt;" lookAhead="true" context="program_name_auto_cast" />
				<Detect2Chars char="&lt;" char1="-" lookAhead="true" context="program_name_auto_cast" />
            </context>

            <context name="program_name_auto_cast" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<Detect2Chars char="-" char1="&gt;" context="program_name_auto_cast_type_list" attribute="exported_types_arrow" />
				<Detect2Chars char="&lt;" char1="-" context="program_name_auto_cast_type_list" attribute="imported_types_arrow" />

                <DetectChar char=";" lookAhead="true" context="#pop" />
            </context>

			<context name="program_name_auto_cast_type_list" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				
				<RegExpr String="&start_type;" lookAhead="true" context="type_list" />

				<DetectChar char="," context="#stay" attribute="comma_separating_types" />
				<DetectChar char="(" context="type_list" attribute="parenthesis_enclosing_infix_params" />
				<DetectChar char=")" context="#stay" attribute="parenthesis_enclosing_infix_params" />
				
				<RegExpr String="(;|&lt;[-]|[-]&gt;)" lookAhead="true" context="#pop" />
            </context>


			<context name="program_inherit_section" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <RegExpr String="&style;" context="program_inherit_slot_name" attribute="slot_style" />


                <RegExpr String="(&start_contract;|Section)" lookAhead="true" context="#pop#pop" endRegion="Section" /> <!--remontée au 1er niveau -->
            </context>

            <context name="program_inherit_slot_name" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <RegExpr String="&identifier;" context="program_inherit_slot_return_type" attribute="inherit_slot_name" />


                <DetectChar char=";" context="#pop" attribute="semi_colon_ending_slot" />
            </context>

            <context name="program_inherit_slot_return_type" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&affect;" context="def_slot" attribute="slot_affectation" />

                <DetectChar char=":" context="type" attribute="colon_before_return_type" />

				<DetectChar char=";" lookAhead="true" context="#pop" />

            </context>


            <!--##################################################################
            SLOT -> style ['(' LOCAL ')'] TYPE_SLOT[':'(TYPE | '(' TYPE_LIST ')')][affect DEF_SLOT]';'
            ___
            SLOT -> style SLOT_INFIX_PARAMS TYPE_SLOT SLOT_RETURN_TYPE SLOT_AFFECTED_DEF_SLOT ';' {style}
            SLOT_INFIX_PARAMS -> lambda {identifier|"'"}
            SLOT_INFIX_PARAMS -> '(' LOCAL ')' {'('}
            SLOT_RETURN_TYPE -> lambda {affect}
            SLOT_RETURN_TYPE -> ':' SLOT_RETURNED {':'}
            SLOT_RETURNED -> TYPE {start_type }
            SLOT_RETURNED -> '(' TYPE_LIST ')' {'(' }
            SLOT_AFFECTED_DEF_SLOT -> lambda {';'}
            SLOT_AFFECTED_DEF_SLOT -> affect DEF_SLOT {'affect'}
            ##################################################################-->
			<context name="slot" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&style;" context="slot_infix_params" attribute="slot_style" beginRegion="slot" />
				<RegExpr String="(&identifier;|&apos;)" lookAhead="true" context="type_slot" />
                <RegExpr String=":[^=]" lookAhead="true" context="slot_return_type" />
                <RegExpr String="&affect;" lookAhead="true" context="slot_affected_def_slot" />
				<DetectChar char=";" context="#pop" attribute="semi_colon_ending_slot" endRegion="slot"/>
            </context>

			<context name="slot_infix_params" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<DetectChar char="(" attribute="parenthesis_enclosing_infix_params" context="local" />
   				<DetectChar char=")" attribute="parenthesis_enclosing_infix_params" context="#pop" />
				<!--cas où y en a pas -->
				<RegExpr String="(&identifier;|&apos;)" lookAhead="true" context="#pop" />
            </context>

			<context name="slot_return_type" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="(&affect;|;)" lookAhead="true" context="#pop" />
				<DetectChar char=":" context="slot_returned" attribute="colon_before_return_type" /> <!--on fait passer le ":" tout seul après l'affectation, sinon une affectation du type := serait bouffée par le ":" tout seul-->
            </context>

            <context name="slot_returned" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="(&affect;|;)" lookAhead="true" context="#pop" />
				<RegExpr String="&start_type;" lookAhead="true" context="type" /> <!--on fait passer le ":" tout seul apr� l'affectation, sinon une affectation du type := serait bouff� par le ":" tout seul-->
                <DetectChar char="(" context="type_list" attribute="parenthesis_enclosing_returned_types" />
                <DetectChar char=")" context="#pop" attribute="parenthesis_enclosing_returned_types" />
            </context>

			<context name="slot_affected_def_slot" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&affect;" context="def_slot" attribute="slot_affectation" />
				<DetectChar char=";" lookAhead="true" context="#pop" />
            </context>

			<!--#################################################################
			DEF_SLOT -> [CONTRACT] EXPR [CONTRACT]
			___
			DEF_SLOT -> CONTRACT DEF_SLOT_EXPR {start_contract}
			DEF_SLOT -> DEF_SLOT_EXPR {start_expr}
			DEF_SLOT_EXPR -> EXPR DEF_SLOT_END_CONTRACT
			DEF_SLOT_END_CONTRACT -> lambda {style|'Section'|$}
			DEF_SLOT_END_CONTRACT -> CONTRACT {start_contract}
			###################################################################-->
			<context name="def_slot" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_contract;" lookAhead="true" context="contract" />
				<RegExpr String="&start_expr;" lookAhead="true" context="def_slot_expr" />
				<RegExpr String=";" lookAhead="true" context="#pop" />
			</context>

			<context name="def_slot_expr" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_expr;" lookAhead="true" context="expr" />
				<RegExpr String=";" lookAhead="true" context="#pop" />
				<!--pour le contrat de fin -->
				<RegExpr String="&start_contract;" lookAhead="true" context="def_slot_expr_contract" />
			</context>

			<context name="def_slot_expr_contract" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_contract;" lookAhead="true" context="contract" />
				<RegExpr String=";" lookAhead="true" context="#pop" />
			</context>

			<!-- #################################################################
			LOC_ARG -> identifier ':' TYPE | '(' LOCAL ')'
			___
			LOC_ARG -> identifier LOC_ARG_IDENT_TYPE {identifier}
			LOC_ARG -> LOC_ARG_LOCAL {'('}
			LOC_ARG_IDENT_TYPE -> ':' TYPE
			LOC_ARG_LOCAL -> '(' LOCAL ')'
			###################################################################-->
			<context name="loc_arg" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&identifier;" context="loc_arg_ident" attribute="declared_variable_name" />
				<DetectChar char="(" lookAhead="true" context="loc_arg_local" />
			</context>

			<context name="loc_arg_ident" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				<!--pour eviter de consommer le type de retour d'un slot -->
				<DetectChar char=":" context="loc_arg_ident_type" attribute="colon_before_type" />
			</context>

			<context name="loc_arg_ident_type" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_type;" lookAhead="true" context="type" />

				<RegExpr String="&following_loc_arg;" lookAhead="true" context="#pop#pop#pop" />
			</context>


			<context name="loc_arg_local" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<DetectChar char="(" context="local" attribute="parenthesis_enclosing_local_arguments" />

				<DetectChar char=")" context="#pop#pop" attribute="parenthesis_enclosing_local_arguments" />
			</context>



            <!--#################################################################
            TYPE_SLOT -> identifier [LOC_ARG {identifier LOC_ARG}]
            TYPE_SLOT -> "'"operator"'" [priority[integer]] LOC_ARG
            ___
            TYPE_SLOT -> identifier TYPE_SLOT_PARAMS {identifier}
            TYPE_SLOT_PARAMS -> lambda {':', affect, ';'}
            TYPE_SLOT_PARAMS -> LOC_ARG TYPE_SLOT_KEYWORD_PARAM {'(', identifier}
            TYPE_SLOT_KEYWORD_PARAM -> lambda {':', affect, ';'}
            TYPE_SLOT_KEYWORD_PARAM -> identifier LOC_ARG TYPE_SLOT_KEYWORD_PARAM {identifier}

            TYPE_SLOT -> "'"operator"'" TYPE_SLOT_PRIORITY TYPE_SLOT_PARAM {"'"}
            TYPE_SLOT_PRIORITY -> lambda {identifier, ':', affect, ';'}
            TYPE_SLOT_PRIORITY -> priority TYPE_SLOT_PRIORITY_VALUE {priority}
            TYPE_SLOT_PRIORITY_VALUE -> lambda {identifier, '(', ':', affect, ';'}
            TYPE_SLOT_PRIORITY_VALUE -> integer {integer}
            TYPE_SLOT_PARAM -> lambda {':', affect, ';'}
            TYPE_SLOT_PARAM -> LOC_ARG
            ###################################################################-->
			<context name="type_slot" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <!--on differencie pour les fonctions d'auto_cast, sans params pour to et un seul pour from-->
                <RegExpr String="to_&identifier;&ws_opt;:" lookAhead="true" context="type_slot_auto_cast_slot" />
				<RegExpr String="from_&identifier;&ws_oom;&identifier;&ws_opt;:&ws_opt;&approx_type;&ws_opt;:" lookAhead="true" context="type_slot_auto_cast_slot" />

                <RegExpr String="&identifier;" context="type_slot_params" attribute="slot_name" />
                <RegExpr String="&apos;&operator;&apos;" context="type_slot_priority" attribute="slot_operator" />
				<RegExpr String="&following_type_slot;" lookAhead="true" context="#pop" />
			</context>

            <context name="type_slot_auto_cast_slot" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <RegExpr String="to_&identifier;" context="#pop" attribute="exporting_slot_name" /> <!--type_slot fini-->
				<RegExpr String="from_&identifier;" context="type_slot_params" attribute="importing_slot_name" /> <!--type_slot pas fini, il y a un param-->

				<RegExpr String="&following_type_slot;" lookAhead="true" context="#pop" />

			</context>

			<context name="type_slot_params" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <RegExpr String="&start_loc_arg;" lookAhead="true" context="loc_arg" />
                <!-- ws_opt car on peut avoir ident(LOCAL)-->
                <!--<RegExpr String="&identifier;(&ws_opt;&start_loc_arg;)" lookAhead="true" context="type_slot_keyword_param" />-->
				<RegExpr String="&identifier;" lookAhead="true" context="type_slot_keyword_param" />
				<RegExpr String="&following_type_slot;" lookAhead="true" context="#pop" /> <!--type_slot_params_r1-->
            </context>

			<context name="type_slot_keyword_param" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

                <RegExpr String="&identifier;" context="loc_arg" attribute="slot_keyword" />
				<RegExpr String="&following_type_slot;" lookAhead="true" context="#pop" /> <!--type_slot_keyword_param_r1-->
            </context>

			<context name="type_slot_priority" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&priority;" context="type_slot_priority_value" attribute="slot_operator_priority" />

				<RegExpr String="&start_loc_arg;" lookAhead="true" context="loc_arg" />
				<RegExpr String="&following_type_slot;" lookAhead="true" context="#pop" />
            </context>

			<context name="type_slot_priority_value" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="(&start_loc_arg;|&following_type_slot;)" lookAhead="true" context="#pop" /><!--type_slot_priority_value_r1-->
                <RegExpr String="&integer;" context="#pop" attribute="slot_operator_priority_value" />
            </context>

            <!--#################################################################
                LOCAL -> {identifier[':'TYPE]','} identifier':'TYPE
                ___
                /*l'algorithme donne ca, mais ce n'est pas LL(1) => on utilise une version
                moins puissante mais LL(1). Son défaut est qu'elle ne detecte pas le cas où
                le dernier identifiant n'est pas suivi d'un type.

                LOCAL -> LOCAL_PARAMS_LIST identifier LOCAL_PARAM_TYPE {identifier}
                LOCAL_PARAMS_LIST -> lambda {pas de virgule, utiliser la prise en compte de l'ordre des règles.}
                LOCAL_PARAMS_LIST -> identifier LOCAL_PARAM_OPTIONAL_TYPE ',' LOCAL_PARAMS_LIST {identifier}
                LOCAL_PARAM_OPTIONAL_TYPE -> lambda {','}
                LOCAL_PARAM_OPTIONAL_TYPE -> ':' TYPE {':'}
                LOCAL_PARAM_TYPE -> ':' TYPE {':'}*/
				____ solution implémentée, qui n'a pas le défaut de la version d'au dessus :
                LOCAL :
                    identifier ":" -> LOCAL_WITH_TYPE (en lookAhead)
                    identifier "," -> LOCAL_FOLLOWING (en lookAhead)
                LOCAL_WITH_TYPE -> identifier LOCAL_TYPE
                LOCAL_TYPE -> ':' TYPE LOCAL_FOLLOWING
                LOCAL_FOLLOWING -> ','LOCAL {','}
                LOCAL_FOLLOWING -> lambda {identifier, ':', ';', affect}
            	################################################################# -->
			<context name="local" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<DetectChar char="," lookAhead="true" context="local_parameter" /> <!--pour gerer les remontées qui sont effectuées lors d'analyse de texte de la forme - slot item : TYPE, item1, item2 : TYPE2 -->

				<RegExpr String="&identifier;&ws_oom;&identifier;" lookAhead="true" context="#pop" /> <!--quand on remonte d'un texte du type - slot item : TYPE keyword item2 ... , à la fin de TYPE on ne remonte qu'ici, ce qui, sans la regle précedente, fait que keyword est analysé comme un parametre.-->

				<RegExpr String="&identifier;" context="local_parameter" attribute="declared_variable_name" />

				<RegExpr String="&following_local;" lookAhead="true" context="#pop" />
            </context>

			<context name="local_parameter" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<Detect2Chars char=":" char1="=" context="error" />
				<DetectChar char=":" context="local_with_type" attribute="colon_before_type" />
				<DetectChar char="," context="#pop" attribute="comma_separating_parameters" />
            </context>

			<context name="local_with_type" fallthrough="true" fallthroughContext="#pop#pop">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_type;" lookAhead="true" context="type" />
            </context>

            <!--#################################################################
                TYPE_LIST -> TYPE {',' TYPE}
                ################################################################# -->
			<context name="header_type_list" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				
				<StringDetect String="Section" lookAhead="true" context="#pop" />
				<RegExpr String="&start_type;" lookAhead="true" context="header_type" />
				<DetectChar char="," context="header_type" attribute="comma_separating_header_types" />
				
				<RegExpr String="&following_type_list;" lookAhead="true" context="#pop" />
			</context>
			
			<context name="type_list" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				<!--avant à cause de ", (" possible dans l'import/export de vecteur -->
				<RegExpr String="&following_type_list;" lookAhead="true" context="#pop" />
				
				<RegExpr String="&start_type;" lookAhead="true" context="type" />
				<DetectChar char="," context="type" attribute="comma_separating_types" />
				
			</context>
			
			
			<!--#################################################################
			TYPE -> [type] PROTOTYPE
			___
			TYPE -> type PROTOTYPE (type}
			TYPE -> PROTOTYPE {cap_identifier}
			################################################################# -->
			<context name="header_type" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				<StringDetect String="Section" lookAhead="true" context="#pop" />
				<RegExpr String="&type;" context="header_prototype" attribute="lisaac_keyword" />
				<RegExpr String="&cap_identifier;" lookAhead="true" context="header_prototype" />
				
				<RegExpr String="&following_type;" lookAhead="true" context="#pop" />
			</context>
			<context name="type" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				<RegExpr String="&type;" context="prototype" attribute="lisaac_keyword" />
				<RegExpr String="&cap_identifier;" lookAhead="true" context="prototype" />
				
				<RegExpr String="&following_type;" lookAhead="true" context="#pop" />
			</context>
			
			<!--#################################################################
			PROTOTYPE -> cap_identifier['('TYPE_LIST {identifier TYPE_LIST} ')']
			___
			PROTOTYPE -> cap_identifier GENERIC_TYPE {cap_identifier}
			GENERIC_TYPE -> lambda {si pas de '('}
			GENERIC_TYPE -> '['GENERIC_TYPE_LIST']' {'('}
			GENERIC_TYPE_LIST -> TYPE_LIST GENERIC_TYPE_LIST_FOLLOWING {start_type}
			GENERIC_TYPE_LIST_FOLLOWING -> lambda {')'}
			GENERIC_TYPE_LIST_FOLLOWING -> 'identifier TYPE_LIST GENERIC_TYPE_LIST_FOLLOWING {identifier}
			################################################################# -->
			<context name="header_prototype" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				
				<StringDetect String="Section" lookAhead="true" context="#pop" />
				<RegExpr String="&cap_identifier;" context="#stay" attribute="header_type" />
				<DetectChar char="(" lookAhead="true" context="header_generic_type" />
				
				<RegExpr String="&following_prototype;" lookAhead="true" context="#pop" />
			</context>
			<context name="prototype" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				
				<RegExpr String="&cap_identifier;" context="#stay" attribute="type" />
				<DetectChar char="(" lookAhead="true" context="generic_type" />
				
				<RegExpr String="&following_prototype;" lookAhead="true" context="#pop" />
			</context>
			
			<context name="header_generic_type" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				
				<DetectChar char="(" context="header_generic_type_list" attribute="header_generic_type_bracket" />
				<DetectChar char=")" context="#pop" attribute="header_generic_type_bracket" />
			</context>
			<context name="generic_type" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				
				<DetectChar char="(" context="generic_type_list" attribute="generic_type_bracket" />
				<DetectChar char=")" context="#pop" attribute="generic_type_bracket" />
			</context>
			
			<context name="header_generic_type_list" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				
				<!--on rajoute following_type_list pour eviter de boucler dans le cas où un truc
					   commencant comme un type mais faisant parti de following_type_list est trouvé avant "]".
					   l'erreur sera trouvée après.-->
				<RegExpr String="(\)|&following_type_list;)" lookAhead="true" context="#pop" />
				<RegExpr String="&start_type;" lookAhead="true" context="header_type_list" />
				<RegExpr String="&identifier;" lookAhead="true" context="generic_type_list_following" />
				
				<!--attention, ceci n'interdit pas d'avoir [identifier TYPE1...], donc c'est une approximation-->
			</context>
			<context name="generic_type_list" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<!--on rajoute following_type_list pour eviter de boucler dans le cas où un truc
					   commencant comme un type mais faisant parti de following_type_list est trouvé avant "]".
					   l'erreur sera trouvée après.-->
				<RegExpr String="(\)|&following_type_list;)" lookAhead="true" context="#pop" />
				<RegExpr String="&start_type;" lookAhead="true" context="type_list" />
				<RegExpr String="&identifier;" lookAhead="true" context="generic_type_list_following" />
				
				<!--attention, ceci n'interdit pas d'avoir [identifier TYPE1...], donc c'est une approximation-->
			</context>
			
			<context name="generic_type_list_following" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				
				<DetectChar char=")" lookAhead="true" context="#pop" />
				<RegExpr String="&identifier;" context="type_list" attribute="identifier_separating_types" />
            </context>


            <!--#################################################################
			EXPR -> EXPR_PREFIX ( [affect EXPR] | {operator EXPR_PREFIX})
            ===>
			truc considéré :
			EXPR -> {operator} EXPR_MESSAGE ( [affect EXPR] | {operator {operator} EXPR_MESSAGE})
			____
			EXPR -> EXPR_OPERATORS EXPR_FOLLOWING
			EXPR_OPERATORS -> lambda {start_expr_message}
			EXPR_OPERATORS -> operator EXPR_INFIX_OPERATORS {operator}
			EXPR_FOLLOWING -> EXPR_MESSAGE EXPR_CONTINUE {start_expr_message}
			EXPR_CONTINUE -> lambda {';', ')', '}'}
			EXPR_CONTINUE -> affect EXPR {affect}
			EXPR_CONTINUE -> operator EXPR_OPERATORS EXPR_MESSAGE EXPR_CONTINUE {operator}

			################################################################# -->
			<context name="expr" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&operator;" lookAhead="true" context="expr_operators" />
                <RegExpr String="&start_expr_message;" lookAhead="true" context="expr_following" />

				<RegExpr String="&following_expr;" lookAhead="true" context="#pop" />
			</context>

			<context name="expr_operators" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_expr_message;" lookAhead="true" context="#pop" />
				<RegExpr String="&operator;" context="#stay" attribute="operator_before_expression" />
			</context>

			<context name="expr_following" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_expr_message;" lookAhead="true" context="expr_message" />
				<RegExpr String="(&operator;|&affect;)" lookAhead="true" context="expr_continue" />

				<RegExpr String="&following_expr;" lookAhead="true" context="#pop" />
			</context>

			<context name="expr_continue" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&affect;" context="expr" attribute="affectation" />
				<RegExpr String="&operator;" lookAhead="true" context="expr_continue_treatment" />

				<RegExpr String="&following_expr;" lookAhead="true" context="#pop" />
			</context>

			<context name="expr_continue_treatment" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&bad_operator;" lookAhead="true" context="error" />
				<RegExpr String="&operator;" context="expr_operators" attribute="operator_between_expressions"/>

				<RegExpr String="&start_expr_message;" lookAhead="true" context="expr_message" />

				<RegExpr String="&following_expr;" lookAhead="true" context="#pop" />
			</context>


            <!--#################################################################
				EXPR_MESSAGE -> EXPR_BASE{'.'SEND_MSG}
    			___
				EXPR_MESSAGE -> EXPR_BASE EXPR_MESSAGE_SLOT_CALL {start_expr_primary}
				EXPR_MESSAGE_SLOT_CALL -> lambda {operator, ';', '}', ')' }
				EXPR_MESSAGE_SLOT_CALL -> '.'SEND_MSG EXPR_MESSAGE_SLOT_CALL {'.'}

            	################################################################# -->
			<context name="expr_message" fallthrough="true" fallthroughContext="error" lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_expr_base;" lookAhead="true" context="expr_base" />
				<DetectChar char="." lookAhead="true" context="expr_message_slot_call" />

				<RegExpr String="&following_expr_message;" lookAhead="true" context="#pop" />
            </context>

			<context name="expr_message_slot_call" fallthrough="true" fallthroughContext="error" lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />

				<DetectChar char="." context="send_msg" attribute="slot_call_dot" />

				<RegExpr String="&following_expr_message;" lookAhead="true" context="#pop" /><!--&following_expr_message;-->
			</context>

			<!--#################################################################
			EXPR_BASE -> EXPR_PRIMARY | SEND_MSG | "Old" EXPR
			___
			EXPR_BASE -> "Old" EXPR_BASE_FOLLOWING
			EXPR_BASE -> SEND_MSG
			EXPR_BASE -> EXPR_PRIMARY
			EXPR_BASE_FOLLOWING -> identifier
			################################################################# -->
			<context name="expr_base" fallthrough="true" fallthroughContext="error" lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="Old" context="expr" attribute="lisaac_keyword" />
				<RegExpr String="&start_send_msg;" lookAhead="true" context="send_msg_implicit" />
				<!-- mise de expr_primary après à cause des ident qui
					 commencent comme des chiffres hexa -->
				<RegExpr String="&start_expr_primary;" lookAhead="true" context="expr_primary" />
				<RegExpr String="&following_expr_base;" lookAhead="true" context="#pop" />
			</context>

			<!--<context name="expr_base_following" fallthrough="true" fallthroughContext="error" lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&identifier;" context="#pop" attribute="called_slot_name" />
				//<RegExpr String="(&operator;|[;)}])" lookAhead="true" context="#pop" />
			</context>-->

            <!--#################################################################
				EXPR_PRIMARY -> "Self"
				EXPR_PRIMARY -> result
				EXPR_PRIMARY -> integer
				EXPR_PRIMARY -> characters
				EXPR_PRIMARY -> string
				EXPR_PRIMARY -> '('GROUP')'
    			___
				pas de changement, les symboles directeurs sont triviaux

				EXPR_PRIMARY -> '{'[LOC_ARG ';'] GROUP'}'
				___
				EXPR_PRIMARY -> '{'EXPR_PRIMARY_BLOCK '}'
				EXPR_PRIMARY_BLOCK -> LOC_ARG ';' GROUP  {start_loc_arg}
				EXPR_PRIMARY_BLOCK -> GROUP {start_group}

				EXPR_PRIMARY -> PROTOTYPE
    			___
				EXPR_PRIMARY -> PROTOTYPE {cap_identifier}

				EXPR_PRIMARY -> external[':'['(']TYPE['{'{TYPE','}TYPE'}'][')']]
				___
				EXPR_PRIMARY -> external EXPR_PRIMARY1 {external}
				EXPR_PRIMARY_EXTERNAL_CAST -> lambda {'.', operator, ';', '}', ')' }
				EXPR_PRIMARY_EXTERNAL_CAST -> ':' EXPR_PRIMARY_EXTERNAL_TYPE {':'}
				EXPR_PRIMARY_EXTERNAL_TYPE -> '(' EXPR_PRIMARY_EXTERNAL_MAIN_TYPE ')' {'('}
				EXPR_PRIMARY_EXTERNAL_TYPE -> EXPR_PRIMARY_EXTERNAL_MAIN_TYPE {cap_identifier}
				EXPR_PRIMARY_EXTERNAL_MAIN_TYPE -> TYPE EXPR_PRIMARY_EXTERNAL_SUB_TYPES
				EXPR_PRIMARY_EXTERNAL_SUB_TYPES -> lambda {')'}
				EXPR_PRIMARY_EXTERNAL_SUB_TYPES -> '(' TYPE EXPR_PRIMARY_EXTERNAL_OTHER_SUB_TYPES ')' {'('}
				EXPR_PRIMARY_EXTERNAL_OTHER_SUB_TYPES -> lambda {')'}
				EXPR_PRIMARY_EXTERNAL_OTHER_SUB_TYPES -> ',' TYPE EXPR_PRIMARY_EXTERNAL_OTHER_SUB_TYPES {','}
            	################################################################# -->

			<context name="expr_primary" fallthrough="true" fallthroughContext="error"  lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />
				<RegExpr String="Self" context="#pop" attribute="self" />
				<RegExpr String="&result;" context="#pop" attribute="result" />
                <RegExpr String="&integer_or_real;" context="#pop" attribute="integer" />
				<DetectChar char="(" context="expr_primary_parenthesed_group" attribute="parenthesis_surrounding_group" beginRegion="group" />
				<DetectChar char="{" context="expr_primary_block" attribute="brace_surrounding_group" beginRegion="group" />
				<DetectChar char=")" context="#pop" attribute="parenthesis_surrounding_group" endRegion="group" />
				<DetectChar char="}" context="#pop" attribute="brace_surrounding_group" endRegion="group" />
				<RegExpr String="(&cap_identifier;|&string_start;|&characters_start;|&external_start;)" lookAhead="true" context="expr_primary_not_trivial_context" />
            </context>

			<context name="expr_primary_not_trivial_context"  fallthrough="true" fallthroughContext="error"  lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&cap_identifier;" lookAhead="true" context="prototype" />

				<RegExpr String="&string_start;" context="expr_primary_string" attribute="string" />
				<RegExpr String="&characters_start;" context="expr_primary_characters" attribute="characters" />
				<RegExpr String="&external_start;" context="expr_primary_external" attribute="external" />

				<RegExpr String="&following_expr_primary;" lookAhead="true" context="#pop#pop" />
			</context>

			<!--les 2 contextes qui suivent sont pour assurer qu'un group commencant par "(" finisse par ")"  (resp. "{" et "}")-->

			<context name="expr_primary_parenthesed_group" fallthrough="true" fallthroughContext="error"  lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />

				<DetectChar char=")" lookAhead="true" context="#pop" />
				<RegExpr String="&start_group;" lookAhead="true" context="group" />
			</context>

			<context name="expr_primary_block" fallthrough="true" fallthroughContext="error" lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_loc_arg;" lookAhead="true" context="loc_arg" />
				<DetectChar char=";" context="expr_primary_block_1" attribute="semi_colon_ending_block_local_arg" />
				<RegExpr String="&start_group;"	lookAhead="true" context="group" />
				<DetectChar char="}" lookAhead="true" context="#pop" />
			</context>

			<context name="expr_primary_block_1" fallthrough="true" fallthroughContext="error" lineEndContext="#stay">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_group;"	lookAhead="true" context="group" />
				<DetectChar char="}" lookAhead="true" context="#pop" />
			</context>


			<context name="expr_primary_string" attribute="string" fallthrough="true" fallthroughContext="error" lineEndContext="#stay" >
				<RegExpr String="[\\]&quot;" context="#stay" attribute="string"/>
				<RegExpr String="&quot;" context="#pop" attribute="string"/>
				<RegExpr String="(&normal_char;|&escape_char;|&apos;|`)" context="#stay"/>
			</context>

			<context name="expr_primary_characters" attribute="characters" fallthrough="true" fallthroughContext="error">
				<RegExpr String="[\\]&apos;" context="#stay" />
				<RegExpr String="&apos;" context="#pop" attribute="string"/>
				<RegExpr String="(&normal_char;|&escape_char;|&quot;|`)" context="#stay"/>
			</context>

			<context name="expr_primary_external" attribute="external"  fallthrough="true" fallthroughContext="error" lineEndContext="#stay">
				<Detect2Chars char="\" char1="`" context="#stay" />
				<DetectChar char="`" context="expr_primary_external_cast" />

				<RegExpr String="@&identifier;" context="#stay" attribute="c_variable" />

				<RegExpr String="(&normal_char;|&escape_char;|&quot;|&apos;|&ws;)" context="#stay"/>
			</context>

			<context name="expr_primary_external_cast" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String=":=" context="error" />
				<RegExpr String="[:]&ws_opt;&start_type;" lookAhead="true" context="expr_primary_external_main_type_dp" />
				<RegExpr String="[:]&ws_opt;[(]" lookAhead="true" context="expr_primary_external_main_type_parenthesed" />
				<RegExpr String="(&identifier;|&operator;|[;)}])" lookAhead="true" context="#pop#pop" />
			</context>

			<context name="expr_primary_external_main_type_dp" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<DetectChar char=":" context="expr_primary_external_main_type" attribute="cast_colon" />

				<RegExpr String="(&identifier;|&operator;|[;)}])" lookAhead="true" context="#pop" />
			</context>

			<context name="expr_primary_external_main_type_parenthesed" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<DetectChar char=":" context="#stay" attribute="cast_colon" />

				<DetectChar char="(" context="expr_primary_external_main_type" attribute="parenthesis_surrounding_cast" />

				<DetectChar char=")" context="#pop" attribute="parenthesis_surrounding_cast" />
			</context>

			<context name="expr_primary_external_main_type" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_type;(&start_type;|\(|\)|&ws;)*[{]" lookAhead="true" context="expr_primary_external_main_type_with_sub_types" />
				<RegExpr String="&start_type;" lookAhead="true" context="type" />

				<RegExpr String="(&identifier;|&operator;|[;)}])" lookAhead="true" context="#pop" />
			</context>

			<context name="expr_primary_external_main_type_with_sub_types" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_type;" lookAhead="true" context="type" />
				<DetectChar char="{" context="expr_primary_external_sub_types" attribute="parenthesis_surrounding_cast_subtypes" />

				<DetectChar char="}" context="#pop#pop" attribute="parenthesis_surrounding_cast_subtypes" />
			</context>

			<context name="expr_primary_external_sub_types" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_type;" lookAhead="true" context="type" />
				<DetectChar char="," context="#stay" attribute="comma_separating_types" />

				<DetectChar char="}" lookAhead="true" context="#pop" />
			</context>


			<!--#################################################################
				GROUP -> DEF_LOCAL{EXPR';'}[EXPR{(,({EXPR';'}EXPR}]
				pour moi il est impossible de reconnaitre avec les outils dispos
				{EXPR';'}[EXPR{(,({EXPR';'}EXPR}],
				je peux juste reconnaitre {[EXPR] {','EXPR }[';']}
    			___

				GROUP -> lambda {')' '}'}
				GROUP -> DEF_LOCAL GROUP_EXPR {start_def_local}
				GROUP_EXPR -> EXPR ','|';' GROUP_EXPR
				GROUP_EXPR -> lambda {')' '}'}
            	################################################################# -->
			<context name="group" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_def_local;" lookAhead="true" context="def_local" />
				<RegExpr String="&start_expr;" lookAhead="true" context="group_expr" />

				<RegExpr String="[)}]" lookAhead="true" context="#pop" />
            </context>

			<context name="group_expr" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String=";" context="#stay" attribute="semi_colon_ending_instruction" />
				<RegExpr String="&start_expr;" lookAhead="true" context="expr" />
				<RegExpr String="," context="expr" attribute="comma_ending_returned_expr" />

				<RegExpr String="[)}]" lookAhead="true" context="#pop" />
            </context>

			<!--#################################################################
				CONTRACT -> '['DEF_LOCAL {(EXPR';'|"...")}']'
			################################################################# -->
			<context name="contract" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<DetectChar char="[" context="def_local" attribute="bracket_surrounding_contract" />
				<RegExpr String="(&start_expr;|[.][.][.])" lookAhead="true" context="contract_exprs" />

				<DetectChar char="]" context="#pop" attribute="bracket_surrounding_contract" />
			</context>

			<context name="contract_exprs" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="[.][.][.]" context="#stay" attribute="contract_ellipsis" />
				<RegExpr String="&start_expr;" lookAhead="true" context="contract_expr" />

				<DetectChar char="]" lookAhead="true" context="#pop" />
			</context>

			<context name="contract_expr" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_expr;" lookAhead="true" context="expr" />
				<DetectChar char=";" context="#pop" attribute="semi_colon_ending_contract_instruction" />
			</context>

			<!--#################################################################
				DEF_LOCAL -> { style LOCAL';'}
				___
				DEF_LOCAL -> DEF_LOCAL_FOLLOWING DEF_LOCAL
				DEF_LOCAL -> lambda
				DEF_LOCAL_FOLLOWING -> style LOCAL';'
				################################################################# -->
			<context name="def_local" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_def_local;" lookAhead="true" context="def_local_following" />

				<RegExpr String="&following_def_local;" lookAhead="true" context="#pop" />
            </context>

			<context name="def_local_following" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&style;" context="local" attribute="local_variable_style" />
				<DetectChar char=";" context="#pop" attribute="semi_colon_ending_stylized_variable_def" />
            </context>

            <!--#################################################################
				SEND_MSG -> identifier[ ARGUMENT{ identifier ARGUMENT}]
   				 ___
				SEND_MSG -> identifier SEND_MSG_ARGS {identifier}
				SEND_MSG_ARGS -> lambda {'.', operator, ';', '}', ')'}
				SEND_MSG_ARGS -> ARGUMENT SEND_MSG_ARGS_FOLLOWING {start_argument}
				SEND_MSG_ARGS_FOLLOWING -> lambda {'.', operator, ';', '}', ')'}
				SEND_MSG_ARGS_FOLLOWING -> identifier SEND_MSG_ARGS {identifier}
            	################################################################# -->
			<context name="send_msg" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<!--<RegExpr String="&identifier;&ws_opt;[({]" lookAhead="true" context="send_msg_with_args" />--> <!--on a le droit de les accoler à l'identifier-->
				<!--<RegExpr String="&identifier;&ws_oom;&start_argument;" lookAhead="true" context="send_msg_with_args" />

				<RegExpr String="&identifier;" context="#pop" attribute="called_slot_name" />	-->
				<!--<RegExpr String="&identifier;&ws_opt;&following_send_msg;" lookAhead="true" context="send_msg_only_ident" />-->
				<!--plutot que faire le choix avec/sans arg au plus tot, comme fait au dessus, on mange directement l'identifier puis ensuite on fait le choix. Ainsi, on a pas besoin de regexp qui pourraient
				avoir à traiter des données venant de 2 lignes successives (ident\n arg1 typiquement), ce que ne permet pas
				le moteur de kate -->
				<RegExpr String="&identifier;" lookAhead="true" context="send_msg_ident" />

				<RegExpr String="&following_send_msg;" lookAhead="true" context="#pop" />
            </context>

			<context name="send_msg_ident" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&identifier;" context="send_msg_switch_param_or_not" attribute="called_slot_name" />
			</context>

			<context name="send_msg_switch_param_or_not" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="(&identifier;|&start_expr_primary;)" lookAhead="true" context="send_msg_args" />

				<RegExpr String="&following_send_msg;" lookAhead="true" context="#pop#pop" />
			</context>

			<context name="send_msg_with_args" fallthrough="true" fallthroughContext="error">
				<RegExpr String="&identifier;" context="send_msg_args" attribute="called_slot_name" />

				<RegExpr String="&following_send_msg;" lookAhead="true" context="#pop" />
			</context>

			<context name="send_msg_args" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&identifier;" context="send_msg_args_following" attribute="argument_identifier" />
				<RegExpr String="&start_expr_primary;" lookAhead="true" context="send_msg_args_following" />
			</context>

			<context name="send_msg_args_following" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_expr_primary;" lookAhead="true" context="expr_primary" />

				<RegExpr String="&identifier;" context="#pop" attribute="called_slot_keyword" />

				<RegExpr String="&following_send_msg;" lookAhead="true" context="#pop#pop" />
			</context>






			<context name="send_msg_implicit" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&identifier;" lookAhead="true" context="send_msg_implicit_ident" />

				<RegExpr String="&following_send_msg;" lookAhead="true" context="#pop" />
			</context>

			<context name="send_msg_implicit_ident" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />
				<!-- test if there is arguments to the message or not. If not, we call send_msg_implicit_ident_stop,
					 else we call send_msg_implicit_ident_cont. In the case we don't know (because there are
					 comments or new lines between the slot name and the following thing) we guess it is a slot
					 without arguments because it is rare to put extra things between a slot name and its argument
					 but it is more common to put variables (slots without arguments) at the end of a list, with the
					 list ending the following line -->

				<RegExpr String="&identifier;&ws_opt;(&ws;&identifier;|&start_expr_primary;)" context="send_msg_implicit_ident_cont" lookAhead="true" />

				<RegExpr String="&identifier;&ws_opt;(&following_send_msg;)" context="send_msg_implicit_ident_stop" lookAhead="true" />

				<RegExpr String="&identifier;" context="send_msg_implicit_switch_param_or_not" attribute="called_variable_name_implicit"/>
			</context>

			<context name="send_msg_implicit_ident_stop" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&identifier;" context="#pop#pop" attribute="called_variable_name_implicit" />
			</context>

			<context name="send_msg_implicit_ident_cont" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&identifier;" context="send_msg_implicit_switch_param_or_not" attribute="called_slot_name_implicit" />
			</context>

			<context name="send_msg_implicit_switch_param_or_not" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="(&identifier;|&start_expr_primary;)" lookAhead="true" context="send_msg_implicit_args" />

				<RegExpr String="&following_send_msg;" lookAhead="true" context="#pop#pop#pop" />
			</context>

			<context name="send_msg_implicit_with_args" fallthrough="true" fallthroughContext="error">
				<RegExpr String="&identifier;" context="send_msg_implicit_args" attribute="called_slot_name_implicit" />

				<RegExpr String="&following_send_msg;" lookAhead="true" context="#pop" />
			</context>

			<context name="send_msg_implicit_args" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&identifier;" context="send_msg_implicit_args_following" attribute="argument_identifier_implicit" />
				<RegExpr String="&start_expr_primary;" lookAhead="true" context="send_msg_implicit_args_following" />
			</context>

			<context name="send_msg_implicit_args_following" fallthrough="true" fallthroughContext="error">
				<IncludeRules context="comments_and_spaces" />

				<RegExpr String="&start_expr_primary;" lookAhead="true" context="expr_primary" />

				<RegExpr String="&identifier;" context="#pop" attribute="called_slot_keyword_implicit" />

				<RegExpr String="&following_send_msg;" lookAhead="true" context="#pop#pop" />
			</context>

			<!--######################################################-->
			<context name="comments_and_spaces" fallthrough="true" fallthroughContext="#pop">
				<!--support des commentaires, et vidage des espaces et autres tabulations-->
				<IncludeRules context="comments" />
				<!--<RegExpr String="&ws_oom;" context="#stay" />               -->
				<DetectSpaces context="#stay" />
			</context>
			
			<context name="comments" fallthrough="true" fallthroughContext="#pop">
				<!--support des commentaires-->
				<RegExpr String="/[*]" context="comment" attribute="comment" beginRegion="multiline_comment" />
				<RegExpr String="//.*" context="#stay" attribute="comment" />
			</context>
			
			<context name="error" attribute="error">
				<RegExpr String="." context="#pop" attribute="error" /> <!-- try to recover, thanks mildred for this clever tip !! -->
				<!--<RegExpr String="." context="#stay" />-->
            </context>

			<!--############################################################-->
			<!--le contexte pour les commentaires multi-lignes -->
			<context name="comment" attribute="comment" fallthrough="true" fallthroughContext="#pop">
				<RegExpr String="[*]/" context="#pop" attribute="comment" endRegion="multiline_comment" />
				<!--evalué que si la 1ere ne marche pas.-->
				<RegExpr String="." context="#stay" />
			</context>
        </contexts>


        <itemDatas>

			<itemData name="Normal"    defStyleNum="dsNormal" />
			
			<itemData name="section_declaration"	defStyleNum="dsNormal" color="darkmagenta" underline="1" />
			<itemData name="section_name"	defStyleNum="dsNormal" color="darkmagenta" bold="1" underline="1" />
			<itemData name="inherit_section_name"	defStyleNum="dsNormal" color="darkred" bold="1" underline="1"/>
			<itemData name="header_section_name"	defStyleNum="dsNormal" color="darkred" bold="1" underline="1"/>

   			<itemData name="prototype_name_slot"	defStyleNum="dsNormal" 	color="blue" 	bold="1" underline="1" />
   			<itemData name="inherit_slot_name"	defStyleNum="dsNormal" 	color="red" 	bold="1" />
			<itemData name="slot_name"				defStyleNum="dsNormal" 	color="blue" 	bold="1" />
			<itemData name="slot_keyword"			defStyleNum="dsNormal" 	color="blue" />
			<itemData name="slot_operator"			defStyleNum="dsNormal"	color="magenta"		bold="1" />
			<itemData name="slot_operator_priority"	defStyleNum="dsNormal" 	color="red"		italic="1" />
			<itemData name="slot_operator_priority_value"	defStyleNum="dsNormal" 	color="blue" />
			<itemData name="declared_variable_name"	defStyleNum="dsNormal"	color="darkmagenta"	bold="1" />


			<itemData name="slot_style"				defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />

			<itemData name="local_variable_style"				defStyleNum="&punctuation_style;" color="darkgray" bold="&punctuation_bold;" />
			<itemData name="slot_affectation"							defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />

			<itemData name="imported_types_arrow"							defStyleNum="&punctuation_style;" color="&import_related_item_color;" bold="&punctuation_bold;" />
			<itemData name="importing_slot_name"							defStyleNum="&punctuation_style;" color="&import_related_item_color;" bold="&punctuation_bold;" />

   			<itemData name="exported_types_arrow"							defStyleNum="&punctuation_style;" color="&export_related_item_color;" bold="&punctuation_bold;" />
   			<itemData name="exporting_slot_name"							defStyleNum="&punctuation_style;" color="&export_related_item_color;" bold="&punctuation_bold;" />


			<itemData name="colon_before_type"					defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="colon_before_return_type"					defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" underline="1" />
			<itemData name="cast_colon"							defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="comma_separating_arguments"					defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="comma_separating_parameters"				defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="comma_separating_types"						defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="comma_separating_header_types"                     defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" underline="1" />
			<itemData name="comma_ending_returned_expr"				defStyleNum="&punctuation_style;" color="red" bold="&punctuation_bold;" />
			<itemData name="semi_colon_ending_instruction"				defStyleNum="&punctuation_style;" color="red" bold="&punctuation_bold;" />
			<itemData name="semi_colon_ending_local_variable_def"		defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" underline="1" />
			<itemData name="semi_colon_ending_slot"						defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" underline="1" />
			<itemData name="semi_colon_ending_stylized_variable_def"		defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="semi_colon_ending_block_local_arg"		defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="semi_colon_ending_program_contract"								defStyleNum="&punctuation_style;" color="red" bold="&punctuation_bold;" />
			<itemData name="semi_colon_ending_contract_instruction"								defStyleNum="&punctuation_style;" color="red" bold="&punctuation_bold;" />
			<itemData name="slot_call_dot"								defStyleNum="&punctuation_style;" color="red" bold="&punctuation_bold;" />
			<itemData name="contract_ellipsis"								defStyleNum="&punctuation_style;" color="red" bold="&punctuation_bold;" />
			<itemData name="parenthesis_surrounding_cast"				defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="0" />
			<itemData name="parenthesis_surrounding_cast_subtypes"		defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="0" />
			<itemData name="parenthesis_surrounding_group"				defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="brace_surrounding_group"					defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="generic_type_bracket"						defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="header_generic_type_bracket"                       defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" underline="1" />
			<itemData name="parenthesis_enclosing_infix_params"						defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="parenthesis_enclosing_returned_types"						defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />
			<itemData name="parenthesis_enclosing_local_arguments"						defStyleNum="&punctuation_style;" color="&punctuation_color;" bold="&punctuation_bold;" />



			<itemData name="operator_before_expression"	defStyleNum="dsNormal"	color="darkorange" />
			<itemData name="operator_between_expressions"	defStyleNum="dsNormal"	color="darkmagenta" />
			<itemData name="affectation"	defStyleNum="dsNormal" color="darkmagenta" bold="1" />
			<itemData name="self"			defStyleNum="dsNormal" color="darkgreen" bold="1" />
			<itemData name="result"		defStyleNum="dsDecVal" />
			<itemData name="string"			defStyleNum="dsString" />
            <itemData name="characters"		defStyleNum="dsChar" />
			<itemData name="integer"		defStyleNum="dsDecVal" />
			<itemData name="external"		defStyleNum="dsString" color="darkred" />
			<itemData name="type"			defStyleNum="dsNormal" color="darkgreen" bold="1" />
			<itemData name="header_type"           defStyleNum="dsNormal" color="darkgreen" bold="1" underline="1" />

			<itemData name="lisaac_keyword"		defStyleNum="dsNormal" />

			<itemData name="caller_identifier"		defStyleNum="dsNormal"	color="#0000C0" />
			<itemData name="called_slot_name"					defStyleNum="dsNormal"	color="#0000C0" />
			<itemData name="called_slot_name_implicit"			defStyleNum="dsNormal"	color="#0000C0" />
			<itemData name="called_slot_variable_name_implicit"	defStyleNum="dsNormal"	color="black"	italic="1" />
			<itemData name="called_slot_keyword"				defStyleNum="dsNormal"	color="#0000C0" />
			<itemData name="called_slot_keyword_implicit"		defStyleNum="dsNormal"	color="#0000C0" />
			<itemData name="identifier_separating_types"		defStyleNum="dsNormal"	color="black"	italic="1" />
			<itemData name="argument_identifier"				defStyleNum="dsNormal"	color="black"	italic="1" />
			<itemData name="argument_identifier_implicit"		defStyleNum="dsNormal"	color="black"	italic="1" />
			<itemData name="c_variable"		defStyleNum="dsNormal" color="blue" bold="1" />

            <itemData name="comment" defStyleNum="dsComment" color="darkgreen" italic="1" />
			<itemData name="error"                defStyleNum="dsString" 	color="red"	backgroundColor="grey" />
        </itemDatas>
    </highlighting>
    <general>
        <comments>
            <!--<comment name="singleLine" start="//" />
			<comment name="multiLine" start="/*" end="*/" />-->
        </comments>
        <keywords casesensitive="1" additionalDeliminator="`"/>
    </general>
</language>