/***************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  + name        := DICTIONARY[V,K];
  - comment     :=" Associative memory.\
                  \Values of type `V' are stored using Keys of type `K'..";
  
  - category    := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
section INHERIT
  
  - parent_safe_equal:SAFE_EQUAL[V] := SAFE_EQUAL[V];
  
section PUBLIC
  
  // DICTIONARY
  
  + buckets:NATIVE_ARRAY[DICTIONARY_NODE[V,K]];
  // The `buckets' storage area is the primary hash table of `capacity'
  // elements. To search some key, the first access is done in `buckets'
  // using the remainder of the division of the key `hash_code' by
  // `capacity'. In order to try to avoid clashes, `capacity' is always a
  // prime number (selected using HASH_TABLE_SIZE).
  
  - default_size:INTEGER := 193;
  // Default size for the storage area in number of items.
  
  // Counting:
  
  + capacity:INTEGER;
  // Of the `buckets' storage area.
  
  + count:INTEGER;
  // Actual `count' of stored elements.
  
  - lower:INTEGER := 1;
  
  + cache_user :INTEGER;
  // The last user's external index in range [1 .. `count'] (see `item'
  // and `valid_index' for example) may be saved in `cache_user' otherwise
  // -1 to indicate that the cache is not active. When the cache is
  // active, the corresponding index in `buckets' is save in
  // `cache_buckets' and the corresponding node in `cache_node'.
  
  + cache_node:DICTIONARY_NODE[V,K];
  // Meaningful only when `cache_user' is not -1.
  
  + cache_buckets:INTEGER;
  // Meaningful only when `cache_user' is not -1.
  
  
  
  - is_empty:BOOLEAN <- count = 0;
  // Is it empty ?
  
  // Basic access:
  
  - has k:K :BOOLEAN <-
  // Is there a value currently associated with key `k'?
  (
    + idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];
    
    idx := k.hash_code % capacity;
    node := buckets.item idx;
    
    { (node = NULL) || { node.key == k}}.until_do {
      node := node.next;
    };
    node != NULL
  );

  - fast_has k:K :BOOLEAN <-
  // Is there a value currently associated with key `k'?
  (
    + idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];
    
    idx := k.hash_code % capacity;
    node := buckets.item idx;
    
    { (node = NULL) || { node.key = k}}.until_do {
      node := node.next;
    };
    node != NULL
  );
  
  
  - at k:K :V <-
  // Return the value associated to key `k'.
  // (See also `reference_at' if V is a reference type.)
  (
    + idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];  
    
    ? { has k };
    
    idx := k.hash_code % capacity;
    node := buckets.item idx;
    
    { node.key == k}.until_do {
      node := node.next;
    };
    node.item
  );

  - fast_at k:K :V <-
  // Return the value associated to key `k'.
  // (See also `reference_at' if V is a reference type.)
  (
    + idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];  
    
    ? { fast_has k };
    
    idx := k.hash_code % capacity;
    node := buckets.item idx;
    
    { node.key = k}.until_do {
      node := node.next;
    };
    node.item
  );
  
  
  - '@' left 1 k:K :V <-
  (
    at k
  );
  
  - reference_at k:K :V <-
  // Return NULL or the value associated with key `k'. Actually, this 
  // feature is useful when the type of values (the type V) is a 
  // reference type, to avoid using `has' just followed by `at' to get 
  // the corresponding value.
  (
    + idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];
    + result:V;
    
    idx := k.hash_code % capacity;
    node := buckets.item idx;
    { (node = NULL) ||{ node.key == k }}.until_do {
      node := node.next;
    };
    ( node != NULL ).if {
      result := node.item;
    };
    
    ? { has k ->> {result = at k}};
    
    result
  );

  - fast_reference_at k:K :V <-
  // Return NULL or the value associated with key `k'. Actually, this 
  // feature is useful when the type of values (the type V) is a 
  // reference type, to avoid using `has' just followed by `at' to get 
  // the corresponding value.
  (
    + idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];
    + result:V;
    
    idx := k.hash_code % capacity;
    node := buckets.item idx;
    { (node = NULL) ||{ node.key = k }}.until_do {
      node := node.next;
    };
    ( node != NULL ).if {
      result := node.item;
    };
    
    ? { fast_has k ->> {result = fast_at k}};
    
    result
  );
 
  - put v:V to k:K  <-
  // Change some existing entry or `add' the new one. If there is
  // as yet no key `k' in the dictionary, enter it with item `v'.
  // Otherwise overwrite the item associated with key `k'.
  (
    + h, idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];
    //? { k != NULL}; // BSBS : a voir si k=INTEGER
    cache_user := -1;
    
    h := k.hash_code;
    idx := h % capacity;
    node := buckets.item idx;
        
    { (node = NULL) || { node.key == k}}.until_do {
      node := node.next;
    };
    ( node = NULL ).if {
      (capacity = count).if {
	increase_capacity;
	idx := h % capacity;
      };
      node:=DICTIONARY_NODE[V,K].create v to k next (buckets.item idx);
      buckets.put node to idx;
      count := count + 1;
    } else {
      node.set_item v;
    };
    
    ? { v = at k };
  );

  - fast_put v:V to k:K  <-
  // Change some existing entry or `add' the new one. If there is
  // as yet no key `k' in the dictionary, enter it with item `v'.
  // Otherwise overwrite the item associated with key `k'.
  (
    + h, idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];
    //? { k != NULL}; // BSBS : a voir si k=INTEGER
    cache_user := -1;
    
    h := k.hash_code;
    idx := h % capacity;
    node := buckets.item idx;
        
    { (node = NULL) || { node.key = k}}.until_do {
      node := node.next;
    };
    ( node = NULL ).if {
      (capacity = count).if {
	increase_capacity;
	idx := h % capacity;
      };
      node:=DICTIONARY_NODE[V,K].create v to k next (buckets.item idx);
      buckets.put node to idx;
      count := count + 1;
    } else {
      node.set_item v;
    };
    
    ? { v = fast_at k };
  );
  
  
  - add v:V to k:K <-
  // To add a new entry `k' with its associated value `v'. Actually, this
  // is equivalent to call `put', but may run a little bit faster.
  ( + old_count:INTEGER;
    + idx:INTEGER;
    + node:DICTIONARY_NODE[V,K];
    
    ? {!has k};
    old_count := count;
    cache_user := -1;
    (capacity = count ).if {
      increase_capacity;
    };
    idx := k.hash_code % capacity;
    node:= DICTIONARY_NODE[V,K].create v to k next (buckets.item idx);
    buckets.put node to idx;
    count := count + 1;
    
    ? { count = 1 + old_count };
    ? { v = at k };
  );
  
  
  // Looking and searching some value:
  
  
  - occurrences v:V :NUMERIC <-
  // Number of occurrences using `equal'.
  // See also `fast_occurrences' to chose the apropriate one.
  (
    1.to count do { i:INTEGER;
      (safe_equal v,(item i) ).if {
	result := result + 1;
      }; // end if
    }; // end fo
    
    ? { result >= 0 };
    
    result
  );
  
  
  - fast_occurrences v:V :NUMERIC <-
  // Number of occurrences using `='.
  // See also `occurrences' to chose the apropriate one.
  (
    + result:INTEGER;
    
    1.to count do { i:INTEGER;
      (v = item i ).if {
	result := result + 1;
      }; // end if
    }; // end do
    
    ? { result >= 0 };
    
    result
  );
  
  
  - key_at v:V :K <-
  // Retrieve the key used for value `v' using `equal' for comparison.
  (
    + i:INTEGER;
    + result:K;
    
    ? { occurrences v = 1};
    i := 1;
    {safe_equal v,(item i)}.until_do {
      i := i + 1;
    };
    result := cache_node.key;
    
    ? { equal (at result) ,v };
    
    result
  );
  
  
  - fast_key_at v:V :K <-
  // Retrieve the key used for value `v' using `=' for comparison.
  (
    + i:INTEGER;         
    + result:K;
    
    ? { fast_occurrences v = 1 };
    i := 1;
    {v = item(i)}.until_do {
      i := i + 1;
    };
    result := cache_node.key;
    
    ? { at result = v };
    
    result
  );
  
  
  // Removing:
  
  - remove k:K <-
  // Remove entry `k' (which may exist or not before this call).
  (
    + h, idx:INTEGER;
    +  node, previous_node:DICTIONARY_NODE[V,K]; 
    cache_user := -1;
    h := k.hash_code;
    idx := h % capacity;
    node := buckets.item idx;
    (node != NULL ).if {
      (node.key == k ).if {
	count := count - 1;
	node := node.next;
	buckets.put node to idx;
      } else {
	previous_node := node;
	node := node.next;
	{(node = NULL) || {node.key == k}}.until_do {
	  previous_node := node;
	  node := node.next;
	};
	(node != NULL ).if {
	  count := count - 1;
	  previous_node.set_next (node.next);
	};
      };
    };
    
    ? { ! has k};
  );
  
  
  - clear <-
  // Discard all items.
  ( + old_capacity:INTEGER;
    old_capacity := capacity;
    buckets.set_all_with NULL until (capacity - 1);
    cache_user := -1;
    count := 0;
    ? { is_empty };
    ? { capacity = old_capacity};
  );
  
  
  // To provide iterating facilities:
  
  - upper :INTEGER <-
  (
    count
  );
  
  
  - valid_index index:NUMERIC :BOOLEAN <-
  (
    + result:BOOLEAN;
    
    result := (1 <= index) && {index <= count};
    
    ? { result =  index.in_range lower to upper };
    
    result
  );
  
  
  - item index:NUMERIC :V <-
  ( + result:V;
    ? { valid_index index };
    set_cache_user index;
    result := cache_node.item;
    
    ? { result = fast_at (key index)};
    result
  );
  
  
  - key index:NUMERIC :K <-
  ( + result:K;
    ? { valid_index index };
    
    set_cache_user index;
    result := cache_node.key;
    
    //? { at result = item index};
    result
  );
  
  
  - get_new_iterator_on_items :ITERATOR[V] <-
  (
    ITERATOR_ON_DICTIONARY_ITEMS[V].create self
  );
  
  
  - get_new_iterator_on_keys :ITERATOR[K] <-
  (
    ITERATOR_ON_DICTIONARY_KEYS[K].create self
  );
  
  
  - key_map_in buffer:COLLECTION[K] <-
  // Append in `buffer', all available keys (this may be useful to
  // speed up the traversal).
  (
    + node:DICTIONARY_NODE[V,K];
    + idx:INTEGER;
    + old_count:INTEGER;
    
    ? { buffer != NULL };
    
    old_count := buffer.count;     
    node := buckets.item idx;
    count.downto 1 do { i:INTEGER;	    
      {node != NULL}.until_do {
	idx := idx + 1;
	? {idx < capacity};
	node := buckets.item idx;
      }; // end until_do
      buffer.add_last (node.key);
      node := node.next;
    }; // end do
    
    ? { buffer.count = count + old_count };
  );
  
  
  - item_map_in buffer:COLLECTION[V]  <-
  // Append in `buffer', all available items (this may be useful to
  // speed up the traversal).
  (
    + node:DICTIONARY_NODE[V,K];
    + idx:INTEGER;
    + old_count:INTEGER;
    
    ? { buffer != NULL };
    
    old_count := buffer.count;
    node := buckets.item idx;
    count.downto 1 do { i:INTEGER;
      {node != NULL}.until_do {
	idx := idx + 1;
	? {idx < capacity};
	node := buckets.item idx;
      }; // end until_do
      buffer.add_last (node.item);
      node := node.next;
    }; // end do
    
    ? { buffer.count = count + old_count };
  );
  
  
  - '=='  right 60 other:SELF :BOOLEAN <-
  // do both dictionaries have the same set of associations?
  // Keys are compared with `==' and values are comnpared
  // with the basic = operator. See also `is_equal_map'.
  (
    + i:INTEGER;
    + result:BOOLEAN;
    
    (self = other ).if {
      result := TRUE;
    }.elseif { count = other.count } then {
      result := TRUE;
      i := 1;
      {!result || {i > count}}.until_do {
	(other.has (key i) ).if {
	  (other.at (key i) != item i ).if {
	    result := FALSE;
	  } else {
	    i := i + 1;
	  }; // end if
	} else {
	  result := FALSE;
	}; // end if
      }; // end until_do
    }; // end if
    
    ? { result ->> {count = other.count} };
    
    result
  );
  
  
  - is_equal_map other:SELF :BOOLEAN <-
  // Do both dictionaries have the same set of associations?
  // Both keys and values are compared with `=='. See also `=='.
  (
    + i:INTEGER;
    + k:K; 
    + result:BOOLEAN;
    (self = other ).if {
      result := TRUE;
    }.elseif { count = other.count } then {
      result := TRUE;
      i := 1;
      {! result || {i > count}}.until_do {
	k := key i;
	(other.has k ).if {
	  (! safe_equal (other.at k),(item i) ).if {
	    result := FALSE;
	  } else {
	    i := i + 1;
	  }; // end if
	} else {
	  result := FALSE;
	}; // end if
      }; // end until_do
    }; // end if
    
    result
  );
  
  
  - copy other:SELF <-
  // Reinitialize by copying all associations of `other'.
  (
    // Note:this is a naive implementation because we should
    // recycle already allocated nodes of `self'.
    
    (capacity = 0 ).if {
      with_capacity (other.count + 1);
    } else {
      clear;
    }; // end if
    
    1.to (other.count) do { i:INTEGER;
      put (other.item i) to (other.key i);
    }; // end do
  );
  
  
  // Other features:
  
  - internal_key k:K :K <-
  // Retrieve the internal key object which correspond to the existing
  // entry `k' (the one memorized into the `self' dictionary).
  (
    + node:DICTIONARY_NODE[V,K];
    + result:K;
    
    ? {has k};
    
    node := buckets.item (k.hash_code % capacity);
    result := node.key;
    {result == k}.until_do {
      node := node.next;
      result := node.key;
    }; // end until_do
    
    ? {result == k};
  );
  
  
  // NONE
  
  - increase_capacity <-
  // There is no more free slots:the dictionary must grow.
  (
    + idx, new_capacity:INTEGER;
    + old_count,old_capacity:INTEGER;
    + old_buckets:NATIVE_ARRAY[DICTIONARY_NODE[V,K]];
    + node1, node2:DICTIONARY_NODE[V,K];
    
    ? { capacity = count };
    
    old_capacity := capacity;
    old_count    := count;
    old_buckets  := buckets;
    new_capacity := HASH_TABLE_SIZE.prime_number_ceiling (capacity + 1);
    
    buckets := NATIVE_ARRAY[DICTIONARY_NODE[V,K]].calloc new_capacity;
    capacity := new_capacity;
    (old_capacity - 1).downto 0 do { i:INTEGER;
      node1 := old_buckets.item i;
      {node1 = NULL}.until_do {
	node2 := node1.next;
	idx := node1.key.hash_code % capacity;
	node1.set_next (buckets.item idx);
	buckets.put node1 to idx;
	node1 := node2;
      }; // end until_do
    }; // end downto
    cache_user := -1;
    
    ? { capacity > old_capacity };
    ? { count = old_count };
  );
  
  
  - set_cache_user index:NUMERIC <-
  // Set the internal memory cache (`cache_user', `cache_node' and
  // `cache_buckets') to the appropriate valid value.
  (
    ? { valid_index index};
    
    (index = cache_user + 1 ).if {
      cache_user := index;
      cache_node := cache_node.next;
      {cache_node != NULL}.until_do {
	cache_buckets := cache_buckets + 1;
	cache_node := buckets.item cache_buckets;
      }; // end until_do
    }.elseif { index = cache_user} then {
    }.elseif { index = 1} then {
      cache_user := 1;
      cache_buckets := 0;
      cache_node := buckets.item cache_buckets;
      {cache_node != NULL}.until_do {
	cache_buckets := cache_buckets + 1;
	cache_node := buckets.item cache_buckets;
      }; // end until_do
    } else {
      set_cache_user 1;
      {cache_user = index}.until_do {
	set_cache_user (cache_user + 1);
      }; // end until_do
    }; // end if

    ? { cache_user = index };
    ? { cache_buckets.in_range 0 to (capacity - 1) };
    ? { cache_node != NULL };
  );
  
  - create:SELF <-
  (
    + result:SELF;
    result := clone;
    result.make;
    result
  );
  
  - make <-
  // Create an empty dictionary. Internal storage `capacity' of the
  // dictionary is initialized using the `Default_size' value. Then,
  // tuning of needed storage `capacity' is performed automatically
  // according to usage. if you are really sure that your dictionary
  // is always really bigger than `Default_size', you may consider to use
  // `with_capacity' to save some execution time.
  (
    with_capacity default_size;
    
    ? { is_empty };
    ? { capacity = default_size };
  );
  
  
  - with_capacity medium_size:NUMERIC <-
  // May be used to save some execution time if one is sure that
  // storage size will rapidly become really bigger than `Default_size'.
  // When first `remove' occurs, storage size may naturally become
  // smaller than `medium_size'. Afterall, tuning of storage size is
  // done automatically according to usage.
  (
    + new_capacity:INTEGER;
    
    ? { medium_size > 0 };
    
    new_capacity := HASH_TABLE_SIZE.prime_number_ceiling medium_size;
    buckets := NATIVE_ARRAY[DICTIONARY_NODE[V,K]].calloc new_capacity;
    capacity := new_capacity;
    cache_user := -1;
    count := 0;
    
    ? { is_empty };
    ? { capacity >= medium_size };
  );
  
  
  - invariant :BOOLEAN <-
  (
    ( capacity > 0) && 
    { capacity >= count} &&
    { cache_user.in_range (-1) to count} &&
    { (cache_user > 0) ->> {cache_node != NULL}} &&
    { (cache_user > 0) ->> {cache_buckets.in_range 0 to (capacity - 1)}}
  );
  
  
  
  
  

