/****************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  + name        :=LINKED2_LIST[E] ;
  - comment     :="Two way linked list with internal automatic memorization of the last access .";
  
  - category    := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
section INHERIT
  
  + parent_linked_collection:LINKED_COLLECTION[E] := LINKED_COLLECTION[E];
  
section PUBLIC
  
  
  + first_link:LINK2[E];
  // Void when empty or gives access to the first element.
  
  // {TWO_WAY_LINKED_LIST}
  
  + last_link:LINK2[E];
  // Void when empty or gives access to the last element.
  
  + mem_idx:INTEGER; 
  
  + mem_lnk:LINK2[E];
  // To speed up accessing, `mem_idx' and `mem_lnk' is the
  // memory of the last access done. For example, after
  // item(1), `mem_idx' is 1 and `mem_lnk' is `first_link'.
  // When list is empty, `first_link' is Void as well as
  // `mem_lnk' and `mem_idx' is 0;
  
  - create:SELF <-
  (
    + result:SELF;
    result := SELF.clone;
    result.make;
    result
  );
  
  - make <-
  // Make an empty list;
  (
    first_link := NULL;
    last_link := NULL;
    upper := 0;
    mem_idx := 0;
    mem_lnk := NULL;
    ? { count = 0 };
  );
  
  
  - is_empty:BOOLEAN <-
  ( + result:BOOLEAN;
    result := first_link = NULL;
    ? { result = (count = 0)};
    result
  );
  
  
  - add_first element:E <-
  ( + old_count,old_lower,old_upper:INTEGER;
    old_count := count;
    old_lower := lower;
    old_upper := upper;
    ( first_link = NULL).if {
      first_link := LINK2[E].create element previous NULL next NULL;
      last_link := first_link;
      upper := 1;
      mem_idx := 1;
      mem_lnk := first_link;
    } else {
      first_link := LINK2[E].create element previous NULL next first_link;
      first_link.next.set_previous first_link;
      upper := upper + 1;
      mem_idx := mem_idx + 1;
    };
    ? { first = element };
    ? { count = 1 + old_count };
    ? { lower = old_lower };
    ? { upper = 1 + old_upper };
  );
  
  
  - add_last element:E <-
  ( + old_count,old_lower,old_upper:INTEGER;
    old_count := count;
    old_lower := lower;
    old_upper := upper;
    (first_link = NULL).if {
      first_link := LINK2[E].create element previous NULL next NULL;
      last_link := first_link;
      upper := 1;
      mem_idx := 1;
      mem_lnk := first_link;
    } else {
      last_link := LINK2[E].create element previous last_link next NULL;
      last_link.previous.set_next last_link;
      upper := upper + 1;
    };
    ? { last = element };
    ? { count = 1 + old_count };
    ? { lower = old_lower };
    ? { upper = 1 + old_upper };
  );
  
  
  - add element:E to index:NUMERIC <-
  ( + link:LINK2[E];
    + old_count,old_upper:INTEGER;
    ? { index.in_range lower to (upper + 1)};
    old_count := count;
    old_upper := upper;
    (index = 1).if {
      add_first element;
    }.elseif { index = upper + 1} then {
      add_last element;
    } else {
      ( (index - 1) != mem_idx).if {
	go_item (index - 1);
      };
      link := LINK2[E].create element previous mem_lnk next (mem_lnk.next);
      link.next.set_previous link;
      mem_lnk.set_next link;
      upper := upper + 1;
    };
    ? { item index = element };
    ? { count = 1 + old_count };
    ? { upper = 1 + old_upper };    
  );
  
  
  - remove_first <-
  ( + old_lower,old_upper,old_count:INTEGER;
    ? { not is_empty };
    old_lower := lower;
    old_upper := upper;
    old_count := count;
    ( upper = 1).if {
      make;
    } else {
      mem_lnk := first_link;
      first_link := first_link.next;
      first_link.set_previous NULL;
      mem_lnk := first_link;
      mem_idx := 1;
      upper := upper - 1;
    };
    ? { count = old_count - 1};
    ? {(lower = old_lower + 1) ^ (upper = old_upper - 1)};
  );
  
  
  - remove index:NUMERIC <-
  ( + link:LINK2[E];
    + old_count,old_upper:INTEGER;
    ? { valid_index(index)};
    old_count := count;
    old_upper := upper;
    (index = 1).if {
      remove_first;
    }.elseif { index = upper} then {
      remove_last;
    } else {
      ( (index - 1) != mem_idx).if {
	go_item (index - 1);
      };
      link := mem_lnk.next;
      mem_lnk.set_next (link.next);
      link.next.set_previous mem_lnk;
      upper := upper - 1;
    };
    ? { count = old_count - 1};
    ? { upper = old_upper - 1};    
  );
  
  
  - first:E <-
  ( + result:E;
    ? {count >= 1};
    result :=  first_link.item;
    ? { result = item lower};
    result
  );
  
  
  - last:E <-
  ( + result:E;
    ? {! is_empty};    
    result := last_link.item;
    ? { result = item upper};
    result
  );
  
  
  - item index:NUMERIC :E <-
  (
    ? { valid_index i};
    ( index != mem_idx).if {
      go_item index;
    };
    mem_lnk.item
  );
  
  
  - '@' left 1 index:NUMERIC :E <-
  (
    item index
  );
  
  
  - put element:E to index:NUMERIC <-
  ( + old_count:INTEGER;
    old_count := count;
    ? { valid_index i};
    ( index != mem_idx).if {
      go_item index;
    };
    mem_lnk.set_item element;
    ? { item i = element};
    ? { count = old_count};
  );
  
  
  - count:INTEGER <-
  ( + result:INTEGER;
    result := upper;
    ? {result = upper - lower + 1};
    result
  );
  
  
  - set_all_with v:E <-
  ( + old_count:INTEGER;
    old_count := count;
    ( first_link != NULL).if {
      first_link.set_all_with v;
    };
    ? { count = old_count };
  );
  
  
  - copy other:SELF <-
  (
    from_collection other;
  );
  
  
  - '=='  right 60 other:SELF :BOOLEAN <-
  ( + result:BOOLEAN;
    + lnk1, lnk2:LINK2[E];
    
    result:= FALSE;
    ( self = other ).if {
      result := TRUE;
    }.elseif { upper = other.upper} then {
      result := TRUE;
      lnk1 := first_link;
      lnk2 := other.first_link;
      {(lnk1 = NULL) | ! result}.until_do {
	result := lnk1.item = lnk2.item;
	lnk1 := lnk1.next;
	lnk2 := lnk2.next;
      };
    };
    ? { result ->> {(lower = other.lower) & (upper = other.upper)}};
    result
  );
  
  
  - is_equal_map other:SELF :BOOLEAN <-
  ( + result:BOOLEAN;
    + lnk1, lnk2:LINK2[E];
    ( self = other ).if {
      result := TRUE;
    }.elseif { upper = other.upper } then {
      result := TRUE;
      lnk1 := first_link;
      lnk2 := other.first_link;
      { (lnk1 = NULL) | ! result}.until_do {
	result := safe_equal (lnk1.item),(lnk2.item);
	lnk1 := lnk1.next;
	lnk2 := lnk2.next;
      };
    };
    
    result
  );
  
  
  - index_of x:E :INTEGER <-
  ( + result:INTEGER;
    result := lower;
    {(result > upper) || {safe_equal x,(item result)}}.until_do {
      result := result + 1;
    };
    ? { lower <= result };
    ? { result <= upper + 1 };
    ? { (result <= upper) ->> { element == (item result)}};    
    result
  );
  
  
  - fast_index_of x:E :INTEGER <-
  ( + result:INTEGER;
    + u:INTEGER;
    result := lower;
    u := upper;
    {(result > u) || {x = item result}}.until_do {
      result := result + 1;
    };
    ? { lower <= result };
    ? { result <= upper + 1 };
    ? { (result <= upper) ->> { element = item result}};    
    result
  );
  
  
  - clear <-
  (
    ( first_link != NULL ).if {
      first_link := NULL;
      mem_idx := 0;
      mem_lnk := NULL;
      upper := 0;
      last_link := NULL;
    };
    ? { is_empty };   
    ? { upper = 0 };
  );
  
  
  - from_collection model:COLLECTION[E] <-
  ( + lnk:LINK2[E];
    ? { model != NULL };
    (first_link = NULL).if {
      (model.lower).to (model.upper) do { i:INTEGER;
	add_last (model.item i);
      };
    } else {
      lnk := first_link;
      (model.lower).to (model.upper) do { i:INTEGER;
	( lnk = NULL).if {
	  add_last (model.item i);
	} else {
	  lnk.set_item (model.item i);
	  lnk := lnk.next;
	};
      };
      ( lnk = first_link ).if {
	? { model.count = 0 };
	clear;
      }.elseif { lnk != NULL } then {
	+ i:INTEGER;
	i := model.count;
	( mem_idx != i ).if {
	  go_item i;
	};
	? { lnk = mem_lnk.next };
	mem_lnk.set_next NULL;
	upper := i;
	last_link := mem_lnk;
      };
    };
    ? { count = model.count };
  );
  
  
  - slice low:NUMERIC to up:NUMERIC :SELF <-
  ( + lnk:LINK2[E];
    + result:SELF;
    ? { lower <= min };
    ? { max <= upper };
    ? { min <= max + 1 };    
    result := SELF.create;
    
    ( mem_idx != low ).if {
      go_item low;
    };
    lnk := mem_lnk;
    ( up - low + 1).downto 1 do { i:INTEGER;
      result.add_last (lnk.item);
      lnk := lnk.next;
    };
    ? { same_dynamic_type result };
    ? { result.count = max - min + 1};
    ? { result.lower = lower };    
    result
  );
  
  
  - occurrences element:E :INTEGER <-
  ( + lnk:LINK2[E];
    + result:INTEGER;
    
    lnk := first_link;
    { lnk = NULL }.until_do {
      ( safe_equal element,(lnk.item)).if {
	result := result + 1;
      };
      lnk := lnk.next;
    };
    ? { result >= 0};
    result
  );
  
  
  - fast_occurrences element:E :INTEGER <-
  ( + lnk:LINK2[E];
    + result:INTEGER;
    lnk := first_link;
    { lnk = NULL }.until_do {
      ( element = lnk.item ).if {
	result := result + 1;
      };
      lnk := lnk.next;
    };
    ? { result >= 0}; 
    result
  );
  
  
  - force element:E to index:NUMERIC <-
  ( + v:E;
    { index <= upper }.until_do {
      add_last v;
    };
    put element,index;
  );
  
  
  - all_default:BOOLEAN <-
  ( + l:LINK2[E];
    + d:E;
    + result:BOOLEAN;
    result := TRUE;
    l := first_link;
    { ! result || {l = NULL}}.until_do {
      result := (d = l.item);
      l := l.next;
    };
    
    result
  );
  
  
  - remove_last <-
  ( + old_count,old_upper:INTEGER;
    ? {! is_empty};
    old_count := count;
    old_upper := upper;
    ( upper = 1 ).if {
      make;
    } else {
      ( (upper - 1) != mem_idx ).if {
	go_item (upper - 1);
      };
      upper := upper - 1;
      last_link := mem_lnk;
      last_link.set_next NULL;
    };
    ? { count = old_count - 1};
    ? { upper = old_upper - 1};
  );
  
  
  - replace_all old_value:E with new_value:E <-
  ( + old_count:INTEGER;
    old_count := count;
    lower.to upper do { i:INTEGER;
      ( safe_equal (item i),old_value).if {
	put new_value to i;
      };
    };
    ? { count = old_count};
    ? { occurrences old_value = 0};
  );
  
  
  - fast_replace_all old_value:E with new_value:E <-
  ( + old_count:INTEGER;
    old_count := count;
    lower.to upper do { i:INTEGER;
      ( item(i) = old_value ).if {
	put new_value to i;
      };
    };
    ? { count = old_count};
    ? { occurrences old_value = 0};
  );
  
  
  -  get_new_iterator:ITERATOR[E] <-
  (
    ITERATOR_ON_TWO_WAY_LINKED_LIST[E].create self;
  );
  
  
  // {NONE}
  
  - go_item index:NUMERIC <-
  (
    ? { valid_index index };
    ? { mem_idx != index };
    ? { mem_idx > 0 };
    ? { mem_lnk != NULL };
    
    ( index > mem_idx ).if {
      ( (upper - index) < (index - mem_idx)).if {
	mem_idx := upper;
	mem_lnk := last_link;
	{ index = mem_idx }.until_do {
	  mem_lnk := mem_lnk.previous;
	  mem_idx := mem_idx - 1;
	};
      } else {
	{ index = mem_idx }.until_do {
	  mem_lnk := mem_lnk.next;
	  mem_idx := mem_idx + 1;
	};
      };
    }.elseif { (mem_idx - index) < (index - 1) } then {
      { index = mem_idx }.until_do {
	mem_lnk := mem_lnk.previous;
	mem_idx := mem_idx - 1;
      };
    } else {
      mem_idx := 1;
      mem_lnk := first_link;
      { index = mem_idx }.until_do {
	mem_lnk := mem_lnk.next;
	mem_idx := mem_idx + 1;
      };
    };
    
    ? { mem_idx = index };
    ? {  mem_lnk != NULL };
  );
  
  
  - invariant:BOOLEAN <-
  (
    ( (first_link = NULL) ->>   { (last_link = NULL) & (upper = 0) & (mem_idx = 0) & (mem_lnk = NULL)}) &&
    { ( first_link != NULL) ->> { (last_link != NULL) & (upper > 0) & (mem_idx > 0) & (mem_lnk != NULL)}}
  );
