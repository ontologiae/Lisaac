/****************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  - name        := COLLECTION2[E];
  
  - comment     :=
    "Abstract definition of a 2 dimensional collection of     \
    \elements of type E. The Lisaac standard library          \
    \(lisaac/lib/base) provides two implementations of        \
    \COLLECTION2[E]: ARRAY2[E] and FIXED_ARRAY2[E].           \
    \All implementations have exactly the same behavior.      \
    \Switching from one implementation to another only change \
    \the memory used and the execution time. .";
  
  - category    := MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Boutet Jerome (boutet@loria.fr), Benoit Sonntag (bsonntag@loria.fr)";
  
section INHERIT
  
  - parent_safe_equal:SAFE_EQUAL[E] := SAFE_EQUAL[E];
  
section PUBLIC
  
  // Indexing:
  
  - lower1 :INTEGER <-
  (
    // Lower index bounds.
    // deferred
  );
  
  
  - lower2 :INTEGER <-
  (
    // Lower index bounds.
    // deferred
  );
  
  
  - upper1 :INTEGER <-
  (
    // Upper index bounds.
    // deferred
  );
  
  
  - upper2 :INTEGER <-
  (
    // Lower index bounds.
    // deferred
  );
  
  
  // Reading:
  
  - item line, column:NUMERIC :E <-
  (
    ? { valid_index line,column};
    // deferred
  );
  
  
  // Writing:
  
  - put element:E to line, column:NUMERIC <-
  (
    ? { valid_index line,column};
    // deferred
    
    // ensure
    //    item(line,column) = element
  );
  
  
  - force element:E to line, column:NUMERIC <-
  // Put `element' at position (`line',`column'). Collection is
  // resized first when (`line',`column') is not inside current
  // bounds. New bounds are initialized with default values.
  (
    ? { line >= 0 };
    ? { column >= 0 };
    // deferred
    
    //ensure
    //   item(line,column) = element;
    //   count >= old count;
  );
  
  
  // Index validity:
  
  - valid_line line:NUMERIC :BOOLEAN <- 
  (
    lower1 <= line && line <= upper1
  );
  
  
  - valid_index1 line:NUMERIC :BOOLEAN <-
  (
    valid_line line
  );
  
  
  - valid_column column:NUMERIC :BOOLEAN <- 
  (
    lower2 <= column && column <= upper2
  );
  
  
  - valid_index2 column:NUMERIC :BOOLEAN <-
  (
    valid_column column
  );
  
  
  
  - valid_index line, column:NUMERIC :BOOLEAN <-
  (
    valid_line line && valid_column column
  );
  
  
  // Counting:
  
  - count1 :INTEGER <-
  // Size of the first dimension.
  (
    // deferred
    
    // ensure
    //    result = upper1 - lower1 + 1;
  );
  
  - line_count :INTEGER <- 
  // Equivalent of `count1'.
  (
    count1
  );
  
  
  - count2 :INTEGER <-
  // Size of the second dimension.
  (
    // deferred
    
    // ensure
    // result = upper2 - lower2 + 1;
  );
  
  
  - column_count :INTEGER <- 
  (
    count2
  );
  
  
  - count:INTEGER <-
  // Total number of elements.
  (
    // deferred
    
    // ensure
    //    result = line_count * column_count
  );
  
  
  - swap line1, column1:NUMERIC with line2, column2:NUMERIC <-
  // Swap the element at index (`line1',`column1') with the
  // the element at index (`line2',`column2').
  (
    ? { valid_index line1,column1 };
    ? { valid_index line2,column2 };
    // deferred
    
    //ensure
    //   item(line1,column1) = old item(line2,column2);
    //   item(line2,column2) = old item(line1,column1);
    // count = old count
  );
  
  
  - set_all_with v:E <-
  // Set all item with value `v'.
  (
    // deferred
    // ensure
    //    count = old count
  );
  
  
  - clear_all <-
  // Set all items to default values.
  (
    + value:E;
    + old_count:INTEGER;
    old_count:= count;
    
    set_all_with value;
    ? { count = old count };
  );
  
  
  // Creating or initializing:
  
  - from_collection2 model:COLLECTION2[E] <-
  //  Uses `model' to initialize Current.
  (
    ? { model != NULL };
    
    // deferred
    
    // ensure
    // count1 = model.count1;
    // count2 = model.count2
  );
  
  
  - from_model model:COLLECTION[COLLECTION[E]] <-
  // The `model' is used to fill line by line Current.
  // Assume all sub-collections of `model' have the same
  // number of lines.
  (
    ? { model != NULL };
    
    // deferred
    // ensure
    //  count1 = model.count;
    //  count2 > 0 -> count2 = model.first.count
  );
  
  
  // Looking and comparison:
  
  - all_default :BOOLEAN <-
  // Do all items have their type's default value?
  (
    // deferred
  );
  
  
  - same_as other:COLLECTION2[E] :BOOLEAN <-
  // Unlike `is_equal', this feature can be used to compare
  // distinct implementation of COLLECTION2.
  (
    ? { other != NULL };
    // deferred
    
    //ensure
    // result -> standard_same_as(other)
  );
  
  
  // Printing:
  
  - fill_tagged_out_memory <-
  (
    + line:INTEGER;
    +v:E;
    
    tagged_out_memory.append "lower1:";
    lower1.append_in tagged_out_memory;
    tagged_out_memory.append " upper1:";
    upper1.append_in tagged_out_memory;
    tagged_out_memory.append " lower2:";
    lower2.append_in tagged_out_memory;
    tagged_out_memory.append " upper2:";
    upper2.append_in tagged_out_memory;
    tagged_out_memory.append " [\n";
    
    line := lower1;
    { (line > upper1) || { tagged_out_memory.count > 4096 }}.until_do {
      tagged_out_memory.append(once "line ");
      line.append_in(tagged_out_memory);
      tagged_out_memory.append(once "\t:");
      
      lower2.to upper2 do { column:INTEGER;
	v := item line,column;
	( v = NULL).if {
	  tagged_out_memory.append(once "NULL");
	} else {
	  v.out_in_tagged_out_memory;
	}; // end if
	tagged_out_memory.extend(' ');
      }; // end do
      tagged_out_memory.extend('\n');
      line := line + 1;
    }; // end until_do
    ( valid_line line).if {
      tagged_out_memory.append(once "......\n");
    }; // end if
  );
  
  
  // Miscellaneous features:
  
  - occurrences elt:E :NUMERIC <-
  // Number of occurrences using `equal'.
  // See also `fast_occurrences' to chose the apropriate one.
  (
    // deferred
    // ensure
    //    result >= 0
  );
  
  
  - fast_occurrences elt:E :NUMERIC <-
  // Number of occurrences using `='.
  // See also `occurrences' to chose the apropriate one.
  (
    // deferred
    // ensure
    //    result >= 0
  );
  
  
  - has x:E :BOOLEAN <-
  // Search if a element x is in the array using `equal'.
  // See also `fast_has' to chose the apropriate one.
  (
    // deferred
  );
  
  
  - fast_has x:E :BOOLEAN <-
  //  Search if a element x is in the array using `='.
  (
    // deferred
  );
  
  
  - replace_all old_value:E with new_value:E <-
  // Replace all occurences of the element `old_value' by `new_value'
  // using `equal' for comparison.
  // See also `fast_replace_all' to choose the apropriate one.
  (
    // deferred
    
    // ensure
    //    count = old count;
    //    occurrences(old_value) = 0
  );
  
  
  - fast_replace_all old_value:E with new_value:E <-
  // Replace all occurences of the element `old_value' by `new_value'
  // using operator `=' for comparison.
  // See also `replace_all' to choose the apropriate one.
  (
    // deferred
    
    // ensure
    //    count = old count;
    //    fast_occurrences(old_value) = 0
  );
  
  
  - sub_collection line_min,column_min:NUMERIC to line_max,column_max:NUMERIC :SELF <-
  // Create a new object using selected area of `Current'.
  (
    ? { valid_index line_min,column_min};
    ? { valid_index line_max,column_max};
    
    // deferred
    // ensure
    //    result != NULL
  );
  
  
  - set_area line_min,column_min:NUMERIC to line_max,column_max:NUMERIC with element:E <-
  // Set all the elements of the selected area rectangle with `element'.
  (
    ? { valid_index line_min,column_min };
    ? { valid_index line_max,column_max };
    
    line_min.to line_max do { line:INTEGER;
      column_min.to column_max do { column:INTEGER;
	put element to line,column;
      }; // end do
    }; // end do
    
    ? { count = old count };
  );
  
  
  // COLLECTION2 For `same_as' implementation:
  
  - standard_same_as other:COLLECTION2[E] :BOOLEAN <-  //frozen
  (
    + result:BOOLEAN;
    + line, column:INTEGER;
    
    ? { generating_type != other.generating_type};
    
    (lower1 != other.lower1).if {
    }.elseif {upper1 != other.upper1} then {
    }.elseif {lower2 != other.lower2} then {
    }.elseif {upper2 != other.upper2} then {
    } else {
      result := TRUE;
      line := upper1;
      {! result || {line < lower1}}.until_do {
	column := upper2;
	{! result || {column < lower2}}.until_do {
	  result := safe_equal (item line,column),(other.item line,column);
	  column := column - 1;
	}; // end until_do
	line := line - 1;
      }; // end until_do
    }; // end if
  );
  
  
  - same_as_array2 other:ARRAY2[E] :BOOLEAN <-
  (
    ? { other != NULL };
    
    // deferred
  );
  
  
  - same_as_fixed_array2 other:FIXED_ARRAY2[E] :BOOLEAN <-
  (
    ? { other != NULL };
    
    // deferred
  );
  
  
