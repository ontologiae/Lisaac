/***************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Jerome BOUTET  - boutet@loria.fr                       *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
****************************************************************************/

section HEADER
  
  * name        := REAL_24_8 -> INTEGER; // Provisoir...
  // Aucun Auto-Cast pour l'instant...(peu etre
  // REAL ...)
  
  - comment     := "signed 24.8 fixed float.";
  
  - category    := MICRO;
  
  - bibliography:= "http://IsaacOS.com";
  - author      := "Benoit Sonntag (bsonntag@loria.fr)";
  
  - type        := `signed long`;
  - default     := 0;
  
section INHERIT
  
  - parent_signed:SIGNED := SIGNED;
  
section PUBLIC
  
  - object_size:INTEGER := 4;
  
  //
  // Range.
  //
  
  - minimum:ULONGINT <- - 8388608 ; // (-2**23)

  - maximum:ULONGINT <- 8388607; // (2**23)-1
  
  //
  // Convertion format with test.
  //
  
  - to_ulongint:ULONGINT   <- 
  ( ? {in_range 0 to (ULONGINT.maximum)};
    floor    
  );
  
  - to_uinteger:UINTEGER   <- 
  ( ? {in_range 0 to (UINTEGER.maximum)};
    floor
  );
  
  - to_ushortint:USHORTINT <- 
  ( ? {in_range 0 to (USHORTINT.maximum)};
    floor.to_ushortint
  );
  
  - to_usmallint:USMALLINT <- 
  ( ? {in_range 0 to (USMALLINT.maximum)};
    floor.to_usmallint
  );
  
  - to_longint:LONGINT     <- 
  ( ? {in_range (LONGINT.minimum) to (LONGINT.maximum)};
    floor
  );
  
  - to_integer:INTEGER     <- 
  ( ? {in_range (INTEGER.minimum) to (INTEGER.maximum)};
    floor.to_integer
  );
  
  - to_shortint:SHORTINT   <- 
  ( ? {in_range (SHORTINT.minimum) to (SHORTINT.maximum)};
    floor.to_shortint
  );
  
  - to_smallint:SMALLINT   <- 
  ( ? {in_range (SMALLINT.minimum) to (SMALLINT.maximum)};
    floor.to_smallint
  );
  
  - to_ureal_26_6:UREAL_26_6 <-
  ( ? { in_range O to (UREAL_26_6.maximum)};
    (to_raw_integer >> 2).to_raw_ureal_26_6    
  );
  
  - to_real_24_8:REAL_24_8 <- self;
  
  - floor:INTEGER <-
  // Greatest integral value no greater than Current.
  ( + result:INTEGER;
    
    result:=to_raw_integer >> 8;
    ? {self <= result.to_real_24_8};
    ? {(self - result.to_real_24_8) < 1};
    result
  );
  
  - ceiling:INTEGER <-
  // Smallest integral value no smaller than Current.
  ( + result:INTEGER;
    
    result:=(to_raw_integer+255) >> 8;
    ? {self >= result.to_real_24_8};
    ? {(self - result.to_real_24_8) < 1};
    result
  );
  
  - rounded:INTEGER <-
  // Rounded integral value.
  (
    (to_raw_integer+128) >> 8
  );
  
  - truncated_to_integer:INTEGER <- floor;
  // Integer part (largest absolute value no greater than Current).
  
  //
  // binary operator :
  //
  
  - '-'  left 80  other:SELF :SELF <- 
  (
    (to_raw_integer - other.to_raw_integer).to_raw_real_24_8
  );

  - '*#' left 100 other:INTEGER :SELF <- 
  (    
    (to_raw_integer * other).to_raw_real_24_8
  );
  
  - '*'  left 100 other:SELF :SELF <- 
  (
    ((to_raw_longint * other.to_raw_longint)>>8).to_raw_real_24_8
  );
  
  - '/#' left 100 other:INTEGER :SELF <- 
  (
    (to_raw_integer / other).to_raw_real_24_8
  );
  
  - '/'  left 100 other:SELF :SELF <- 
  (
    ((to_raw_longint << 8)/ other.to_raw_longint).to_raw_real_24_8
  );
  
  - '&'  left 100 other:SELF :SELF <-
  (
    (to_raw_integer & other.to_raw_integer).to_raw_real_24_8
  );
  
  - '>>' left 100 other:NUMERIC :REAL_24_8 <- (to_raw_integer >> other).to_real_24_8;  
  
  - '<<' left 100 other:NUMERIC :REAL_24_8 <- (to_raw_integer << other).to_real_24_8;
  
  //
  // Test binary operator :
  //
  
  - '>'   right 60 other:SELF :BOOLEAN <- 
  (
    to_raw_integer > other.to_raw_integer
  );
  
  //
  // prefix : Unary operator
  //
  
  - '~' :SELF <- 
  (
    (~ to_raw_integer).to_raw_real_24_8
  );
  
  //
  // Convertion
  //
  
  - append_in buffer:STRING <- 
  // Append in the `buffer' the equivalent of `to_string'. No new STRING
  // creation during the process.
  ( + val:INTEGER;
    + old_count,new_count:INTEGER;
    ? {buffer!=NULL};
    
    val := self.to_raw_integer;
    
    (val < 0).if {
      val := - val;
      buffer.extend '-';
    };
    (val >> 8).append_in buffer;
    buffer.extend '.';

    old_count:=buffer.count;
    //     1/256 = 0.00390625 => 8 digit.
    (((val & 255).to_ulongint * 100000000)>>8).to_integer.append_in buffer;
    new_count:=old_count+8;
    {buffer.count!=new_count}.while_do {
      buffer.insert '0' to old_count;
    };

  );
  
  
  
  
  
  
  
  
  
  
