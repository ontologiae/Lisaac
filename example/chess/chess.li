Section Header  
  
  + name     := CHESS;
  
  - comment   := "3D Chess Game";
  
  - author    := "Damien Bouvarel (dams.bouvarel@wanadoo.fr)";
  
Section Inherit
  
  - parent_framework:FRAMEWORK := FRAMEWORK;

  + parent_scene:Expanded SCENE;
  
  - parent_reshape:RESHAPE := RESHAPE;
  
  - parent_event_listener:EVENT_LISTENER := EVENT_LISTENER;

Section Public  
  
  - main <-
  ( 
    // pixel format query
    CAPABILITIES.use_stencil_buffer;
    
    OPENGL.set_reshape Self;
   
    OPENGL.make (800,600) title "3D Chess Game";
    FRAMEWORK.make OPENGL;
    
    attach_scene Self;
    add_key_listener Self;
    add_mouse_listener Self;
    
    // start game
    run;
  );
  
Section Public
  
  - square_size:INTEGER := 32;
  
  // pieces
  - p1:FAST_ARRAY(PIECE);
  - p2:FAST_ARRAY(PIECE);
  
  - chessboard:FAST_ARRAY(PIECE); 
  
  - gamestate:GAMESTATE := GAMESTATE;
  
  - current_square:SQUARE; // for highlighting
  - current_world:SCENE;
  
  
  - board_texture:TEXTURE;
  
  - black_texture:TEXTURE;
  - white_texture:TEXTURE;
  
  - camera:CHESSCAM;
  
  - selection_color:COLOR := RGB.create (0,0.7,0);
  - current_color:COLOR := RGB.create (0.4,0,0.4);
  
  - move_ok_color:COLOR := RGB.create (0,0.7,0);
  - illegal_move_color:COLOR := RGB.create (0.8,0,0);
  
  - light:LIGHT;
  - light_pos:VECTOR3(REAL_32);
  
  - light_shader:SHADER;
  - loc_texture:INTEGER;
  
  - sphere:SPHERE;// to represent light source
  
  - piece_material:MATERIAL;
  - board_material:MATERIAL;
  
  - shadow_matrix:MATRIX4(REAL_32);
  - shadow_plane:PLANE;
  
  - particle_system:PARTICLE_SYSTEM;// when capture is on
  - particle_texture:TEXTURE;

  - modelview:MATRIX4(REAL_32);
  - dx:VECTOR3(REAL_32) := VECTOR3(REAL_32).zero;
  - dy:VECTOR3(REAL_32) := VECTOR3(REAL_32).zero;
  
  - logo:TEXTURE;
  
  
  - initialize:BOOLEAN <-
  ( + infolog:STRING;
    + board:FAST_ARRAY(UINTEGER_8);
    + dim:INTEGER;
    + orig,pf_pos:VECTOR3(REAL_32);
    + ambient,diffuse,specular,emission:RGB;
    + shine:REAL_32;
    + constraint:CONSTRAINT;
    
    //
    // load textures
    //
    
    black_texture := renderer.texture2d.create_from (IMAGE.create "textures/black.bmp");
    white_texture := renderer.texture2d.create_from (IMAGE.create "textures/white.bmp");
    
    
    dim := 256;
    board := FAST_ARRAY(UINTEGER_8).create (dim*dim);
    
    // procedural image
    0.to (dim-1) do { i:INTEGER;
      0.to (dim-1) do { j:INTEGER;
        ((i^j)%64 < 32).if {
          board.put 0 to (i*dim+j);
        } else {
          board.put 255 to (i*dim+j);
        }
      };
    };
    
    board_texture := renderer.texture2d.create_from_data board size (dim,dim) type 1;
    logo := renderer.texture2d.create_from (IMAGE.create "textures/logo.bmp");
    
    //
    // load models
    //
    
    p1 := FAST_ARRAY(PIECE).create_with_capacity 16;
    p2 := FAST_ARRAY(PIECE).create_with_capacity 16;
    chessboard := FAST_ARRAY(PIECE).create 64;
    
    0.to 7 do { i:INTEGER;
      load_piece PAWN at (i,6) in p1 player 1;
      load_piece PAWN at (i,1) in p2 player 2;
    };
    
    load_piece ROOK at (0,7) in p1 player 1;
    load_piece ROOK at (7,7) in p1 player 1;
    load_piece ROOK at (0,0) in p2 player 2;
    load_piece ROOK at (7,0) in p2 player 2;
    
    load_piece KNIGHT at (1,7) in p1 player 1;
    load_piece KNIGHT at (6,7) in p1 player 1;
    load_piece KNIGHT at (1,0) in p2 player 2;
    load_piece KNIGHT at (6,0) in p2 player 2;
    
    load_piece BISHOP at (2,7) in p1 player 1;
    load_piece BISHOP at (5,7) in p1 player 1;
    load_piece BISHOP at (2,0) in p2 player 2;
    load_piece BISHOP at (5,0) in p2 player 2;
    
    load_piece QUEEN at (4,7) in p1 player 1;
    load_piece QUEEN at (3,0) in p2 player 2;
    
    load_piece KING at (3,7) in p1 player 1;
    load_piece KING at (4,0) in p2 player 2; 
    
    
    set_world WORLD1;
    
    camera := CHESSCAM.create;
    
    //
    // intro motion (rotate around chessboard..)
    //
    orig := VECTOR3(REAL_32).zero;
    camera.add_waypoint (VECTOR3(REAL_32).create (0, 100, -800));
    camera.add_waypoint orig;
    
    camera.add_waypoint (VECTOR3(REAL_32).create (0,150,-300));
    camera.add_waypoint orig;
    
    camera.add_waypoint (VECTOR3(REAL_32).create (500, 250, 0));
    camera.add_waypoint (VECTOR3(REAL_32).create (0, 100, 50));
    
    camera.add_waypoint (VECTOR3(REAL_32).create (0,200,300));
    camera.add_waypoint orig;
    
    //
    // capture effect
    ///
    
    particle_system := PARTICLE_SYSTEM.create orig;
    particle_system.set_size (2, 0.5);
    particle_system.set_spawn_rate 4;
    
    pf_pos := VECTOR3(REAL_32).create (0, 80, 0); // attraction point
    
    constraint := POINT_FORCE.create (pf_pos,0.005,0,0.001);
    particle_system.add_constraint constraint;
    
    constraint := BOUNCE_PLANE.create (VECTOR3(REAL_32).create (0,1,0), 20);
    particle_system.add_constraint constraint;
    
    
    // load particle texture
    renderer.texture2d.set_wrapping_mode (renderer.texture2d.clamp);
    particle_texture := renderer.texture2d.create_from (IMAGE.create "textures/particle.bmp");
    renderer.texture2d.set_wrapping_mode (renderer.texture2d.repeat);
    
    modelview := MATRIX4(REAL_32).create;
    
    //
    //  Board lighting
    //
    
    OPENGL.use_shaders.if_false {
      log.append "Cannot support GLSL Shaders with ARB extensions";
    } else {
      // per-pixel lighting
      light_shader := renderer.shader.create ("shaders/light.vert","shaders/light.frag");
      light_shader.enable;
      
      light_shader.has_compiled.if_false {
        // print shader compilation errors - shader is disabled
        infolog := STRING.create 32;
        light_shader.get_infolog infolog;
        
        log.append "Compilation error(s) in light shader: ";
        log.append infolog;
      };
      loc_texture := light_shader.get_uniform_location "texture";
      light_shader.disable;
    };
    
    // create OpenGL light (also used in light shader)
    light_pos := VECTOR3(REAL_32).create (50,300,-30);
    ambient := RGB.create (0.2, 0.2, 0.2);
    diffuse := RGB.create (1.0, 1.0, 1.0);
    specular := RGB.create (1.0, 1.0, 1.0);
    
    light := renderer.light.create (ambient,diffuse,specular) at light_pos;
    
    // board piece material    
    ambient := RGB.create (0.2, 0.2, 0.2); 
    diffuse := RGB.create (1.0, 1.0, 1.0);
    specular := RGB.create (1.0, 1.0, 1.0);
    emission := RGB.create (0.0, 0.0, 0.0);// no emission
    shine := 50.0;
    
    piece_material := renderer.material.create (ambient,diffuse,specular,emission,shine);
    
    ambient := RGB.create (1.0, 1.0, 1.0); 
    diffuse := RGB.create (1.0, 1.0, 1.0);
    specular := RGB.create (1.0, 1.0, 1.0);
    shine := 8.0;
    
    board_material := renderer.material.create (ambient,diffuse,specular,emission,shine);
    
    
    // debug light position
    sphere := SPHERE.create (light_pos,2,10,10);
    
    light.enable;
    
    // stencilling is used for reflections
    renderer.stencil_buffer.set_clear_value 0.0;
    
    // for shadow casting
    shadow_matrix := MATRIX4(REAL_32).create;
    
    // cast shadow on board plane
    shadow_plane := renderer.plane.create (0,1,0,0);
    
    on_resize (800,600);
    TRUE
  );
  
  - load_piece type:PIECE at (x,y:INTEGER) in p:FAST_ARRAY(PIECE) player pl:INTEGER <-
  ( + piece:PIECE;
    
    piece := type.create (x,y,pl) index (p.count);
    p.add_last piece;
    chessboard.put piece to (y*8+x);
  );
  
  - counter:REAL_32;
  
  - render t:REAL_32 <-
  (         
    + time:REAL_32;
    + board_half_size:INTEGER;
    
    board_half_size := square_size*4;

    camera.animate t;
    camera.look;
    
    // update game
    gamestate.play;
    
    // draw world around
    current_world.render t;
    
    // first pass of rendering pieces
    render_shadows_and_reflections board_half_size;
    
    // draw board
    render_chessboard board_half_size;
    
    //
    // render pieces
    //
    
    time := t*50;
    0.to 15 do { i:INTEGER;
      (p1.item i = gamestate.current_piece).if {
        p1.item i.update_selected time;
      } else {
        p1.item i.update time;
      };
      (p2.item i = gamestate.current_piece).if {
        p2.item i.update_selected time;
      } else {
        p2.item i.update time;
      };
      
      // rotate light around
      counter := counter+time*0.001;
      light_pos.set_x (100.0 * (0.78*counter).cos);
      light_pos.set_y (50.0 * (0.3*counter).cos + 100);
      light_pos.set_z (100.0 * (1.0*counter).sin); 
      
      // debug light position
      renderer.texture2d.disable;
      renderer.color_buffer.set_color3f (0.9, 1.0, 0.6);
      sphere.render;
      renderer.color_buffer.set_color3f (1, 1, 1);
      renderer.texture2d.enable;
      
      
      renderer.enable_lighting;  
      ////
      
      // if light position is modified 
      light.set_position light_pos;
      light.enable;
      
      piece_material.apply_front;
      
      (light_shader != NULL).if {
        // per-pixel lighting if shader is supported
        light_shader.enable;
        light_shader.bind_sampler black_texture unit 0 location loc_texture;
      };
      
      // draw black pieces
      p1.item i.render renderer;
      
      (light_shader != NULL).if {
        light_shader.bind_sampler white_texture unit 0 location loc_texture;
      };
      
      // draw white pieces
      p2.item i.render renderer;
      
      (light_shader != NULL).if {
        light_shader.disable;
      };
      
      /////
      renderer.disable_lighting;  
    };
    
    //
    // render particles
    //
    
    gamestate.capture.if {
      renderer.transform.get_modelview modelview;

      // let particles face the camera (billboard) 
      dx.make (modelview.item (0,0), modelview.item (1,0), modelview.item (2,0));
      dy.make (modelview.item (0,1), modelview.item (1,1), modelview.item (2,1));
      renderer.blending.apply (renderer.blending.src_color,renderer.blending.one);
      renderer.blending.enable;
      
      // update & render
      particle_system.update (t.to_real);
    
      particle_texture.bind;
      
      renderer.transform.new_matrix {
        PIECE.set_renderer renderer at_position (gamestate.move_dest);
        
        particle_system.render (dx,dy);
      };
      
      renderer.blending.disable;
    };
    
    // draw logo
    camera.is_traveling.if_false {
      renderer.light.push_attrib;
      renderer.transform.ortho_mode (renderer.width,renderer.height) do {
        
        (gamestate.current_player = 1).if {
          renderer.color_buffer.set_color3f (0.4,0.6,0.8);// blue
        } else {
          renderer.color_buffer.set_color3f (0.8,0.6,0.4);// orange
        };
        logo.draw_strech (50,50,64,64);
        renderer.color_buffer.set_color3f (1,1,1);
      };
      renderer.light.pop_attrib;
    };
    //----- end rendering
  );
  
  - render_chessboard sz:INTEGER <-
  (
    + x:INTEGER;
    
    //
    // render board
    //
    
    //renderer.enable_lighting;  
    /////
    //  board_material.apply_front;
    
    
    renderer.blending.apply (renderer.blending.src_alpha, renderer.blending.one_minus_src_alpha);
    renderer.blending.set_alpha_value 0.7;
    renderer.blending.enable;
    
    board_texture.bind;
    
    renderer.transform.new_matrix {
      
      renderer.vb.new_quads {
        renderer.vb.add_normal3f (0.0, 1.0, 0.0);
        
        renderer.vb.add_texel2f (0.0, 1.0);
        renderer.vb.add_vertex3f (-sz, 0.0, sz);
        
        renderer.vb.add_texel2f (0.0, 0.0);
        renderer.vb.add_vertex3f (-sz, 0.0, -sz);
        
        renderer.vb.add_texel2f (1.0, 0.0);
        renderer.vb.add_vertex3f (sz, 0.0, -sz);
        
        renderer.vb.add_texel2f (1.0, 1.0);
        renderer.vb.add_vertex3f (sz, 0.0, sz);
      };
      
      renderer.blending.disable;
      
      /////
      //     renderer.disable_lighting;  
      
      // render selected squares
      camera.is_traveling.if_false {
        gamestate.piece_selected.if {
          gamestate.current_piece.check_move (gamestate.move_orig) to current_square.if {
            // move ok
            current_square.render renderer color move_ok_color;
          } else {
            current_square.render renderer color illegal_move_color;
          };
        } else {
          current_square.render renderer color current_color;
        };
        gamestate.piece_selected.if {
          gamestate.move_orig.render renderer color selection_color;
        };
      };
    };
    
    x := renderer.width / 2 - 50;
    renderer.font.print_zone {
      out.print "3D Chess Game" at (x,50);
      
      (gamestate.current_piece != NULL).if {
        out.print ("this is "+gamestate.current_piece.name+gamestate.current_piece.player.to_string) at (x,500);
      } else {
        out.print "Pick up a piece" at (x,500);
      };
    };
  );
  
  - render_shadows_and_reflections sz:INTEGER <-
  (
    //
    // First pass: draw an invisible mask of the floor in the stencil buffer
    //
    
    // disable drawing in color buffer
    renderer.color_buffer.disable;
    
    renderer.stencil_buffer.clear;
    renderer.stencil_buffer.enable;
    
    // stencil test always pass and set stencil value to 1 
    renderer.stencil_buffer.set_function (renderer.stencil_buffer.always) value 1 mask 1;
    
    // if test successful replace stencil value else keep the old value
    renderer.stencil_buffer.when_pass (renderer.stencil_buffer.replace) when_fail (renderer.stencil_buffer.keep) when_zfail (renderer.stencil_buffer.keep);
    
    renderer.depth_buffer.disable;
    
    // render board in stencil buffer
    renderer.vb.new_quads {  
      renderer.vb.add_vertex3f (-sz, 0.0, sz);
      renderer.vb.add_vertex3f (-sz, 0.0, -sz);
      renderer.vb.add_vertex3f (sz, 0.0, -sz);
      renderer.vb.add_vertex3f (sz, 0.0, sz);
    };
    
    // back to color mode
    renderer.depth_buffer.enable;
    renderer.color_buffer.enable;
    
    //
    // Second pass: draw reflections & shadows in the masked floor (stencil test enabled)
    //
    
    // only draw pixels masked with 1 in stencil buffer
    renderer.stencil_buffer.set_function (renderer.stencil_buffer.equal) value 1 mask 1;
    renderer.stencil_buffer.lock; // read-only
    
    ////
    render_reflections;
    render_shadows;
    ///
    
    // back to normal mode
    renderer.stencil_buffer.disable;
    renderer.depth_buffer.enable;
  );
  
  - render_reflections <-
  (
    renderer.transform.new_matrix {
      
      // mirror y axis
      renderer.transform.scalef (1.0, -1.0, 1.0);
      
      // draw reflections
      0.to 15 do { i:INTEGER;
        p1.item i.render renderer;
        p2.item i.render renderer;
      };
    };
  );
  
  - render_shadows <-
  (
    + dot:REAL_32;
    
    renderer.depth_buffer.disable;
    
    //
    // build a shadow matrix from light position & shadow plane
    //
    
    // dot product between shadow plane & light_position
    dot := shadow_plane.a * light_pos.x + shadow_plane.b * light_pos.y + shadow_plane.c * light_pos.z + shadow_plane.d;
    
    // first column
    shadow_matrix.put (dot - light_pos.x * shadow_plane.a) to (0,0);
    shadow_matrix.put (0.0 - light_pos.x * shadow_plane.b) to (1,0);
    shadow_matrix.put (0.0 - light_pos.x * shadow_plane.c) to (2,0);
    shadow_matrix.put (0.0 - light_pos.x * shadow_plane.d) to (3,0);
    
    // second column
    shadow_matrix.put (0.0 - light_pos.y * shadow_plane.a) to (0,1);
    shadow_matrix.put (dot - light_pos.y * shadow_plane.b) to (1,1);
    shadow_matrix.put (0.0 - light_pos.y * shadow_plane.c) to (2,1);
    shadow_matrix.put (0.0 - light_pos.y * shadow_plane.d) to (3,1);
    
    // third column
    shadow_matrix.put (0.0 - light_pos.z * shadow_plane.a) to (0,2);
    shadow_matrix.put (0.0 - light_pos.z * shadow_plane.b) to (1,2);
    shadow_matrix.put (dot - light_pos.z * shadow_plane.c) to (2,2);
    shadow_matrix.put (0.0 - light_pos.z * shadow_plane.d) to (3,2);
    
    // fourth column
    shadow_matrix.put (0.0 - shadow_plane.a) to (0,3);
    shadow_matrix.put (0.0 - shadow_plane.b) to (1,3);
    shadow_matrix.put (0.0 - shadow_plane.c) to (2,3);
    shadow_matrix.put (dot - shadow_plane.d) to (3,3);
    
    // shadow color (dark)
    renderer.color_buffer.set_color3f (0, 0, 0);
    renderer.texture2d.disable;
    
    renderer.transform.new_matrix {
      
      // set OpenGL modelview matrix in shadow space
      renderer.transform.mult_matrix_by shadow_matrix;
      
      // draw shadows
      0.to 15 do { i:INTEGER;
        p1.item i.render renderer;
        p2.item i.render renderer;
      };
    };
    renderer.color_buffer.set_color3f (1, 1, 1);
    renderer.texture2d.enable;
  );
  
  //
  // Selection.
  //
  
  - hits:FAST_ARRAY(UINTEGER_32) := FAST_ARRAY(UINTEGER_32).create 512;
  
  - select_piece (x,y:UINTEGER_32) :PIECE <-
  // selection from camera view vector
  ( 
    + nb_hits:INTEGER;
    + choose,depth:UINTEGER_32;
    + v:VIEWPORT;
    + result:PIECE;
    
    v := renderer.viewport;
    
    // start selection mode, hits are recorded in 'hits' array
    renderer.begin_selection_in hits size 512;
    
    // restrict the viewing volume to the mouse click region
    renderer.transform.new_projection {
      renderer.transform.push_matrix;
      renderer.transform.load_identity;
      
      // create 5x5 pixel picking region near cursor location 
      renderer.transform.pickmatrix (x, v.height - y, 5, 5) in v;
      
      // multiply it the viewing volume matrix
      renderer.transform.perspective (renderer.fov, (v.width-v.x0).to_real/(v.height-v.y0).to_real, 0.1, 5000);
    };
    
    // initialize the name stack
    renderer.name_stack.init;
    renderer.name_stack.push (-1);// not to have an empty stack
    
    // draw pieces in selection buffer
    0.to 15 do { i:INTEGER;
      renderer.name_stack.load (p1.item i.id);
      p1.item i.render renderer;
      
      renderer.name_stack.load (p2.item i.id);
      p2.item i.render renderer;
    };
    
    // go back to previous projection
    renderer.transform.new_projection {
      renderer.transform.pop_matrix;
    };
    
    // go back to render mode 
    nb_hits := renderer.end_selection;
    
    //
    //  Buffer format:
    //    for each hit:
    //       0:  number of names for this hit
    //       1:  z-min value of the hit
    //       2:  z-max value of the hit
    //       3:  content of the name stack (bottom of stack)
    //       ...
    
    // choose the closest object hit
    (nb_hits > 0).if {
      choose := hits.item 3;
      depth := hits.item 1;
      
      1.to (nb_hits-1) do { i:INTEGER;
        (hits.item (i*4+1) < depth).if { // here the name stack has 1 elt
          choose := hits.item (i*4+3);
          depth := hits.item (i*4+1);
        };
      };
      result := get_piece_from choose;
    };
    result
  );
  
  - select_square (x,y:UINTEGER_32) :SQUARE <-
  // selection from camera view vector
  ( + result:SQUARE;
    + target:VECTOR3(REAL_32);
    + fraction,start_dist,end_dist,start_frac,end_frac,epsilon:REAL_32;
    + x_col,z_col:REAL_32;
    + px,py:INTEGER;
    
    // create ray from camera eye in world space
    
    // camera.view.set_y (camera.view.y + 0.05); // bug fix..
    target := camera.position + (camera.view * 1000);
    //   camera.view.set_y (camera.view.y - 0.05); // big fix..
    
    epsilon := 0.325;
    start_frac := -1.0;
    end_frac := 1.0;
    
    // check collision: ray vs board plane (XZ plane, normal=(0,1,0))
    start_dist := camera.position.y; // a*x+b*y+c*z-d
    end_dist := target.y;
    
    ((start_dist > 0) && {end_dist > 0}).if_false {
      // else ray is not colliding
      
      (start_dist > end_dist).if {
        fraction := (start_dist - epsilon) / (start_dist - end_dist);
        (fraction > start_frac).if {
          start_frac := fraction;
        };
      } else {
        fraction := (start_dist + epsilon) / (start_dist - end_dist);
        (fraction < end_frac).if {
          end_frac := fraction;
        };
      };
      (
        (start_frac < end_frac) && 
        {start_frac > -1.0} &&
        {start_frac < 1.0}
      ).if {
        // collision
        
        fraction := start_frac;
        (fraction < 0).if {
          fraction := 0;
        };
        x_col := camera.position.x + (target.x-camera.position.x) * fraction;
        z_col := camera.position.z + (target.z-camera.position.z) * fraction;
        
        x_col := (4.0*square_size-x_col) / square_size; // to board space
        z_col := (z_col+4.0*square_size) / square_size; // to board space
        
        px := x_col.to_integer;
        (px < 0).if {
          px := 0;
        };
        py := z_col.to_integer;
        (py < 0).if {
          py := 0;
        };
        result := SQUARE.create (px, py);
      };
    };
    
    result
  );
  
  - get_piece_from id:UINTEGER_32 :PIECE <-
  ( + result:PIECE;
    ((id & 01h) = 0).if {
      // player 1
      result := p1.item (id >> 1);
    } else {
      // player 2     
      result := p2.item (id >> 1);
    };
    result
  );
  
  - release <-
  (
    (current_world != NULL).if {
      current_world.release;
    };
    (light_shader != NULL).if {
      light_shader.delete;
    };
  );
  
  - set_world w:SCENE <-
  (
    (current_world != NULL).if {
      current_world.release; 
    };
    
    w.set_renderer renderer;
    current_world := w;
    
    current_world.initialize;
  );
  
  //
  // Input.
  //
  
  - keydown k:INTEGER <-
  (
     (k = KEYCODE.k_escape).if {
	FRAMEWORK.stop;
     };
  );
  
  - click b:INTEGER <-
  ( + x,y:UINTEGER_32;
    + piece:PIECE;
    + square:SQUARE;
    
    camera.is_traveling.if_false {
      
      x := event.mouse_x;
      y := event.mouse_y;
      
      piece := select_piece (x,y);
      (piece != NULL).if {
        square := piece.square;
      } else {
        square := select_square (x,y);
      };
      
      // update game
      gamestate.update square;
    };
  );
  
  - move (x,y:INTEGER) <-
  ( 
    camera.is_traveling.if_false {
      current_square := select_square (x,y);
    };
  );
  
  
  - on_resize (w,h:INTEGER) <-
  // world projection
  (
    + ratio:REAL_32;
    
    (renderer != NULL).if {
      ratio := renderer.width / renderer.height;
      
      renderer.transform.new_projection {
        renderer.transform.load_identity;
        
        renderer.transform.perspective (renderer.fov, w.to_real/h.to_real, 0.1, 5000.0);
      };
      // clear modelview matrix
      renderer.transform.load_identity;
    };
  );
