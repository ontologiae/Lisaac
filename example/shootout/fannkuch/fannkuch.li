///////////////////////////////////////////////////////////////////////////////
//                              Lisaac Example                               //
//                                                                           //
//                   LSIIT - ULP - CNRS - INRIA - FRANCE                     //
//                                                                           //
//   This program is free software: you can redistribute it and/or modify    //
//   it under the terms of the GNU General Public License as published by    //
//   the Free Software Foundation, either version 3 of the License, or       //
//   (at your option) any later version.                                     //
//                                                                           //
//   This program is distributed in the hope that it will be useful,         //
//   but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//   GNU General Public License for more details.                            //
//                                                                           //
//   You should have received a copy of the GNU General Public License       //
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.   //
//                                                                           //
//                     http://isaacproject.u-strasbg.fr/                     //
///////////////////////////////////////////////////////////////////////////////
Section Header
  
  + name         := FANNKUCH;
  
  - bibliography := "http://IsaacOS.com";
  - author       := "Xavier Oswald (x.oswald@free.fr)";
  - comment      := "Language shootout - fannkuch"; 
  
Section Inherit
  
  - parent_any:OBJECT := OBJECT;

Section Private

  - fannkuch(n:INTEGER) :INTEGER <-
  ( + perm            :FAST_ARRAY[INTEGER];
    + perm1           :FAST_ARRAY[INTEGER];
    + count           :FAST_ARRAY[INTEGER];
    + max_perm        :FAST_ARRAY[INTEGER];
    + exit, exit1     :BOOLEAN;    
    + check           :INTEGER;
    + perm0           :INTEGER;
    + max_flips_count :INTEGER;
    + flips_count     :INTEGER;
    + k, k2           :INTEGER;
    + i1, j           :INTEGER;
    + r, m            :INTEGER;
    m := n - 1;

    perm     := FAST_ARRAY[INTEGER].create n;
    count    := FAST_ARRAY[INTEGER].create n;
    max_perm := FAST_ARRAY[INTEGER].create n;
    perm1    := FAST_ARRAY[INTEGER].create_with_capacity n;

    0.to m do { i:INTEGER;
      perm1.add_last i; 
    };
    r := n;

    (n < 1).if {
      exit := TRUE;
    };

    {exit = FALSE}.while_do {
      // write-out the first 30 permutations
      (check < 30).if {
      //  0.to m do { i:INTEGER;
      //    ((perm1.item i) + 1).print;
      //  };
        perm1.foreach { elt : INTEGER;
          (elt+1).print;
        };
        '\n'.print;
        check := check + 1;
      };
      
      {r != 1}.while_do {
        count.put r to (r-1);
        r := r-1;
      };

      (! ((perm1.item 0 = 0) || {perm1.item m = m})).if {
        0.to m do { i:INTEGER;
          perm.put (perm1.item i) to i;
        };
       // perm.copy perm1;

        flips_count := 0;
        k := 0;
       
        {!((k:= perm.item 0) = 0)}.while_do {
          k2 := (k+1) >> 1;
          j := 0;
          {j < k2}.while_do {
            perm.swap j with (k-j);
            j := j+1;
          };
          flips_count := flips_count + 1;
        };

        (flips_count > max_flips_count).if {
          max_flips_count := flips_count;
          0.to m do { i:INTEGER;
            max_perm.put (perm1.item i) to i;
          };
        };
      };

      exit1 := FALSE;
      {exit1 = FALSE}.while_do {
        (r = n).if {
          exit  := TRUE;
          exit1 := TRUE;
        };
        perm0 := perm1.item 0;
        i1 := 0;
        {i1 < r}.while_do {
          j := i1+1;
          perm1.put (perm1.item j) to i1;
          i1 := j;
        };
        perm1.put perm0 to r;
        count.put ((count.item r) -1) to r;
        (count.item r > 0).if {
          exit1 := TRUE;
        } else {
          r := r+1;
        };
      };
    };
    max_flips_count
  );

Section Public
 
  - main <-
  ( + n      :INTEGER;
    + result :INTEGER;

    (COMMAND_LINE.upper = 1).if {
      n := COMMAND_LINE.item 1.to_integer;
    } else {
      n := 0;
    };
    result := fannkuch(n);
    "Pfannkuchen(".print;
    n.print;
    ") = ".print;
    result.print;
    '\n'.print;
  );
