/***************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
***************************************************************************/

section HEADER
 
  * name        :=NATIVE_ARRAY[E];
  
  - category    :=MICRO;
  
  - bibliography:="http://IsaacOS.com";
  - author      :="Sonntag Benoit (bsonntag@loria.fr)";

  - comment     :="Native array of collection library.";
  
section INHERIT
  
  - parent_safe_equal:SAFE_EQUAL[E] := SAFE_EQUAL[E];
  
section PUBLIC  
  
  //
  // Basic features:
  //
  
  - object_size:INTEGER := 0;
  
  - element_sizeof:INTEGER <- E.pointer_size;
  // The size in number of bytes for type `E'.
  
  - calloc_intern nb_elements:NUMERIC :NATIVE_ARRAY[E] <-
  // Allocate a new array of 'nb_elements' of type `E'.
  // The new array is initialized with default values.
  ( + capacity:INTEGER;
    + p:POINTER;
    + result  :NATIVE_ARRAY[E];
    ? {nb_elements > 0};
    
    //capacity := element_sizeof * nb_elements;
    capacity := nb_elements * element_sizeof;
    //'A'.print;
    p        :=MEMORY.allocation capacity;
    //'B'.print;
    result   := `(void*)@p`:NATIVE_ARRAY[E];
    result
  );
  
  - calloc nb_elements:NUMERIC :NATIVE_ARRAY[E] <-
  // Allocate a new array of `nb_elements' of type `E'.
  // The new array is initialized with default values.
  ( 
    + result:NATIVE_ARRAY[E];
    ? {nb_elements > 0};
    result:=calloc_intern nb_elements;
    result.clear_all (nb_elements-1); 
    result
  );
  
  - realloc old_nb_elts:NUMERIC with new_nb_elts:NUMERIC :NATIVE_ARRAY[E] <-
  // Assume Current is a valid NATIVE_ARRAY in range
  // [0 .. `old_nb_elts'-1]. Allocate a bigger new array in
  // range [0 .. `new_nb_elts'-1].
  // Old range is copied in the new allocated array.
  // New items are initialized with default values.
  ( 
    + new:NATIVE_ARRAY[E];
    ? {self != NULL};
    ? {old_nb_elts > 0};
    ? {old_nb_elts < new_nb_elts};
    
    new := calloc new_nb_elts;
    new.copy_from self until (old_nb_elts - 1);
    new
  );
  
  - first:E <- item 0;
  
  - item index:NUMERIC :E <-
  ( ? {index >= 0};
    
    `7` // External Lisaac #7
  );
  
  - put element:E to index:NUMERIC<-
  (     
    force_put element to index;
    
    ? {element = item index};
  );
  
  //
  // Displacement
  //
  
  - '+' left 80 other:NUMERIC :NATIVE_ARRAY[E] <- `@self+@other`:NATIVE_ARRAY[E];
  
  //
  // Comparison:
  //
  
  - memcmp other:NATIVE_ARRAY[E] until capacity:NUMERIC :BOOLEAN <-
  // True if all elements in range [0..capacity-1] are
  // identical using `equal'. Assume Current and `other'
  // are big enough.
  // See also `fast_memcmp'.
  ( + i:INTEGER;
    ? {(capacity > 0) -> other.is_not_null};
    
    i:=capacity-1;
    {(i>=0) && {safe_equal (item i),(other.item i)}}.while_do {
      i:=i-1;
    };
    i<0
  );
  
  - fast_memcmp other:NATIVE_ARRAY[E] until capacity:NUMERIC :BOOLEAN <-
  // Same jobs as `memcmp' but uses infix `=' instead `equal'.
  ( + i:INTEGER;
    ? {(capacity > 0) -> other.is_not_null};
    
    i:=capacity-1;
    {(i>=0) && {(item i)=(other.item i)}}.while_do {
      i:=i-1;
    };
    i<0
  );
  
  - deep_memcmp other:NATIVE_ARRAY[E] until capacity:NUMERIC :BOOLEAN <-
  // Same jobs as `memcmp' but uses `is_deep_equal' instead `equal'.
  ( + result:BOOLEAN;  // BEN : A REVOIR, il y a + efficace...
    + e1,e2:E;
    result := TRUE;
    (capacity - 1).downto 0 do	{ i:INTEGER;
      e1 := item i;
      e2 := other.item i;
      (e1 != e2).if {
	((e1!=NULL) && {e2!=NULL}).if {
	  (! e1.is_deep_equal e2).if {
	    result := FALSE;
	  };
	} else {
	  result := FALSE;
	};
      };
    };
    result
  );
  
  //
  // Searching:
  //
  
  - index_of element:E until upper:NUMERIC :NUMERIC <-
  // Give the index of the first occurrence of `element' using
  // `is_equal' for comparison.
  // Answer `upper + 1' when `element' is not inside.
  ( + idx:INTEGER;
    ? {upper>=-1};
    
    {(idx>upper) || {safe_equal element,(item idx)}}.until_do	{
      idx:=idx+1;
    };
    idx
  );
  
  - fast_index_of element:E until upper:NUMERIC :NUMERIC <-
  // Same as `index_of' but use basic `=' for comparison.
  ( + idx:INTEGER;
    ? {upper>=-1};
    
    {(idx>upper) || {element=item idx}}.until_do {
      idx:=idx+1;
    };
    idx
  );
  
  - has element:E until upper:NUMERIC :BOOLEAN <-
  // Look for `element' using `is_equal' for comparison.
  // Also consider `has' to choose the most appropriate.
  ( + result:BOOLEAN;
    ? {upper >= -1};
    result := FALSE;
    upper.downto 0 do { i:INTEGER;
      (safe_equal element,(item i)).if {
	result := TRUE;
      };
    };
    result
  );
  
  - fast_has element:E until upper:NUMERIC :BOOLEAN <-
  // Look for `element' using basic `=' for comparison.
  // Also consider `has' to choose the most appropriate.
  ( + result:BOOLEAN;
    ? {upper >= -1};
    result := FALSE;
    upper.downto 0 do { i:INTEGER;
      (element = item i).if {
	result := TRUE;
      };
    };
    result
  );
  
  //
  // Removing:
  //
  
  - remove_first upper:NUMERIC <-
  // Assume `upper' is a valid index.
  // Move range [1 .. `upper'] by 1 position left.
  ( + i:INTEGER;
    ? {upper >= 0};
    
    {i = upper}.until_do {
      put (item (i + 1)) to i;
      i := i + 1;
    };
  );
  
  - remove index:NUMERIC until upper:NUMERIC <-
  // Assume `upper' is a valid index.
  // Move range [`index' + 1 .. `upper'] by 1 position left.
  ( + i:INTEGER;
    ? {index >= 0};
    ? {index <= upper};
    
    i := index;
    {i = upper}.until_do {
      put (item (i + 1)) to i;
      i := i + 1;
    };
  );
  
  //
  // Replacing:
  //
  
  - replace_all old_value:E with new_value:E until upper:NUMERIC <-
  // Replace all occurences of the element `old_value' by `new_value'
  // using `is_equal' for comparison.
  // See also `fast_replace_all' to choose the apropriate one.
  ( ? {upper >= -1};
    
    upper.downto 0 do { i:INTEGER;
      (safe_equal old_value,(item i)).if {
	put new_value to i;
      };
    };
  );
  
  - fast_replace_all old_value:E with new_value:E until upper:NUMERIC <-
  // Replace all occurences of the element `old_value' by `new_value'
  // using basic `=' for comparison.
  // See also `replace_all' to choose the apropriate one.
  ( ? {upper >= -1};
    
    upper.downto 0 do { i:INTEGER;
      (old_value = item i).if {
	put new_value to i;
      };
    };
  );
  
  //
  // Adding:
  //
  
  - copy src:NATIVE_ARRAY[E] to dest:NUMERIC until src_capacity:NUMERIC <-
  // Copy range [0 .. `src_capacity - 1'] of `src' to range
  // [`at' .. `at + src_capacity - 1'] of `Current'.
  // No subscript checking.
  ( + i1, i2:INTEGER;
    ? {dest >= 0};
    ? {src_capacity >= 0};
    i1 := dest;
    {i2 = src_capacity}.until_do {
      put (src.item i2) to i1;
      i2 := i2 + 1;
      i1 := i1 + 1;
    };
  );
  
  - copy_slice src:NATIVE_ARRAY[E] to dest:NUMERIC from src_min:NUMERIC to src_max:NUMERIC <-
  // Copy range [`src_min' .. `src_max'] of `src' to range
  // [`at' .. `at + src_max - src_min - 1'] of `Current'.
  // No subscript checking.
  ( + i1, i2:INTEGER;
    ? {dest >= 0};
    ? {src_min <= src_max + 1};
    
    i1 := dest;
    i2 := src_min;
    {i2 > src_max}.until_do {
      put (src.item i2) to i1;
      i2 := i2 + 1;
      i1 := i1 + 1;
    };
  );
  
  //
  // Other:
  //
  
  - set_all_with v:E until upper:NUMERIC <-
  // Set all elements in range [0 .. upper] with
  // value `v'.
  (
    upper.downto 0 do { i:INTEGER;
      put v to i;
    };
  );
  
  - clear_all upper:NUMERIC <-
  // Set all elements in range [0 .. `upper'] with
  // the default value.
  ( + v:E;
    
    upper.downto 0 do { i:INTEGER;
      put v to i;
    };
  );
  
  - clear lower:NUMERIC to upper:NUMERIC <-
  // Set all elements in range [`lower' .. `upper'] with
  // the default value
  ( + v:E;
    ? {lower >= 0};
    ? {upper >= lower};
    
    lower.to upper do { i:INTEGER;
      put v to i;
    };
  );
  
  - copy_from model:NATIVE_ARRAY[E] until upper:NUMERIC <-
  // Assume `upper' is a valid index both in Current and `model'.
  (
    upper.downto 0 do { i:INTEGER;
      put (model.item i) to i;
    };
  );
  
  - deep_twin_from capacity:NUMERIC :NATIVE_ARRAY[E] <-
  // To implement `deep_twin'. Allocate a new array of
  // `capacity' initialized with `deep_twin'.
  // Assume `capacity' is valid both in Current and `model'.
  ( + element:E;
    + result:NATIVE_ARRAY[E];
    ? {capacity >= 0};
    
    (capacity > 0).if {
      result := calloc capacity;
      (capacity - 1).downto 0 do { i:INTEGER;
	element := item i;
	(element != NULL).if {
	  element := element.deep_twin;
	};
	result.put element to i;
      };
    };
  );
  
  - move lower:NUMERIC to upper:NUMERIC by offset:NUMERIC <-
  // Move range [`lower' .. `upper'] by `offset' positions.
  // Freed positions are not initialized to default values.
  ( ? {lower >= 0};
    ? {upper >= lower};
    ? {lower + offset >= 0};
    
    (offset != 0).if {
      (offset < 0).if {
	lower.to upper do { i:INTEGER;
	  put (item i) to (i + offset);
	};
      } else {
	upper.downto lower do { i:INTEGER;
	  put (item i) to (i + offset);
	};
      };
    };
  );
  
  - occurrences element:E until upper:NUMERIC :NUMERIC <-
  // Number of occurrences of `element' in range [0..upper]
  // using `equal' for comparison.
  // See also `fast_occurrences' to chose the apropriate one.
  ( + count:INTEGER;
    
    upper.downto 0 do { i:INTEGER;
      (safe_equal element,(item i)).if {
	count := count + 1;
      };
    };
    count
  );
  
  - fast_occurrences element:E until upper:NUMERIC :NUMERIC <-
  // Number of occurrences of `element' in range [0..upper]
  // using basic "=" for comparison.
  // See also `fast_occurrences' to chose the apropriate one.
  ( + count:INTEGER;
    
    upper.downto 0 do { i:INTEGER;
      (element = item i).if {
	count := count + 1;
      };
    };
    count
  );
  
  - all_default upper:NUMERIC :BOOLEAN <-
  // Do all items in range [0 .. `upper'] have their type's
  // default value?
  ( + result:BOOLEAN;
    + model:E;
    ? {upper >= -1};
    result := TRUE;
    upper.downto 0 do { i:INTEGER;
      (model != item i).if {
	result := FALSE;
      };
    };
    result
  );
  
  //
  // Interfacing with C:
  //
  
  - to_external:POINTER <- to_pointer; // OBSOLETE use 'to_pointer'
  // Gives access to the C pointer on the area of storage.
  
  - is_not_null:BOOLEAN <- to_pointer.is_not_null;
  
  //
  // Guru Section
  //
  
  - force_put element:E to index:NUMERIC<-
  // Used in Memory count: not to use directly without caution !
  ( ? {index>=0};
    
    `6`; // External Lisaac #6
    
  );

