/***************************************************************************
*                             Lisaac Library                               *
*                      (c) INRIA 2003 see 'licence.txt' for more details   *
*                      LORIA - UHP - INRIA - FRANCE                        *
*                   Benoit SONNTAG - bsonntag@loria.fr                     *
*                          http://www.IsaacOS.com                          *
***************************************************************************/

section HEADER
  
  + name        :=BASIC_DIRECTORY;   // expanded
  
  - category    :=MICRO;
  
  - bibliography:="http://IsaacOS.com";
  
  - author      :="Boutet Jerome (boutet@loria.fr)";
  
  - comment     :=" Very low-level basic tools for file-system directory\
  \handling and file path manipulation. This class is intended to be\ 
  \platform independant as much as possible. In order to remove from \
  \the client side the burden of file path computation, this class tries\
  \to compute automatically the system file notation using argument(s)\ 
  \of some of the very first call(s).\
  \As soon as the system notation has been properly detected, the result is\
  \internally memorized for all objects of type BASIC_DIRECTORY in a common\
  \private buffer. Besides the low-level nature of operations one can found\
  \in this class, all file path manipulations are done in a smart way\
  \(except when the system file path notation has not been detected\
  \automatically, which is quite uncommon). As an example, even if the\
  \directory separator is internally detected, this information is\
  \_intentionaly_ kept private to avoid low-level manipulation from the\
  \client side. Finally, this class is expanded in order to avoid as much as\
  \possible memory allocations.\
  
  \Also consider high level facade class DIRECTORY if you don't want\
  \to deal directly with low level directory streams.. ";
  
  - external := `#include <dirent.h>`;
  
section INHERIT
  
  - parent_object:OBJECT := OBJECT;
  
section PUBLIC

  + directory_stream:POINTER;
  // This pointer memorize the current directory stream being
  // scanned (used to compute 'is_connected').
  
  + current_entry:POINTER;
  // When 'is_connected', memorize the current entry in the
  // current  'directory_stream'.
  
  // State of 'Current' basic directory stream:
  
  - is_connected:BOOLEAN <-
  // Is 'Current' connected to some directory stream ?
  (    
    directory_stream.is_not_null
  );
  
  - end_of_input:BOOLEAN <-
  // Is end of input reached ?
  (
    ? { is_connected };
    current_entry.is_null
  );
  
  // Connect and disconnect:
  
  - connect_to directory_path:ABSTRACT_STRING <-
  // Try to connect 'Current' to some existing 'directory_path'. After
  // this call, the client is supposed to use 'is_connected' to check
  // that the stream is ready to be used.
  (
    + path_pointer: NATIVE_ARRAY[CHARACTER];
    
    ? {! is_connected };
    ? {! directory_path.is_empty};
    ? { last_entry != directory_path };
    
    path_pointer := directory_path.to_external;
    directory_stream := basic_directory_open path_pointer;
    current_entry := directory_stream;
    last_entry.clear;
    
    ? { is_connected -> ! end_of_input};
  );
  
  - connect_with some_path:ABSTRACT_STRING <-
  // Try to connect 'Current' to some directory using 'some_path' which
  // may  be either an existing directory path or some arbitrary
  // file path name. When 'some_path' is the path of some readable
  // existing directory, this directory is opened and the effect of
  // 'connect_with' is equivalent to 'connect_to'. When 'some_path' is not an
  // existing readable directory path, 'connect_with' tries to open the
  // directory which may contains 'some_path' viewed as a file path
  // name. After this call, the client is supposed to use 'is_connected'
  // to check that the stream is ready to be used and the 'last_entry'
  // buffer to know about the corresponding opened directory path.
  // Whatever the result, 'some_path' is left unchanged.
  (
    + p:NATIVE_ARRAY[CHARACTER];
    
    ? { ! is_connected };
    ? { ! some_path.is_empty };
    ? { last_entry != some_path };
    
    connect_to some_path;
    is_connected.if {
      last_entry.copy some_path;
    } else {
      compute_parent_directory_of some_path;
      (last_entry.count > 0).if {
	p := last_entry.to_external;
	directory_stream := basic_directory_open p;
	current_entry := directory_stream;
	(directory_stream.is_null).if {
	  last_entry.clear;
	};
      } else {
	last_entry.clear;
      };
    };
    
    ? { is_connected -> ! end_of_input};
  );
  
  
  - connect_to_current_working_directory<-
  // Try to connect 'Current' to the current working directory.
  // After this call, the client is supposed to use 'is_connected'
  // to check that the stream is ready to be used and the 'last_entry'
  // buffer to know about the name of the current working directory.
  (
    + path:NATIVE_ARRAY[CHARACTER];
    ? { ! is_connected };
    path := basic_directory_current_working_directory;
    (path != NULL).if {
      last_entry.from_external_copy path;
      directory_stream := basic_directory_open path;
      current_entry := directory_stream;
      (directory_stream.is_null).if {
	last_entry.clear;
      };
    } else {
      last_entry.clear;
    };
    
    ? { is_connected -> ! end_of_input };
  );
  
  
  - disconnect<-
  // Do not forget to call this feature when you have finished
  // with some previously opened directory stream.
  (
    ? { is_connected };
    (basic_directory_close directory_stream).if {
      directory_stream := NULL;
      current_entry := NULL;
    };
    ? { ! is_connected };
  );
  
  // Scanning:
  
  - last_entry:STRING := STRING.create 256;
  // Global buffer to get the last information
  // computed by many routines of this class: 'read_entry', 'connect_with'
  // 'connect_to_current_working_directory', 'compute_parent_directory_of', ...
  
  - read_entry <-
  // Read the next entry name and update 'last_entry' and 'end_of_input'
  // accordingly.
  (
    + name:NATIVE_ARRAY[CHARACTER];
    
    ? { is_connected };
    ? { ! end_of_input };
    
    current_entry := basic_directory_read_entry directory_stream;
    (current_entry.is_not_null).if {
      name := basic_directory_get_entry_name current_entry;
      last_entry.from_external_copy name;
    };
  );
  
  
  // File path handling tools:
  
  - compute_parent_directory_of some_path:ABSTRACT_STRING <-
  // Using 'some_path' (which may be either a file path or a directory
  // path) tries to compute in the 'last_entry' buffer the parent
  // directory of 'some_path'. When 'some_path' is a path with no parent
  // directory, the 'last_entry' buffer 'is_empty' after this call. This
  // operation does not perform any disk access.
  (
    ? { ! some_path.is_empty };
    ? { last_entry != some_path };
    
    last_entry.copy some_path;
    unix_notation.if {
      last_entry.remove_last 1;
      { (last_entry.is_empty) || { last_entry.last == '/'}}.until_do {
	last_entry.remove_last 1;
      };
    }.elseif { windows_notation} then {
      last_entry.remove_last  1;
      { (last_entry.is_empty) || { last_entry.last == '/'}}.until_do {
	last_entry.remove_last 1;
      };
    }.elseif { cygwin_notation} then {
      last_entry.remove_last  1;
      { (last_entry.is_empty) || { last_entry.last == '/'} || { last_entry.last == ':'}}.until_do {
	last_entry.remove_last 1;
      };
      (last_entry.is_empty).if {
      }.elseif { last_entry.first == '/'} then {
	( last_entry.count = 2).if {
	  (last_entry.item 2 == '/').if {
	    last_entry.remove_last 1;
	  };
	};
      };
    }.elseif { system_notation_detected } then {
      last_entry.clear;
    } else {
      set_notation_using some_path;
      system_notation_detected.if {
	compute_parent_directory_of some_path;
      } else {
	last_entry.clear;
      };
    };
  );
  
  - compute_subdirectory_with parent_path,entry_name:ABSTRACT_STRING <-
  // Try to compute in the 'last_entry' buffer the new subdirectory
  // path obtained when trying to concatenate smartly 'parent_path'
  // whith some 'entry_name'. When this fails the 'last_entry' buffer 'is_empty'
  // after this call. This operation does not perform any disk access.
  // Whatever the result, 'parent_path' and  'entry_name' are left unchanged.
  (
    ? { ! parent_path.is_empty };
    ? {! entry_name.is_empty};
    ? {last_entry != parent_path};
    ? { last_entry != entry_name};
    
    last_entry.copy parent_path;
    (unix_notation || {cygwin_notation}).if {
      (".".is_equal entry_name).if {
	// Because you would get the same directory as 'parent_path' and
	// not a new subdirectory as explained before.
	last_entry.clear;
      }.elseif { "..".is_equal entry_name} then {
	// Because you would not get a subdirectory of 'parent_path'.
	last_entry.clear;
      } else {
	last_entry.extend_unless '/';
	(entry_name.first == '/').if {
	  last_entry.remove_last 1;
	};
	last_entry.append entry_name;
	last_entry.extend_unless '/';
      };
    }.elseif { windows_notation } then {
      (".".is_equal entry_name).if {
	// Because you would get the same directory as 'parent_path' and
	// not a new subdirectory as explained before.
	last_entry.clear;
      }.elseif { "..".is_equal entry_name} then {
	// Because you would not get a subdirectory of 'parent_path'.
	last_entry.clear;
      } else {
	last_entry.extend_unless '\\';
	( entry_name.first == '\\').if {
	  last_entry.remove_last 1;
	};
	last_entry.append entry_name;
	last_entry.extend_unless '\\';
      };
    }.elseif { system_notation_detected } then {
      last_entry.clear;
    } else {
      set_notation_using parent_path;
      system_notation_detected.if {
	compute_subdirectory_with parent_path,entry_name;
      } else {
	last_entry.clear;
      };
    };
  );
  
  - compute_file_path_with parent_path, file_name:ABSTRACT_STRING <-
  // Try to compute in the last_entry buffer the new file path obtained
  // when trying to concatenate smartly parent_path whith some
  // file_name. When this fails the last_entry buffer is_empty after
  // this call. This operation does not perform any disk access.
  // Whatever the result, parent_path and file_name are left unchanged.
  (
    ? { ! parent_path.is_empty };
    ? {! file_name.is_empty };
    ? { last_entry != parent_path };
    ? { last_entry != file_name };
    
    last_entry.copy parent_path;
    (unix_notation || { cygwin_notation }).if {
      last_entry.extend_unless '/';
      ( file_name.first == '/').if {
	last_entry.remove_last 1;
      };
      last_entry.append file_name;
    }.elseif { windows_notation } then {
      last_entry.extend_unless '\\';
      (file_name.first == '\\').if {
	last_entry.remove_last 1;
      };
      last_entry.append file_name;
    }.elseif { system_notation_detected } then {
      last_entry.clear;
    } else {
      set_notation_using parent_path;
      ( system_notation_detected ).if {
	compute_file_path_with parent_path,file_name;
      } else {
	last_entry.clear;
      };
    };
  );
  
  - change_current_working_directory directory_path:ABSTRACT_STRING <-
  // Try to change the current working directory using some
  // directory_path. When the operation is possible, the last_entry buffer
  // is updated with the new current working directory path,
  // otherwise, when the modification is not possible the last_entry
  // buffer is_empty after this call. Whatever the result,
  // directory_path is left unchanged.
  (
    + p:NATIVE_ARRAY[CHARACTER];
    ? { ! is_connected };
    ? { last_entry != directory_path };
    
    p := directory_path.to_external;
    ( basic_directory_chdir p).if {
      connect_to_current_working_directory;
      is_connected.if {
	disconnect;
	? {! last_entry.is_empty};
      } else {
	last_entry.clear;
      };
    } else {
      last_entry.clear;
    };
    
    ? { ! is_connected };
  );
  
  // Disk modification:
  
  - create_new_directory directory_path:ABSTRACT_STRING :BOOLEAN <-
  // Try to create a new directory using the directory_path name.
  // Returns true on success.
  (
    + p:POINTER;
    + result:BOOLEAN;
    
    ? { ! is_connected };
    
    p := directory_path.to_pointer;
    result := basic_directory_mkdir p;
    
    ? { ! is_connected };
    result
  );
  
  - remove_directory directory_path:ABSTRACT_STRING :BOOLEAN <-
  // Try to remove directory directory_path which must be empty.
  // Returns true on success.
  (
    + p:NATIVE_ARRAY[CHARACTER];
    + result:BOOLEAN;
    
    ? { ! is_connected };
    
    p := directory_path.to_external;
    result := basic_directory_rmdir p;
    
    ? { ! is_connected };
    result
  );
  
  - remove_files_of directory_path:ABSTRACT_STRING <-
  // Try to remove all files (not subdirectories) of directory
  // specified by directory_path
  (
    ? { ! is_connected };
    connect_to directory_path;
    is_connected.if {
      read_entry;     
      {end_of_input}.until_do {
	tmp_path.copy last_entry;
	compute_file_path_with directory_path,tmp_path;
	tmp_path.copy last_entry;
	remove_file tmp_path;
	read_entry;
      };
      disconnect;
    };
    ? { ! is_connected };
  );
  
  // Miscellaneous:
  
  - is_case_sensitive:BOOLEAN <-
  (	 
    + result:BOOLEAN;
    
    (notation.first == '?').if {
      connect_to_current_working_directory;
      is_connected.if {
	(! last_entry.is_empty).if {
	  set_notation_using last_entry;
	};
	disconnect;
	(notation.first != '?').if {
	  result := is_case_sensitive;
	};
      };
    };
    result
  );
  
  - get_current_working_directory:STRING <-
  (
    + result:STRING;
    result := STRING.create 256;
    result.from_external_copy basic_directory_current_working_directory;
    result
  );
  
  // INSTALL,SYSTEM_TOOLS
  
  + notation:STRING := "?".to_string;
  // Unique common buffer to memorize the system path
  // name notation code.
  
  - valid_notation:BOOLEAN <-
  (
    (notation.count = 1) && { "?UWCVAM".has (notation.first)}
  );
  
  - system_notation_detected:BOOLEAN <-
  (
    ? { valid_notation };
    notation.first != '?'
  );
  
  - unix_notation:BOOLEAN <-
  // The Windows like file path notation looks like:
  //   /Lisaac/lib/io/basic_directory.li
  (
    ? { valid_notation };
    notation.first == 'U'
  );
  
  - windows_notation:BOOLEAN <-
  // The Windows like file path notation looks like:
  //   C:\Lisaac\lib\io\basic_directory.li
  (
    ? { valid_notation };
    notation.first == 'W'
  );
  
  - cygwin_notation:BOOLEAN <-
  // The Cygwin like file path notation looks like:
  //   //C/Lisaac/lib/io/basic_directory.li
  (
    ? { valid_notation };
    notation.first == 'C'
  );
  
  - set_notation_using some_path:ABSTRACT_STRING <-
  // Try to detect automatically the file system notation.
  (
    ? { ! some_path.is_empty };
    ? { ! system_notation_detected };
    ((some_path.first == '/') || {some_path.first == '.'}|| {some_path.first == '~'}).if {
      notation.put 'U' to 1;
      (some_path.count >= 4).if {
	(some_path.item 2 == '/').if {
	  ( some_path.item 4 == '/').if {
	    notation.put 'C' to 1;
	  };
	};
      };
    }.elseif {some_path.first == '\\'} then {
      notation.put 'W' to 1;
    }.elseif {((some_path.first > 'a') && {some_path.first < 'z'}) || {(some_path.first > 'A') && {some_path.first < 'Z'} }} then {
      (some_path.count >= 2).if {
	(some_path.item 2 == ':').if {
	  (some_path.count = 2).if {
	    notation.put 'W' to 1;
	  }.elseif { some_path.has '\\'} then {
	    notation.put 'W' to 1;
	  }.elseif { some_path.has '/'} then {
	    notation.put 'C' to 1;
	  };
	}.elseif {((some_path.item 2 > 'a') && {some_path.item 2 < 'z'}) || {(some_path.item 2 > 'A') && {some_path.item 2 < 'Z'} }} then {
	  notation.put 'U' to 1;
	};
      };
    };
  );
  
  - reset_notation_using some_path:ABSTRACT_STRING <-
  // Try to detect automatically the file system notation.
  (
    notation.put '?' to 1;
    set_notation_using some_path;
  );
  
  + tmp_path:STRING := STRING.create 256;

section PRIVATE  
  
  - basic_directory_open path_pointer:NATIVE_ARRAY[CHARACTER] :POINTER <-
  // Try to open some existing directory using 'path'. When 'Result'
  // 'is_not_null', the directory is correctly opened and 'Result' is
  // a valid handle for this directory. Using 'Result', one can
  // then scan the content of the directory using function
  // 'basic_directory_read_entry' and 'basic_directory_get_entry_name'. Finally,
  // a 'is_not_null' directory must be closed using function
  // 'basic_directory_close'.
  (
    ? { path_pointer.is_not_null};    
    `opendir((char*) @path_pointer)`:POINTER
  );
  
  - basic_directory_read_entry dirstream:POINTER :POINTER <-
  // Read an return a new entry using the directory handle 'dirstream'
  // obtained with function 'basic_directory_open'. When there is no more
  // entry, the 'Result' becomes 'is_null'.
  (
    ? { dirstream.is_not_null };
    `readdir((DIR*) @dirstream)`:POINTER
  );
  
  - basic_directory_get_entry_name entry:POINTER :NATIVE_ARRAY[CHARACTER] <-
  // Read an return a new entry using the directory handle 'dirstream'
  // obtained with function 'basic_directory_open'.
  // When there is no more entry, the 'Result' becomes 'is_null'.
  (
    ? { entry.is_not_null };
    `((struct dirent*)@entry)->d_name`:NATIVE_ARRAY[CHARACTER]
  );
  
  - basic_directory_close dirstream:POINTER :BOOLEAN <-
  // Try to close some opened 'dirstream' directory.
  // A true result indicates that the directory is correctly
  // closed.
  (
    ? { dirstream.is_not_null };
    `closedir((DIR*)@dirstream)`:INTEGER = 0  
  );
  
  - basic_directory_current_working_directory:NATIVE_ARRAY[CHARACTER] <-
  // Try to get the current working directory path.
  (
    + buf:NATIVE_ARRAY[CHARACTER];
    buf := NATIVE_ARRAY[CHARACTER].calloc 256;
    `getcwd((char *)@buf,256)`:NATIVE_ARRAY[CHARACTER]
  );
  
  - basic_directory_chdir destination:NATIVE_ARRAY[CHARACTER] :BOOLEAN <-
  // Try to change the current working directory using 'destination'.
  (
    `chdir((char*)@destination)`:INTEGER = 0
  );
  
  - basic_directory_mkdir directory_path:NATIVE_ARRAY[CHARACTER] :BOOLEAN <-
  // Try to create a new directory using 'directory_path'.
  (
    `mkdir((char*)@directory_path,0777)`:INTEGER = 0
  );
  
  - basic_directory_rmdir directory_path:NATIVE_ARRAY[CHARACTER] :BOOLEAN <-
  // Try to remove 'directory_path'.
  (
    `rmdir((char*)@directory_path)`:INTEGER = 0
  );  
